{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/img/bg/bg.webp","path":"img/bg/bg.webp","modified":0,"renderable":0},{"_id":"source/img/favicon/favicon.png","path":"img/favicon/favicon.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/callapplybind.md","hash":"ec6b5e51843ced74abd96838e226e6535d520114","modified":1721800454622},{"_id":"source/_posts/gitCommand.md","hash":"3f47068dd630171f783bf99f4f99c70cdfa46d80","modified":1721800454623},{"_id":"source/_posts/jsAsync.md","hash":"558f1d98eb92322b3c5c90b16356351afc5c3388","modified":1721800454623},{"_id":"source/_posts/markdown.md","hash":"c1bd5028ac9f772d9ce2d31c41e58ac7333662bb","modified":1721800454624},{"_id":"source/_posts/reg.md","hash":"bc4aa7f934c8ae027fe934ff310338e3b5ef3734","modified":1721800454624},{"_id":"source/_posts/shellCommand.md","hash":"4685d218945eb35570897236c7ccc29af59765de","modified":1721800454624},{"_id":"source/_posts/webServerPush.md","hash":"d9f8c588be9f7ed118953c1d787f5de889cc4cdd","modified":1721800454625},{"_id":"source/about/index.md","hash":"0607505c25f534ca59a240e900958855a62fc7ec","modified":1721800454625},{"_id":"source/img/bg/bg.webp","hash":"e665a25157f52a255f2e704f8c6f6c2a7ef4a16a","modified":1721800454625},{"_id":"source/img/favicon/favicon.png","hash":"e05dd4108bdcb01038c1556b1eba14eae6897fe5","modified":1721800454626},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"d5ed15fd87806915a5d1ca822d2218862f788a95","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"e9dc7054ffcbb54ff6fb9aa485c524f0c3ded0c6","modified":1721800481926},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"23e5db06cfdc1cb26503204f074db58647adfbf3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"952d3f27cd7a245848fa1c4a1f5c8912500c2ee1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"1452acee33611685b199c50e1bd4ecddbf6424e3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"edcbef65037759c3a7b3539f2edcd72b082267e9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"a4a6b184bd91d9fe090da28891e74afc3b71c7fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"3a812de943457c0c544832daa1957420883aca96","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"eb2c46aa2508ea65d6e5c397c4bc20d05761d754","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"536eedc03faae3b35dc69abd478634d453061a0a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"3d8912b68fcf51c38f6e1c5dd2bd74657bb3b7fb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"57358e2164284f33f3bc81d5f602c620aeab942f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"ef56f0903762a7a2c853417dfa6b0463440295e0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"129a8b19ab26efd02ff1806ff4012376d2cd3497","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"c80bdc171aa53eb7205dcdc77764cec87a1dafd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"359cbcb0e222c23c8a0c5a99034a8a51f667a9ce","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"54933c294d9b469a76a5ed36328e778ed740158f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"cb78296da15c7a8a6957cff2129294cc4815513b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"2465f604eea63b14cd2b0cc142769d963a0193a0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"5f4a17a20ddbf18c8ea6c66638b764905e4386b3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"e24cd1186aae10bf897eed9cfd5278247b6300eb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"e6e48d6ba2951ce4abc2876600f85eef64095338","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"078e5496a1852952ce4ee49016e86b9f70d31908","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"696e429284bda7ae0fffe62ca84cb01a9243ecf0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":499162500000},{"_id":"source/_posts/hooks.md","hash":"543c0afa52c657bd93db8015e05e9423e8255e94","modified":1721800798739},{"_id":"source/_posts/interview.md","hash":"7ab561e9620401f950ccc26e2ee15cde629f63e6","modified":1721803852495},{"_id":"source/_posts/jsModel.md","hash":"5bc9f2a1806db0340ef61c7b5bf6c19c6e1c970e","modified":1721803837669},{"_id":"source/_posts/jsPrototype.md","hash":"c0295a8967719a18d9b929573d7e2ec3e9c74713","modified":1721804391020},{"_id":"source/_posts/inNetwork.md","hash":"b0d8863af0ddf587a736d8aa3ff195408f85dea3","modified":1729650189870},{"_id":"public/local-search.xml","hash":"a203ff5fde570851cd062ca96fd9b368ae3c4984","modified":1729650965258},{"_id":"public/archives/index.html","hash":"0d625e641cdab3c2c469be9fcad31a6c8d4cdca5","modified":1729650965258},{"_id":"public/archives/2022/index.html","hash":"01024a78144f2a5db6843e768431d51abd811fd2","modified":1729650965258},{"_id":"public/archives/2022/04/index.html","hash":"6d937d0dd6f1eff200b12762cc2a8af02fdf4f37","modified":1729650965258},{"_id":"public/archives/2022/05/index.html","hash":"0be0af68bcb77e4ae9c64fd7241eae978fed897b","modified":1729650965258},{"_id":"public/archives/2022/08/index.html","hash":"deac34cb583ca3db08d7feed6a93ad875b3199da","modified":1729650965258},{"_id":"public/archives/2024/index.html","hash":"ab11dfe4d39cb322ff649edf9a0f806ca20c2a76","modified":1729650965258},{"_id":"public/archives/2022/10/index.html","hash":"e311dc9e0fe765918083b48a0635a0fceb0259a9","modified":1729650965258},{"_id":"public/archives/2024/10/index.html","hash":"8675f8120eb1bb4b1df0adf8df753f4cd5c7f24d","modified":1729650965258},{"_id":"public/archives/2024/07/index.html","hash":"5635b247fa8e6a052b7251bd086074fa659f3398","modified":1729650965258},{"_id":"public/page/2/index.html","hash":"3015667b5942c1434dbfa94005a9ce6e00fb0ece","modified":1729650965258},{"_id":"public/tags/js/index.html","hash":"7e5832e06a02b9b616087a8fecb72f128679c177","modified":1729650965258},{"_id":"public/tags/JS/index.html","hash":"46b068c03c9b001ac7ce6bafa417c9f716e81471","modified":1729650965258},{"_id":"public/tags/web/index.html","hash":"af7310ed74188d9e71fd4c9ae4cfaa45e0cb405d","modified":1729650965258},{"_id":"public/tags/reg/index.html","hash":"2e4897eb4a6f4e152a1951e3008ff4b03c0de07a","modified":1729650965258},{"_id":"public/archives/page/2/index.html","hash":"64c3c8c97638c4300cf43edf898ee6c27cfec771","modified":1729650965258},{"_id":"public/tags/index.html","hash":"bf1c08190e9f038947e8b937891bc18b1968494b","modified":1729650965258},{"_id":"public/categories/index.html","hash":"fd09d8d8da3b40c3850b55a3b4c484d3e62d2e54","modified":1729650965258},{"_id":"public/about/index.html","hash":"418c6c6a993891b59a334de0859cb4f9911643cf","modified":1729650965258},{"_id":"public/404.html","hash":"fb4b3624a0b5d2c049e0dd36e12c607c3860e120","modified":1729650965258},{"_id":"public/links/index.html","hash":"adbf19926da3d932b9995e6b279e44423cafae5a","modified":1729650965258},{"_id":"public/2024/10/23/inNetwork/index.html","hash":"9cf2759ace915f7381eb92f224c0d9c32f9530f3","modified":1729650965258},{"_id":"public/2024/07/24/jsPrototype/index.html","hash":"9e0fadb837926b1f66df5f9fa34bf7954e8f1d20","modified":1729650965258},{"_id":"public/2024/07/24/jsModel/index.html","hash":"61b1c7da7a98def2e54a1316487435bb5e909be5","modified":1729650965258},{"_id":"public/2024/07/24/interview/index.html","hash":"dbbe97586fb4ca23b6dd89f5bcf245f917b82019","modified":1729650965258},{"_id":"public/2024/07/24/callapplybind/index.html","hash":"3bc00875d412fc2b35a2b3187eec52922d8e3b83","modified":1729650965258},{"_id":"public/2024/07/24/hooks/index.html","hash":"af6afd39715c44785e97d65d2b4f0206fcb6bd1a","modified":1729650965258},{"_id":"public/2022/10/28/reg/index.html","hash":"608db8b957cba83abd56bf25adc86ea685e4e001","modified":1729650965258},{"_id":"public/2022/10/10/jsAsync/index.html","hash":"e90b162d2d91fed9f2e82e1224095434932e0fe7","modified":1729650965258},{"_id":"public/2022/08/14/webServerPush/index.html","hash":"b98cfc2b90c62ab3c59903a063a0d63b33fd6237","modified":1729650965258},{"_id":"public/2022/05/02/shellCommand/index.html","hash":"3f97025276b408349419d14a1ae23dc1c3218e27","modified":1729650965258},{"_id":"public/2022/05/19/gitCommand/index.html","hash":"e80987d6682ce2b9fd62798c3bc2cddf8f5a7571","modified":1729650965258},{"_id":"public/2022/04/03/markdown/index.html","hash":"db02b12b9bc9d91b41c6c3b840336013391311b5","modified":1729650965258},{"_id":"public/index.html","hash":"2298674b704fc20c23a0203d408832e499d1d319","modified":1729650965258}],"Category":[],"Data":[],"Page":[{"title":"关于我","date":"2022-04-03T08:12:17.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-04-03 16:12:17\nlayout: about\n---\n","updated":"2024-07-24T05:54:14.625Z","path":"about/index.html","comments":1,"_id":"clyzfl2pb0000lyxx0glm8c89","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"Post":[{"title":"call、apply、bind的区别与应用场景","date":"2024-07-24T05:54:14.622Z","_content":"## call、apply、bind\n### 为什么会有call和apply？\ncall和apply两个方法的作用基本相同，它们都是为了改变某个函数执行时的上下文（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部this 的指向。\n\n``` javascript\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor();//red\nsayColor.call(this);//red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)\nsayColor.call(window);//red，把函数体sayColor内部的this，绑到window（全局作用域）\nsayColor.call(o);//blue\n```\n\n### call( thisValue , arg1, arg2, ... )\n> 注意：如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。\n``` javascript\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor.call(this);//red\nsayColor.call(window);//red\nsayColor.call();\nsayColor.call(null);\nsayColor.call(undefined);\nsayColor.call(o);//blue\n```\n### 应用场景\n+ 判断对象类型\n``` javascript\nvar arr = [];\nObject.prototype.toString.call(arr); // [object Array]\n//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）\n```\n\n### 手撕call\n``` js\n\tvar foo = {\n\t  count: 1\n\t};\n\tfunction bar() {\n\t  console.log(this.count);\n\t}\n\tbar.myCall(foo); // 1\n--------------------------------------------------------------------\n\tFunction.prototype.myCall = function(context) {\n\t  // 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo\n\t  // 不传第一个参数，默认是window,\n\t  var context = context || window;\n\t  // 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数\n\t  context.fn = this;//这里的context.fn就相当于上文的bar函数\n\t  // 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表\n\t  var args = [...arguments].slice(1);\n\t  // 执行函数（相当于上文的bar(...args)）\n\t  var result = context.fn(...args);\n\t  // 删除函数\n\t  delete context.fn;\n\t  return result;\n\t};\n```\n\n### apply( thisValue , [arg1, arg2, ...] )\n很明显，我们看标题的可以知道call和apply的一个区别了，它们两个唯一的区别就是传参列表的不同，apply是接收的参数是一个数组。\n\n### 手撕apply\n\n``` js\n\tvar foo = {\n\t  count: 1\n\t};\n\tfunction bar() {\n\t  console.log(this.count);\n\t}\n\tbar.myApply(foo); // 1\n--------------------------------------------------------------------\n  Function.prototype.myApply = function(context) {\n    var context = context || window;\n    context.fn = this;\n    var result;\n    // 判断第二个参数是否存在，也就是context后面有没有一个数组\n    // 如果存在，则需要展开第二个参数\n    if (arguments[1]) {\n      result = context.fn(...arguments[1]);\n    } else {\n      result = context.fn();\n    }\n    delete context.fn;\n    return result;\n  }\n```\n\n### 应用场景\n+ 找出数组中最大或最小的元素\n\n``` js\n    var a = [10, 2, 4, 15, 9];\n    Math.max.apply(Math, a); // 15\n    Math.min.apply(null, a); // 2\n    /* ES6的方法 */\n    Math.max(...[10, 2, 4, 15, 9]); // 12 等同于Math.max(10, 2, 4, 15, 9);t\n```\n\n+ 可以将一个类似（伪）数组的对象（比如arguments对象）转为真正的数组。 前提： 被处理的对象必须有length属性，以及相对应的数字键。\n\n``` js\n  var ArrayLike = { // 一个类似数组的对象\n    0: 'a',\n    1: 'b',\n    2: 'c',\n    length: 3\n  }\n  //接收的是对象，返回的是数组\n  Array.prototype.slice.apply({0: 1, length: 1}) // [1]\n  Array.prototype.slice.apply({0: 1}) // []\n  Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]\n  Array.prototype.slice.apply({length: 1}) // [undefined]\n  //（切下）[].slice(1, n)，返回索引为1到索引为n-1的数组\n\n  /* ES6的方法 */\n  Array.from(ArrayLike); // [\"a\", \"b\", \"c\"]\n\n  // 没有部署Iterator接口的类似数组的对象，扩展运算符就“无法”将其转为真正的数组，但Array.from()可以\n  ...ArrayLike; //  Found non-callable @@iterator\n  // 只要是部署了Iterator接口的数据结构，Array.from 都能将其转为数组\n```\n\n+ 数组追加\n\n``` js\nvar arr1 = [1,2,3];\nvar arr2 = [4,5,6];\n[].push.apply(arr1, arr2);\nconsole.log(arr1); // [1, 2, 3, 4, 5, 6]\nconsole.log(arr2); // [4, 5, 6]\n/* ES6的方法 */\narr1.push(...arr2); // [1, 2, 3, 4, 5, 6]\n```\n\n+ 数组合并\n\n``` js\nvar arr1 = [1, 2, { id: 1, id: 2 }, [1, 2]];\nvar arr2 = ['ds', 1, 9, { name: 'jack' }];\n// var arr = arr1.concat(arr2);//简单做法\nArray.prototype.push.apply(arr1,arr2)\nconsole.log(arr1);\n/* ES6的方法 */\n[...arr1,...arr2]\n```\n\n### bind( thisArg[, arg1[, arg2[, ...]]])\n+ call和apply它们两个是改变this的指向之后立即调用该函数，而bind则不同，它是创建一个新函数，我们必须手动去调用它。\n+ bind()是ES5新增的一个方法\n+ 传参和call或apply类似\n+ 不会执行对应的函数，call或apply会自动执行对应的函数\n+ bind会返回对函数的引用\n\n### 举个栗子\n\n``` js\n  var a ={\n      name : \"Cherry\",\n      fn : function (a,b) {\n          console.log( a + b)\n      }\n  }\n  var b = a.fn;\n  b.call(a,1,2);//立即调用该函数\n  b.bind(a,1,2)();//手动调用()，它返回一个原函数的拷贝（新的，不是原函数），并拥有指定的this值和初始参数。\n```\n\n### 应用场景\n\n``` js\n  var obj = {\n    name:'JuctTr',\n    age: 18\n  };\n  /**\n   * 给document添加click事件监听，并绑定ExecuteFun函数\n   * 通过bind方法设置ExecuteFun的this为obj\n   */\n  //document.addEventListener('click',ExecuteFun.call(obj),false);\n  document.addEventListener('click',ExecuteFun.bind(obj),false);\t\t\n  function ExecuteFun(a,b){\n      console.log(this.name, this.age);\n  }\n```\n\n### 手撕bind\n\n``` js\nFunction.prototype.myBind = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  var _this = this\n  var args = [...arguments].slice(1)\n  // 返回一个函数\n  return function F() {\n    // 因为返回了一个函数，我们可以 new F()，所以需要判断\n    if (this instanceof F) {\n      return new _this(...args, ...arguments)\n    }\n    return _this.apply(context, args.concat(...arguments))\n  }\n}\n```\n","source":"_posts/callapplybind.md","raw":"---\ntitle: call、apply、bind的区别与应用场景\ndate: \ntags: js\n---\n## call、apply、bind\n### 为什么会有call和apply？\ncall和apply两个方法的作用基本相同，它们都是为了改变某个函数执行时的上下文（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部this 的指向。\n\n``` javascript\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor();//red\nsayColor.call(this);//red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)\nsayColor.call(window);//red，把函数体sayColor内部的this，绑到window（全局作用域）\nsayColor.call(o);//blue\n```\n\n### call( thisValue , arg1, arg2, ... )\n> 注意：如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。\n``` javascript\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\nfunction sayColor(){\n\talert(this.color);\n}\nsayColor.call(this);//red\nsayColor.call(window);//red\nsayColor.call();\nsayColor.call(null);\nsayColor.call(undefined);\nsayColor.call(o);//blue\n```\n### 应用场景\n+ 判断对象类型\n``` javascript\nvar arr = [];\nObject.prototype.toString.call(arr); // [object Array]\n//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）\n```\n\n### 手撕call\n``` js\n\tvar foo = {\n\t  count: 1\n\t};\n\tfunction bar() {\n\t  console.log(this.count);\n\t}\n\tbar.myCall(foo); // 1\n--------------------------------------------------------------------\n\tFunction.prototype.myCall = function(context) {\n\t  // 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo\n\t  // 不传第一个参数，默认是window,\n\t  var context = context || window;\n\t  // 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数\n\t  context.fn = this;//这里的context.fn就相当于上文的bar函数\n\t  // 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表\n\t  var args = [...arguments].slice(1);\n\t  // 执行函数（相当于上文的bar(...args)）\n\t  var result = context.fn(...args);\n\t  // 删除函数\n\t  delete context.fn;\n\t  return result;\n\t};\n```\n\n### apply( thisValue , [arg1, arg2, ...] )\n很明显，我们看标题的可以知道call和apply的一个区别了，它们两个唯一的区别就是传参列表的不同，apply是接收的参数是一个数组。\n\n### 手撕apply\n\n``` js\n\tvar foo = {\n\t  count: 1\n\t};\n\tfunction bar() {\n\t  console.log(this.count);\n\t}\n\tbar.myApply(foo); // 1\n--------------------------------------------------------------------\n  Function.prototype.myApply = function(context) {\n    var context = context || window;\n    context.fn = this;\n    var result;\n    // 判断第二个参数是否存在，也就是context后面有没有一个数组\n    // 如果存在，则需要展开第二个参数\n    if (arguments[1]) {\n      result = context.fn(...arguments[1]);\n    } else {\n      result = context.fn();\n    }\n    delete context.fn;\n    return result;\n  }\n```\n\n### 应用场景\n+ 找出数组中最大或最小的元素\n\n``` js\n    var a = [10, 2, 4, 15, 9];\n    Math.max.apply(Math, a); // 15\n    Math.min.apply(null, a); // 2\n    /* ES6的方法 */\n    Math.max(...[10, 2, 4, 15, 9]); // 12 等同于Math.max(10, 2, 4, 15, 9);t\n```\n\n+ 可以将一个类似（伪）数组的对象（比如arguments对象）转为真正的数组。 前提： 被处理的对象必须有length属性，以及相对应的数字键。\n\n``` js\n  var ArrayLike = { // 一个类似数组的对象\n    0: 'a',\n    1: 'b',\n    2: 'c',\n    length: 3\n  }\n  //接收的是对象，返回的是数组\n  Array.prototype.slice.apply({0: 1, length: 1}) // [1]\n  Array.prototype.slice.apply({0: 1}) // []\n  Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]\n  Array.prototype.slice.apply({length: 1}) // [undefined]\n  //（切下）[].slice(1, n)，返回索引为1到索引为n-1的数组\n\n  /* ES6的方法 */\n  Array.from(ArrayLike); // [\"a\", \"b\", \"c\"]\n\n  // 没有部署Iterator接口的类似数组的对象，扩展运算符就“无法”将其转为真正的数组，但Array.from()可以\n  ...ArrayLike; //  Found non-callable @@iterator\n  // 只要是部署了Iterator接口的数据结构，Array.from 都能将其转为数组\n```\n\n+ 数组追加\n\n``` js\nvar arr1 = [1,2,3];\nvar arr2 = [4,5,6];\n[].push.apply(arr1, arr2);\nconsole.log(arr1); // [1, 2, 3, 4, 5, 6]\nconsole.log(arr2); // [4, 5, 6]\n/* ES6的方法 */\narr1.push(...arr2); // [1, 2, 3, 4, 5, 6]\n```\n\n+ 数组合并\n\n``` js\nvar arr1 = [1, 2, { id: 1, id: 2 }, [1, 2]];\nvar arr2 = ['ds', 1, 9, { name: 'jack' }];\n// var arr = arr1.concat(arr2);//简单做法\nArray.prototype.push.apply(arr1,arr2)\nconsole.log(arr1);\n/* ES6的方法 */\n[...arr1,...arr2]\n```\n\n### bind( thisArg[, arg1[, arg2[, ...]]])\n+ call和apply它们两个是改变this的指向之后立即调用该函数，而bind则不同，它是创建一个新函数，我们必须手动去调用它。\n+ bind()是ES5新增的一个方法\n+ 传参和call或apply类似\n+ 不会执行对应的函数，call或apply会自动执行对应的函数\n+ bind会返回对函数的引用\n\n### 举个栗子\n\n``` js\n  var a ={\n      name : \"Cherry\",\n      fn : function (a,b) {\n          console.log( a + b)\n      }\n  }\n  var b = a.fn;\n  b.call(a,1,2);//立即调用该函数\n  b.bind(a,1,2)();//手动调用()，它返回一个原函数的拷贝（新的，不是原函数），并拥有指定的this值和初始参数。\n```\n\n### 应用场景\n\n``` js\n  var obj = {\n    name:'JuctTr',\n    age: 18\n  };\n  /**\n   * 给document添加click事件监听，并绑定ExecuteFun函数\n   * 通过bind方法设置ExecuteFun的this为obj\n   */\n  //document.addEventListener('click',ExecuteFun.call(obj),false);\n  document.addEventListener('click',ExecuteFun.bind(obj),false);\t\t\n  function ExecuteFun(a,b){\n      console.log(this.name, this.age);\n  }\n```\n\n### 手撕bind\n\n``` js\nFunction.prototype.myBind = function (context) {\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  var _this = this\n  var args = [...arguments].slice(1)\n  // 返回一个函数\n  return function F() {\n    // 因为返回了一个函数，我们可以 new F()，所以需要判断\n    if (this instanceof F) {\n      return new _this(...args, ...arguments)\n    }\n    return _this.apply(context, args.concat(...arguments))\n  }\n}\n```\n","slug":"callapplybind","published":1,"updated":"2024-07-24T05:54:14.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2pg0001lyxx0o9qeyb8","content":"<h2 id=\"call、apply、bind\"><a href=\"#call、apply、bind\" class=\"headerlink\" title=\"call、apply、bind\"></a>call、apply、bind</h2><h3 id=\"为什么会有call和apply？\"><a href=\"#为什么会有call和apply？\" class=\"headerlink\" title=\"为什么会有call和apply？\"></a>为什么会有call和apply？</h3><p>call和apply两个方法的作用基本相同，它们都是为了改变某个函数执行时的上下文（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部this 的指向。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;blue&quot;</span>&#125;;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sayColor</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span>);<br>&#125;<br><span class=\"hljs-title function_\">sayColor</span>();<span class=\"hljs-comment\">//red</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>);<span class=\"hljs-comment\">//red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">window</span>);<span class=\"hljs-comment\">//red，把函数体sayColor内部的this，绑到window（全局作用域）</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(o);<span class=\"hljs-comment\">//blue</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"call-thisValue-arg1-arg2-…\"><a href=\"#call-thisValue-arg1-arg2-…\" class=\"headerlink\" title=\"call( thisValue , arg1, arg2, … )\"></a>call( thisValue , arg1, arg2, … )</h3><blockquote>\n<p>注意：如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;blue&quot;</span>&#125;;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sayColor</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span>);<br>&#125;<br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>);<span class=\"hljs-comment\">//red</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">window</span>);<span class=\"hljs-comment\">//red</span><br>sayColor.<span class=\"hljs-title function_\">call</span>();<br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>);<br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>);<br>sayColor.<span class=\"hljs-title function_\">call</span>(o);<span class=\"hljs-comment\">//blue</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li>判断对象类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [];<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(arr); <span class=\"hljs-comment\">// [object Array]</span><br><span class=\"hljs-comment\">//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"手撕call\"><a href=\"#手撕call\" class=\"headerlink\" title=\"手撕call\"></a>手撕call</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">\t<span class=\"hljs-keyword\">var</span> foo = &#123;<br>\t  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span><br>\t&#125;;<br>\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>\t  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>);<br>\t&#125;<br>\tbar.<span class=\"hljs-title function_\">myCall</span>(foo); <span class=\"hljs-comment\">// 1</span><br>--------------------------------------------------------------------<br>\t<span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myCall</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context</span>) &#123;<br>\t  <span class=\"hljs-comment\">// 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo</span><br>\t  <span class=\"hljs-comment\">// 不传第一个参数，默认是window,</span><br>\t  <span class=\"hljs-keyword\">var</span> context = context || <span class=\"hljs-variable language_\">window</span>;<br>\t  <span class=\"hljs-comment\">// 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数</span><br>\t  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span>;<span class=\"hljs-comment\">//这里的context.fn就相当于上文的bar函数</span><br>\t  <span class=\"hljs-comment\">// 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表</span><br>\t  <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>);<br>\t  <span class=\"hljs-comment\">// 执行函数（相当于上文的bar(...args)）</span><br>\t  <span class=\"hljs-keyword\">var</span> result = context.<span class=\"hljs-title function_\">fn</span>(...args);<br>\t  <span class=\"hljs-comment\">// 删除函数</span><br>\t  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span>;<br>\t  <span class=\"hljs-keyword\">return</span> result;<br>\t&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"apply-thisValue-arg1-arg2-…\"><a href=\"#apply-thisValue-arg1-arg2-…\" class=\"headerlink\" title=\"apply( thisValue , [arg1, arg2, …] )\"></a>apply( thisValue , [arg1, arg2, …] )</h3><p>很明显，我们看标题的可以知道call和apply的一个区别了，它们两个唯一的区别就是传参列表的不同，apply是接收的参数是一个数组。</p>\n<h3 id=\"手撕apply\"><a href=\"#手撕apply\" class=\"headerlink\" title=\"手撕apply\"></a>手撕apply</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">\t<span class=\"hljs-keyword\">var</span> foo = &#123;<br>\t  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span><br>\t&#125;;<br>\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>\t  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>);<br>\t&#125;<br>\tbar.<span class=\"hljs-title function_\">myApply</span>(foo); <span class=\"hljs-comment\">// 1</span><br>--------------------------------------------------------------------<br>  <span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myApply</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> context = context || <span class=\"hljs-variable language_\">window</span>;<br>    context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span>;<br>    <span class=\"hljs-keyword\">var</span> result;<br>    <span class=\"hljs-comment\">// 判断第二个参数是否存在，也就是context后面有没有一个数组</span><br>    <span class=\"hljs-comment\">// 如果存在，则需要展开第二个参数</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]) &#123;<br>      result = context.<span class=\"hljs-title function_\">fn</span>(...<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      result = context.<span class=\"hljs-title function_\">fn</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span>;<br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li>找出数组中最大或最小的元素</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">9</span>];<br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">max</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-title class_\">Math</span>, a); <span class=\"hljs-comment\">// 15</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">min</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, a); <span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-comment\">/* ES6的方法 */</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...[<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">9</span>]); <span class=\"hljs-comment\">// 12 等同于Math.max(10, 2, 4, 15, 9);t</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>可以将一个类似（伪）数组的对象（比如arguments对象）转为真正的数组。 前提： 被处理的对象必须有length属性，以及相对应的数字键。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ArrayLike</span> = &#123; <span class=\"hljs-comment\">// 一个类似数组的对象</span><br>  <span class=\"hljs-number\">0</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>  <span class=\"hljs-number\">1</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>,<br>  <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>,<br>  <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span><br>&#125;<br><span class=\"hljs-comment\">//接收的是对象，返回的是数组</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// [1]</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// []</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">2</span>&#125;) <span class=\"hljs-comment\">// [1, undefined]</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// [undefined]</span><br><span class=\"hljs-comment\">//（切下）[].slice(1, n)，返回索引为1到索引为n-1的数组</span><br><br><span class=\"hljs-comment\">/* ES6的方法 */</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title class_\">ArrayLike</span>); <span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><br><span class=\"hljs-comment\">// 没有部署Iterator接口的类似数组的对象，扩展运算符就“无法”将其转为真正的数组，但Array.from()可以</span><br>...<span class=\"hljs-title class_\">ArrayLike</span>; <span class=\"hljs-comment\">//  Found non-callable @@iterator</span><br><span class=\"hljs-comment\">// 只要是部署了Iterator接口的数据结构，Array.from 都能将其转为数组</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>数组追加</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>];<br>[].<span class=\"hljs-property\">push</span>.<span class=\"hljs-title function_\">apply</span>(arr1, arr2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr1); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr2); <span class=\"hljs-comment\">// [4, 5, 6]</span><br><span class=\"hljs-comment\">/* ES6的方法 */</span><br>arr1.<span class=\"hljs-title function_\">push</span>(...arr2); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>数组合并</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span> &#125;, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-string\">&#x27;ds&#x27;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">9</span>, &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;jack&#x27;</span> &#125;];<br><span class=\"hljs-comment\">// var arr = arr1.concat(arr2);//简单做法</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">push</span>.<span class=\"hljs-title function_\">apply</span>(arr1,arr2)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr1);<br><span class=\"hljs-comment\">/* ES6的方法 */</span><br>[...arr1,...arr2]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"bind-thisArg-arg1-arg2-…\"><a href=\"#bind-thisArg-arg1-arg2-…\" class=\"headerlink\" title=\"bind( thisArg[, arg1[, arg2[, …]]])\"></a>bind( thisArg[, arg1[, arg2[, …]]])</h3><ul>\n<li>call和apply它们两个是改变this的指向之后立即调用该函数，而bind则不同，它是创建一个新函数，我们必须手动去调用它。</li>\n<li>bind()是ES5新增的一个方法</li>\n<li>传参和call或apply类似</li>\n<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>\n<li>bind会返回对函数的引用</li>\n</ul>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a =&#123;<br>    name : <span class=\"hljs-string\">&quot;Cherry&quot;</span>,<br>    fn : <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a,b</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( a + b)<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> b = a.<span class=\"hljs-property\">fn</span>;<br>b.<span class=\"hljs-title function_\">call</span>(a,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//立即调用该函数</span><br>b.<span class=\"hljs-title function_\">bind</span>(a,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)();<span class=\"hljs-comment\">//手动调用()，它返回一个原函数的拷贝（新的，不是原函数），并拥有指定的this值和初始参数。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;JuctTr&#x27;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span><br>&#125;;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 给document添加click事件监听，并绑定ExecuteFun函数</span><br><span class=\"hljs-comment\"> * 通过bind方法设置ExecuteFun的this为obj</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">//document.addEventListener(&#x27;click&#x27;,ExecuteFun.call(obj),false);</span><br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-title class_\">ExecuteFun</span>.<span class=\"hljs-title function_\">bind</span>(obj),<span class=\"hljs-literal\">false</span>);\t\t<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ExecuteFun</span>(<span class=\"hljs-params\">a,b</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"手撕bind\"><a href=\"#手撕bind\" class=\"headerlink\" title=\"手撕bind\"></a>手撕bind</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br>  &#125;<br>  <span class=\"hljs-keyword\">var</span> _this = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)<br>  <span class=\"hljs-comment\">// 返回一个函数</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span> <span class=\"hljs-keyword\">instanceof</span> F) &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">_this</span>(...args, ...<span class=\"hljs-variable language_\">arguments</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> _this.<span class=\"hljs-title function_\">apply</span>(context, args.<span class=\"hljs-title function_\">concat</span>(...<span class=\"hljs-variable language_\">arguments</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":4484,"excerpt":"","more":"<h2 id=\"call、apply、bind\"><a href=\"#call、apply、bind\" class=\"headerlink\" title=\"call、apply、bind\"></a>call、apply、bind</h2><h3 id=\"为什么会有call和apply？\"><a href=\"#为什么会有call和apply？\" class=\"headerlink\" title=\"为什么会有call和apply？\"></a>为什么会有call和apply？</h3><p>call和apply两个方法的作用基本相同，它们都是为了改变某个函数执行时的上下文（context）而建立的， 他的真正强大之处就是能够扩充函数赖以运行的作用域。通俗一点讲，就是改变函数体内部this 的指向。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;blue&quot;</span>&#125;;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sayColor</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span>);<br>&#125;<br><span class=\"hljs-title function_\">sayColor</span>();<span class=\"hljs-comment\">//red</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>);<span class=\"hljs-comment\">//red，把函数体sayColor内部的this，绑到当前环境（作用域）(这段代码所处的环境)</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">window</span>);<span class=\"hljs-comment\">//red，把函数体sayColor内部的this，绑到window（全局作用域）</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(o);<span class=\"hljs-comment\">//blue</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"call-thisValue-arg1-arg2-…\"><a href=\"#call-thisValue-arg1-arg2-…\" class=\"headerlink\" title=\"call( thisValue , arg1, arg2, … )\"></a>call( thisValue , arg1, arg2, … )</h3><blockquote>\n<p>注意：如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&quot;red&quot;</span>;<br><span class=\"hljs-keyword\">var</span> o = &#123;<span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">&quot;blue&quot;</span>&#125;;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sayColor</span>(<span class=\"hljs-params\"></span>)&#123;<br>\t<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">color</span>);<br>&#125;<br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">this</span>);<span class=\"hljs-comment\">//red</span><br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">window</span>);<span class=\"hljs-comment\">//red</span><br>sayColor.<span class=\"hljs-title function_\">call</span>();<br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>);<br>sayColor.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>);<br>sayColor.<span class=\"hljs-title function_\">call</span>(o);<span class=\"hljs-comment\">//blue</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li>判断对象类型<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> arr = [];<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(arr); <span class=\"hljs-comment\">// [object Array]</span><br><span class=\"hljs-comment\">//把函数体Object.prototype.toString()方法内部的this，绑到arr的执行环境（作用域）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"手撕call\"><a href=\"#手撕call\" class=\"headerlink\" title=\"手撕call\"></a>手撕call</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">\t<span class=\"hljs-keyword\">var</span> foo = &#123;<br>\t  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span><br>\t&#125;;<br>\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>\t  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>);<br>\t&#125;<br>\tbar.<span class=\"hljs-title function_\">myCall</span>(foo); <span class=\"hljs-comment\">// 1</span><br>--------------------------------------------------------------------<br>\t<span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myCall</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context</span>) &#123;<br>\t  <span class=\"hljs-comment\">// 取得传入的对象（执行上下文），比如上文的foo对象，这里的context就相当于上文的foo</span><br>\t  <span class=\"hljs-comment\">// 不传第一个参数，默认是window,</span><br>\t  <span class=\"hljs-keyword\">var</span> context = context || <span class=\"hljs-variable language_\">window</span>;<br>\t  <span class=\"hljs-comment\">// 给context添加一个属性，这时的this指向调用myCall的函数，比如上文的bar函数</span><br>\t  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span>;<span class=\"hljs-comment\">//这里的context.fn就相当于上文的bar函数</span><br>\t  <span class=\"hljs-comment\">// 通过展开运算符和解构赋值取出context后面的参数，上文的例子没有传入参数列表</span><br>\t  <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>);<br>\t  <span class=\"hljs-comment\">// 执行函数（相当于上文的bar(...args)）</span><br>\t  <span class=\"hljs-keyword\">var</span> result = context.<span class=\"hljs-title function_\">fn</span>(...args);<br>\t  <span class=\"hljs-comment\">// 删除函数</span><br>\t  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span>;<br>\t  <span class=\"hljs-keyword\">return</span> result;<br>\t&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"apply-thisValue-arg1-arg2-…\"><a href=\"#apply-thisValue-arg1-arg2-…\" class=\"headerlink\" title=\"apply( thisValue , [arg1, arg2, …] )\"></a>apply( thisValue , [arg1, arg2, …] )</h3><p>很明显，我们看标题的可以知道call和apply的一个区别了，它们两个唯一的区别就是传参列表的不同，apply是接收的参数是一个数组。</p>\n<h3 id=\"手撕apply\"><a href=\"#手撕apply\" class=\"headerlink\" title=\"手撕apply\"></a>手撕apply</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">\t<span class=\"hljs-keyword\">var</span> foo = &#123;<br>\t  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">1</span><br>\t&#125;;<br>\t<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bar</span>(<span class=\"hljs-params\"></span>) &#123;<br>\t  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">count</span>);<br>\t&#125;<br>\tbar.<span class=\"hljs-title function_\">myApply</span>(foo); <span class=\"hljs-comment\">// 1</span><br>--------------------------------------------------------------------<br>  <span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myApply</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">context</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> context = context || <span class=\"hljs-variable language_\">window</span>;<br>    context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span>;<br>    <span class=\"hljs-keyword\">var</span> result;<br>    <span class=\"hljs-comment\">// 判断第二个参数是否存在，也就是context后面有没有一个数组</span><br>    <span class=\"hljs-comment\">// 如果存在，则需要展开第二个参数</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]) &#123;<br>      result = context.<span class=\"hljs-title function_\">fn</span>(...<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      result = context.<span class=\"hljs-title function_\">fn</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span>;<br>    <span class=\"hljs-keyword\">return</span> result;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li>找出数组中最大或最小的元素</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">9</span>];<br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">max</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-title class_\">Math</span>, a); <span class=\"hljs-comment\">// 15</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">min</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, a); <span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-comment\">/* ES6的方法 */</span><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...[<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">9</span>]); <span class=\"hljs-comment\">// 12 等同于Math.max(10, 2, 4, 15, 9);t</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>可以将一个类似（伪）数组的对象（比如arguments对象）转为真正的数组。 前提： 被处理的对象必须有length属性，以及相对应的数字键。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">ArrayLike</span> = &#123; <span class=\"hljs-comment\">// 一个类似数组的对象</span><br>  <span class=\"hljs-number\">0</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span>,<br>  <span class=\"hljs-number\">1</span>: <span class=\"hljs-string\">&#x27;b&#x27;</span>,<br>  <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">&#x27;c&#x27;</span>,<br>  <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">3</span><br>&#125;<br><span class=\"hljs-comment\">//接收的是对象，返回的是数组</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// [1]</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// []</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-number\">0</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">2</span>&#125;) <span class=\"hljs-comment\">// [1, undefined]</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">apply</span>(&#123;<span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">1</span>&#125;) <span class=\"hljs-comment\">// [undefined]</span><br><span class=\"hljs-comment\">//（切下）[].slice(1, n)，返回索引为1到索引为n-1的数组</span><br><br><span class=\"hljs-comment\">/* ES6的方法 */</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title class_\">ArrayLike</span>); <span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><br><span class=\"hljs-comment\">// 没有部署Iterator接口的类似数组的对象，扩展运算符就“无法”将其转为真正的数组，但Array.from()可以</span><br>...<span class=\"hljs-title class_\">ArrayLike</span>; <span class=\"hljs-comment\">//  Found non-callable @@iterator</span><br><span class=\"hljs-comment\">// 只要是部署了Iterator接口的数据结构，Array.from 都能将其转为数组</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>数组追加</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>];<br>[].<span class=\"hljs-property\">push</span>.<span class=\"hljs-title function_\">apply</span>(arr1, arr2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr1); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr2); <span class=\"hljs-comment\">// [4, 5, 6]</span><br><span class=\"hljs-comment\">/* ES6的方法 */</span><br>arr1.<span class=\"hljs-title function_\">push</span>(...arr2); <span class=\"hljs-comment\">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>数组合并</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span> &#125;, [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]];<br><span class=\"hljs-keyword\">var</span> arr2 = [<span class=\"hljs-string\">&#x27;ds&#x27;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">9</span>, &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;jack&#x27;</span> &#125;];<br><span class=\"hljs-comment\">// var arr = arr1.concat(arr2);//简单做法</span><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">push</span>.<span class=\"hljs-title function_\">apply</span>(arr1,arr2)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr1);<br><span class=\"hljs-comment\">/* ES6的方法 */</span><br>[...arr1,...arr2]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"bind-thisArg-arg1-arg2-…\"><a href=\"#bind-thisArg-arg1-arg2-…\" class=\"headerlink\" title=\"bind( thisArg[, arg1[, arg2[, …]]])\"></a>bind( thisArg[, arg1[, arg2[, …]]])</h3><ul>\n<li>call和apply它们两个是改变this的指向之后立即调用该函数，而bind则不同，它是创建一个新函数，我们必须手动去调用它。</li>\n<li>bind()是ES5新增的一个方法</li>\n<li>传参和call或apply类似</li>\n<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>\n<li>bind会返回对函数的引用</li>\n</ul>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> a =&#123;<br>    name : <span class=\"hljs-string\">&quot;Cherry&quot;</span>,<br>    fn : <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a,b</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>( a + b)<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">var</span> b = a.<span class=\"hljs-property\">fn</span>;<br>b.<span class=\"hljs-title function_\">call</span>(a,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>);<span class=\"hljs-comment\">//立即调用该函数</span><br>b.<span class=\"hljs-title function_\">bind</span>(a,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)();<span class=\"hljs-comment\">//手动调用()，它返回一个原函数的拷贝（新的，不是原函数），并拥有指定的this值和初始参数。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"应用场景-2\"><a href=\"#应用场景-2\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;JuctTr&#x27;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span><br>&#125;;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 给document添加click事件监听，并绑定ExecuteFun函数</span><br><span class=\"hljs-comment\"> * 通过bind方法设置ExecuteFun的this为obj</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-comment\">//document.addEventListener(&#x27;click&#x27;,ExecuteFun.call(obj),false);</span><br><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-title class_\">ExecuteFun</span>.<span class=\"hljs-title function_\">bind</span>(obj),<span class=\"hljs-literal\">false</span>);\t\t<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ExecuteFun</span>(<span class=\"hljs-params\">a,b</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">age</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"手撕bind\"><a href=\"#手撕bind\" class=\"headerlink\" title=\"手撕bind\"></a>手撕bind</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br>  &#125;<br>  <span class=\"hljs-keyword\">var</span> _this = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>)<br>  <span class=\"hljs-comment\">// 返回一个函数</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">F</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span> <span class=\"hljs-keyword\">instanceof</span> F) &#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">_this</span>(...args, ...<span class=\"hljs-variable language_\">arguments</span>)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> _this.<span class=\"hljs-title function_\">apply</span>(context, args.<span class=\"hljs-title function_\">concat</span>(...<span class=\"hljs-variable language_\">arguments</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"Git 常见用法(包含🌰)","date":"2022-05-19T15:40:55.000Z","_content":"## Git 概念\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n![Git](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\n### git HEAD\nHEAD 是一个对当前检出记录的符号引用, 也就是指向你正在其基础上进行工作的提交记录。\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n\n```\n# 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：\n# HEAD -> main -> C1\n# HEAD 指向 main， main 指向 C1\n# C1 表示具体的某条提交记录 \n$ git checkout C1\n```\n\n```\n# 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向\n$ git symbolic-ref HEAD\n```\n### git 相对引用\n背景：通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!\n使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。\n相对引用非常给力，这里我介绍两个简单的用法：\n```\n# 使用 ^ 向上移动 1 个提交记录\n# 所以 main^ 相当于“main 的父节点”。\n# main^^ 是 main 的第二个父节点\n$ git checkout main^\n\n# 使用 ~<num> 向上移动多个提交记录，如 ~3\n$ git checkout main~3\n\n# 你也可以将 HEAD 作为相对引用的参照。下面咱们就用 HEAD 在提交树中向上移动几次。\n$ git checkout HEAD^\n\n# 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字, 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n# Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。\n# C0 -> C1 -> C3(main) ｜ C0 -> C2 -> C3(main)\n$ git checkout main^ (默认指向的是C1而不是C2)\n$ git checkout main^2 (默认指向的是C2而不是C1)\n\n# 这些操作符还支持链式操作！\n$ git checkout HEAD~^2~2\n```\n## Git 常用语法\n### git config\n配置 Git 的相关参数。\nGit 一共有3个配置文件：\n1. 仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。\n2. 全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\\Users\\<用户名>\\.gitconfig。\n3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。\n\n```\n# 查看配置信息\n# --local：仓库级，--global：全局级，--system：系统级\n$ git config <--local | --global | --system> -l\n\n# 查看当前生效的配置信息\n$ git config -l\n\n# 编辑配置文件\n# --local：仓库级，--global：全局级，--system：系统级\n$ git config <--local | --global | --system> -e\n\n# 添加配置项\n# --local：仓库级，--global：全局级，--system：系统级\n$ git config <--local | --global | --system> --add <name> <value>\n\n# 获取配置项\n$ git config <--local | --global | --system> --get <name>\n\n# 删除配置项\n$ git config <--local | --global | --system> --unset <name>\n\n# 配置提交记录中的用户信息\n$ git config --global user.name <用户名>\n$ git config --global user.email <邮箱地址>\n\n# 更改Git缓存区的大小\n# 如果提交的内容较大，默认缓存较小，提交会失败\n# 缓存大小单位：B，例如：524288000（500MB）\n$ git config --global http.postBuffer <缓存大小>\n\n# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态\n$ git config --global color.ui true\n\n# 配置可以缓存密码，默认缓存时间15分钟\n$ git config --global credential.helper cache\n\n# 配置密码的缓存时间\n# 缓存时间单位：秒\n$ git config --global credential.helper 'cache --timeout=<缓存时间>'\n\n# 配置长期存储密码\n$ git config --global credential.helper store\n```\n\n### git clone\n从远程仓库克隆一个版本库到本地。\n\n```\n# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下\n$ git clone <远程仓库的网址>\n\n# 指定本地仓库的目录\n$ git clone <远程仓库的网址> <本地目录>\n\n# -b 指定要克隆的分支，默认是master分支\n$ git clone <远程仓库的网址> -b <分支名称> <本地目录>\n```\n\n### git init\n初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。\n\n```\n# 初始化本地仓库，在当前目录下生成 .git 文件夹\n$ git init\n```\n\n### git status\n查看本地仓库的状态。\n\n```\n# 查看本地仓库的状态\n$ git status\n\n# 以简短模式查看本地仓库的状态\n# 会显示两列，第一列是文件的状态，第二列是对应的文件\n# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中\n$ git status -s\n```\n\n### git remote\n操作远程库。\n\n```\n# 列出已经存在的远程仓库\n$ git remote\n\n# 列出远程仓库的详细信息，在别名后面列出URL地址\n$ git remote -v\n$ git remote --verbose\n\n# 添加远程仓库\n$ git remote add <远程仓库的别名> <远程仓库的URL地址>\n\n# 修改远程仓库的别名\n$ git remote rename <原远程仓库的别名> <新的别名>\n\n# 删除指定名称的远程仓库\n$ git remote remove <远程仓库的别名>\n\n# 修改远程仓库的 URL 地址\n$ git remote set-url <远程仓库的别名> <新的远程仓库URL地址>\n\n```\n\n### git branch\n操作 Git 的分支命令。\n\n```\n# 列出本地的所有分支，当前所在分支以 \"*\" 标出\n$ git branch\n\n# 列出本地的所有分支并显示最后一次提交，当前所在分支以 \"*\" 标出\n$ git branch -v\n\n# 创建新分支，新的分支基于上一次提交建立\n$ git branch <分支名>\n\n# 修改分支名称\n# 如果不指定原分支名称则为当前所在分支\n$ git branch -m [<原分支名称>] <新的分支名称>\n# 强制修改分支名称\n$ git branch -M [<原分支名称>] <新的分支名称>\n\n# 删除指定的本地分支\n$ git branch -d <分支名称>\n\n# 强制删除指定的本地分支\n$ git branch -D <分支名称>\n\n# 强制修改分支位置\n# 我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。将 main 分支强制指向 HEAD 的第 3 级父提交。\n$ git branch -f main HEAD~3\n\n```\n\n### git checkout\n检出命令，用于创建、切换分支等。\n\n```\n# 切换到已存在的指定分支\n$ git checkout <分支名称>\n\n# 创建并切换到指定的分支，保留所有的提交记录\n# 等同于 \"git branch\" 和 \"git checkout\" 两个命令合并\n$ git checkout -b <分支名称>\n\n# 创建并切换到指定的分支，删除所有的提交记录\n$ git checkout --orphan <分支名称>\n\n# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响\n$ git checkout <文件路径>\n```\n\n### git cherry-pick\n把已经提交（多个/单个）的记录有序的合并到当前分支。关键词：多个/有序\n\n```\n# 把已经提交的记录合并到当前分支\n$ git cherry-pick <commit ID>\n\n# 可进行多个提交的抓取 C1 C2 或者 C2 C1 产生的效果完全不一样是有孙旭的提交记录\n$ git cherry-pick C1 C2\n$ git cherry-pick C2 C1\n```\n\n### git add\n把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交\n\n```\n# 把指定的文件添加到暂存区中\n$ git add <文件路径>\n\n# 添加所有修改、已删除的文件到暂存区中\n$ git add -u [<文件路径>]\n$ git add --update [<文件路径>]\n\n# 添加所有修改、已删除、新增的文件到暂存区中，省略 <文件路径> 即为当前目录\n$ git add -A [<文件路径>]\n$ git add --all [<文件路径>]\n\n# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统\n$ git add -i [<文件路径>]\n$ git add --interactive [<文件路径>]\n```\n\n### git commit\n将暂存区中的文件提交到本地仓库中。\n\n```\n# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息\n$ git commit\n\n# 把暂存区中的文件提交到本地仓库中并添加描述信息\n$ git commit -m \"<提交的描述信息>\"\n\n# 把所有修改、已删除的文件提交到本地仓库中\n# 不包括未被版本库跟踪的文件，等同于先调用了 \"git add -u\"\n$ git commit -a -m \"<提交的描述信息>\"\n\n# 修改上次提交的描述信息\n$ git commit --amend\n```\n### git fetch\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\ngit fetch 完成了仅有的但是很重要的两步:\n+ 从远程仓库下载本地仓库中缺失的提交记录\n+ 更新远程分支指针(如 origin/main)\n\ngit fetch 不会做的事: \n+ git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n\n理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。\n所以, 你可以将 git fetch 的理解为单纯的下载操作。\n\n```\n# 将远程仓库所有分支的最新版本全部取回到本地\n$ git fetch <远程仓库的别名>\n$ git fetch origin\n\n# 将远程仓库指定分支的最新版本取回到本地\n$ git fetch <远程主机名> <分支名>\n$ git fetch origin pre:pre\n```\n### git merge\n合并分支\n\n```\n# 把指定的分支合并到当前所在的分支下\n$ git merge <分支名称>\n```\n### git diff\n比较版本之间的差异。\n\n```\n# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改\n$ git diff\n\n# 比较暂存区中的文件和上次提交时的差异\n$ git diff --cached\n$ git diff --staged\n\n# 比较当前文件和上次提交时的差异\n$ git diff HEAD\n\n# 查看从指定的版本之后改动的内容\n$ git diff <commit ID>\n\n# 比较两个分支之间的差异\n$ git diff <分支名称> <分支名称>\n\n# 查看两个分支分开后各自的改动内容\n$ git diff <分支名称>...<分支名称>\n```\n### git pull\n从远程仓库获取最新版本并合并到本地。\n首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。\n\n```\n# 从远程仓库获取最新版本。\n$ git pull\n\n# git pull origin foo 相当于：git fetch origin foo; git merge o/foo\n# git pull origin bar~1:bugFix 相当于：git fetch origin bar~1:bugFix; git merge bugFix\n\n```\n### git push\n把本地仓库的提交推送到远程仓库。远程仓库对应的分支会指向最新的提交，本地的远程分支也会指向最新的提交记录\n\n```\n# push 参数1\n# 把本地仓库的分支推送到远程仓库\n$ git push <远程仓库的别名> <本地分支名>\n$ git push <remote> <place>\n$ git push origin main(本地分支)\n# 把这个命令翻译过来就是：\n# 切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。\n# 我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。\n# 需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！\n\n# push 参数2\n# 把本地仓库的分支推送到远程仓库的指定分支\n$ git push <远程仓库的别名> <本地分支名>:<远程分支名>\n# 当为 git push 指定 place 参数为 main 时，我们同时指定了提交记录的来源和去向。\n# 你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。\n# 当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）\n$ git push origin <source>:<destination>\n# source 可以是任何 Git 能识别的位置：\n$ git push origin HEAD^:foo\n\n# 删除指定的远程仓库的分支\n$ git push <远程仓库的别名> :<远程分支名>\n$ git push <远程仓库的别名> --delete <远程分支名>\n# 为推送当前分支并建立与远程上游的跟踪，使用\n$ git push --set-upstream <远程仓库别名> <远程分支名>\n$ git push --set-upstream origin master\n# 强行推送本地记录\n$ git push -u origin +master\n```\n### git log\n显示提交的记录。\n\n```\n# 打印所有的提交记录\n$ git log\n\n# 打印从第一次提交到指定的提交的记录\n$ git log <commit ID>\n\n# 打印指定数量的最新提交的记录\n$ git log -<指定的数量>\n```\n### git reset\n还原提交记录。\n\n```\n# 重置暂存区，但文件不受影响\n# 相当于将用 \"git add\" 命令更新到暂存区的内容撤出暂存区，可以指定文件\n# 没有指定 commit ID 则默认为当前 HEAD\n$ git reset [<文件路径>]\n$ git reset --mixed [<文件路径>]\n\n# --mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作 （git status 是红色的状态）。\n$ git reset <commit ID>\n$ git reset --mixed <commit ID>\n\n# --soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）\n# 相当于调用 \"git reset --mixed\" 命令后又做了一次 \"git add\"\n$ git reset --soft <commit ID>\n\n# --hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。\n$ git reset --hard <commit ID>\n\n# --merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】\n# --keep 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。\n\n```\n### git revert\n生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。\n\n```\n# 生成一个新的提交来撤销某次提交\n$ git revert <commit ID>\n```\n### git tag\n分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。\n你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。\n更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\n```\n# 我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。\n$ git tag v1 C1\n\n# 打印所有的标签\n$ git tag\n\n# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录\n$ git tag <标签名称> [<commit ID>]\n\n# 添加带有描述信息的附注标签，可以指定之前的提交记录\n$ git tag -a <标签名称> -m <标签描述信息> [<commit ID>]\n\n# 切换到指定的标签\n$ git checkout <标签名称>\n\n# 查看标签的信息\n$ git show <标签名称>\n\n# 删除指定的标签\n$ git tag -d <标签名称>\n\n# 将指定的标签提交到远程仓库\n$ git push <远程仓库的别名> <标签名称>\n\n# 将本地所有的标签全部提交到远程仓库\n$ git push <远程仓库的别名> –tags\n# 强push\n$ git push origin <远程分支名> --force\n```\n### git mv\n重命名文件或者文件夹。\n\n```\n# 重命名指定的文件或者文件夹\n$ git mv <源文件/文件夹> <目标文件/文件夹>\n```\n### git rm\n删除文件或者文件夹。\n\n```\n# 移除跟踪指定的文件，并从本地仓库的文件夹中删除\n$ git rm <文件路径>\n\n# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除\n$ git rm -r <文件夹路径>\n\n# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件\n$ git rm --cached\n```\n### git rebase\nRebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\nRebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。\n\n```\n# 将当前分支变基到目标分支\n$ git rebase <远程分支名>\n\n# 将某个分支变基到另一个分支上 (将分支b变基到分支a上)\n$ git rebase <分支名a> <分支名b>\n$ git rebase a b\n\n# 表示继续下一个冲突(git rebase --continue 就相当于 git commit)\n$ git rebase --continue\n\n# 表示跳过当前冲突\n$ git rebase --skip\n\n# 表示退出rebase模式, 回到运行git rebase master命令之前的状态\n$ git rebase --abort\n```\n\n### git describe\n由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签）\n\n```\n# <ref> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。\ngit describe <ref>\n\n# 它输出的结果是这样的：<tag>_<numCommits>_g<hash>\n# tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。\n# C0(v1) -> C1 -> C2(main)\ngit describe main 会输出：v1_2_gC2 \n```\n\n### git worktree\n仅需维护一个 repo，又可以同时在多个 branch 上工作，互不影响\n默认情况下， git init 或 git clone 初始化的 repo，只有一个 worktree，叫做 main worktree\n在某一个目录下使用 Git 命令，当前目录下要么有 .git 文件夹；要么有 .git 文件，如果只有 .git 文件，里面的内容必须是指向 .git 文件夹的\n\n```\n# 常用worktree 命令\n$ git worktree add [-f] [--detach] [--checkout] [--lock] [-b <new-branch>] <path> [<commit-ish>]\n$ git worktree list [--porcelain]\n$ git worktree remove [-f] <worktree>\n$ git worktree prune [-n] [-v] [--expire <expire>]\n```\n+ 创建一个worktree\n```\ngit worktree add ../feature/feature2\n```\n目录结构\n```\n├── amend-crash-demo\n└── feature\n    └── feature2\n```\ncd ../feature/feature2/ 会发现，这个分支下并不存在 .git 文件夹，却存在一个 .git 文件，打开文件，内容如下：\n```\ngitdir: /Users/rgyb/Documents/projects/amend-crash-demo/.git/worktrees/feature2\n```\n+ git worktree remove\n```\n# 删除一个worktree 参数是文件路径 注意路径前不加 \"/\"\ngit worktree remove feature/feature2\n```\n```\n# 假设你创建一个 worktree，并在里面有改动，突然间这个worktree 又不需要了，此刻你按照上述命令是不能删掉了，此时就需要 -f 参数来帮忙了\ngit worktree remove -f feature/feature2\n```\n```\n# 删除了 worktree，其实在 Git 的文件中，还有很多 administrative 文件是没有用的，为了保持清洁，我们还需要进一步清理\n# 这个命令就是清洁的兜底操作，可以让我们的工作始终保持整洁\ngit worktree prune\n```\n\n## Git操作场景(🌰)\n### 删除掉本地不存在的远程分支\n多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除\n\n```\n# 使用 pull 命令，添加 -p 参数\n$ git pull -p\n\n# 等同于下面的命令\n$ git fetch -p\n$ git fetch --prune origin\n```\n### 只提交某次记录\n发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！\n最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式\n\n```\n# 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用\n$ git rebase -i\n$ git cherry-pick \n```\n### 本地分支合并远端分支\n\n```\n# 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:\n$ git cherry-pick o/main\n$ git rebase o/main\n$ git merge o/main\n...\n```\n### 远程分支代码比本地分支代码新的情况进行提交\n假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。\n\n这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？\n因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n\n```\n# 方式1: rebase\n# 我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。\n$ git fetch; git rebase orgin/main; git push\n\n# 方式2: merge\n# git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。\n# 我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库\n$ git fetch; git merge orgin/main; git push\n\n# 方式3: pull / pull --rebase\n# 要敲那么多命令，有没有更简单一点的？前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写！\n$ git pull --rebase; git push\n$ git pull; git push\n```\n### 远程跟踪\n自定义远程跟踪分支：你可以让任意分支跟踪 o/main, 然后该分支会像 main 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMain 上执行 git push，将工作推送到远程仓库的 main 分支上。\n**需要注意的是 main 并未被更新**\n有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行:\n```\n# 1: git checkout -b\n$ git checkout -b totallyNotMain o/main\n就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main。\n\n# 2: git branch -u\n$ git branch -u o/main foo\n# 这样 foo 就会跟踪 o/main 了。如果当前就在 foo 分支上, 还可以省略 foo：\n$ git branch -u o/main\n```\n### 代码分支迁移到不同仓库\n当我们需要将分支origin(A)/a 迁移到 origin(B)/a 并保留分支记录\n```\n切换到当前origin(A) 更换当前仓库为目标仓库\n$ git remote set-url origin https://gitlab.southinfo.net/ecrp-sg-web.git\n推送当前分支到更换后的目标仓库(需要密码/ssh认证)\n$ git push\n```\n\n### 代码回滚(reset/revert)\n+ 结论\n1. git revert 后会多出一条commit，这里可进行回撤操作\n2. git reset 直接把之前 commit 删掉，非 git reset --hard 的操作是不会删掉修改代码，如果远程已经有之前代码，需要强推 git push -f\n\n+ 应用场景\n1. 如果回退分支的代码以后还需要的话用git revert就再好不过了；\n2. 如果分支我就是提错了没用了还不想让别人发现我错的代码，那就git reset吧\n\n+ git reset\ndevelop将a分支合并后，想要不留痕迹的撤回合并。这个时候用git reset就是很好的选择了\n```\ndevelop ----1      3-----\n             \\   /\nbranch a       a\n```\n\n+ 操作步骤\n1. 切换分支到develop\n2. git log 查看当前分支日志\n3. 我要将develop回退到合并之前的状态，那就是退到 commit 1这了，将commit号复制下来。退出编辑界面。\n```\n3.1 a分支的代码我不需要了，以后应该也不需要了\n  git reset 1（粘贴过来的commit号） --hard\n3.2 a分支的代码我还需要\n  git reset 1（粘贴过来的commit号）\n```\n4. 将回退后的代码推送到远端 git push origin develop\n```\n![rejected] develop -> develop (non-fast-forward)\nerror: 无法推送一些引用到 'git@github.cn:...'\n提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。\n。。。\n```\n因为本地分支的代码落后于远端develop分支, 所以这一步需要强行推送 *--force*\n5. 强推\n```\ngit push origin develop --force\n```\n\n+ git revert\n还是之前的需求，不想要合并a，只想要没合并a时的样子。\n``` \ndevelop ----1      3-----\n             \\   /\nbranch a       a\n```\n\n+ 操作步骤\n1. 切换分支到develop  git checkout develop\n2. git log 查看当前分支日志\n3. 这次和git reset 不同的是我不能复制 commit 1这个commit号了，我需要复制的是commit 2的commit号。因为revert后面跟的是具体需要哪个已经合并了的分支，而并不是需要会退到哪的commit号。\n```\ngit revert 2\n```\n4. push到远端服务器\n```\ngit push origin develop\n```\n\n### 解决合并代码 (Already up-to-date) 问题\n+ 有时我们合并代码会遇到冲突解决的问题, 这个时候如果想取消本次合并如果直接丢弃全部文件会照成远端代码还是保存了本次解决冲突的提交, 当我们重新再合并有冲突的代码就会显示Already up-to-date\n+ 接上个例子, 现在的需求是我之前已经把a分支revert了，但是我现在又需要a分支的代码了，我之前都写过一遍总不能再重新写一遍了。我首先想到的方法，把a分支再merge到develop不就好了。\n```\ngit merge a\n```\n结果\n```\nAlready up-to-date\n```\n因为我们之前提交合并的a分支的代码还在，因此我们并不能在重新合并a分支。\n\n解决方法: 使用revert之前revert的commit号。在上面的例子中就是git revert 4。于是又新增了一个commit，把之前revert的代码又重新revert回来了, 再继续执行合并操作代码冲突又会提示出来了\n","source":"_posts/gitCommand.md","raw":"---\ntitle: Git 常见用法(包含🌰)\ndate: 2022-05-19 23:40:55\ntags:\n---\n## Git 概念\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n![Git](https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\n### git HEAD\nHEAD 是一个对当前检出记录的符号引用, 也就是指向你正在其基础上进行工作的提交记录。\nHEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。\nHEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。\n\n```\n# 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：\n# HEAD -> main -> C1\n# HEAD 指向 main， main 指向 C1\n# C1 表示具体的某条提交记录 \n$ git checkout C1\n```\n\n```\n# 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向\n$ git symbolic-ref HEAD\n```\n### git 相对引用\n背景：通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!\n使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。\n相对引用非常给力，这里我介绍两个简单的用法：\n```\n# 使用 ^ 向上移动 1 个提交记录\n# 所以 main^ 相当于“main 的父节点”。\n# main^^ 是 main 的第二个父节点\n$ git checkout main^\n\n# 使用 ~<num> 向上移动多个提交记录，如 ~3\n$ git checkout main~3\n\n# 你也可以将 HEAD 作为相对引用的参照。下面咱们就用 HEAD 在提交树中向上移动几次。\n$ git checkout HEAD^\n\n# 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字, 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。\n# Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。\n# C0 -> C1 -> C3(main) ｜ C0 -> C2 -> C3(main)\n$ git checkout main^ (默认指向的是C1而不是C2)\n$ git checkout main^2 (默认指向的是C2而不是C1)\n\n# 这些操作符还支持链式操作！\n$ git checkout HEAD~^2~2\n```\n## Git 常用语法\n### git config\n配置 Git 的相关参数。\nGit 一共有3个配置文件：\n1. 仓库级的配置文件：在仓库的 .git/.gitconfig，该配置文件只对所在的仓库有效。\n2. 全局配置文件：Mac 系统在 ~/.gitconfig，Windows 系统在 C:\\Users\\<用户名>\\.gitconfig。\n3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 /usr/local/git）的 etc 文件夹中的 gitconfig。\n\n```\n# 查看配置信息\n# --local：仓库级，--global：全局级，--system：系统级\n$ git config <--local | --global | --system> -l\n\n# 查看当前生效的配置信息\n$ git config -l\n\n# 编辑配置文件\n# --local：仓库级，--global：全局级，--system：系统级\n$ git config <--local | --global | --system> -e\n\n# 添加配置项\n# --local：仓库级，--global：全局级，--system：系统级\n$ git config <--local | --global | --system> --add <name> <value>\n\n# 获取配置项\n$ git config <--local | --global | --system> --get <name>\n\n# 删除配置项\n$ git config <--local | --global | --system> --unset <name>\n\n# 配置提交记录中的用户信息\n$ git config --global user.name <用户名>\n$ git config --global user.email <邮箱地址>\n\n# 更改Git缓存区的大小\n# 如果提交的内容较大，默认缓存较小，提交会失败\n# 缓存大小单位：B，例如：524288000（500MB）\n$ git config --global http.postBuffer <缓存大小>\n\n# 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态\n$ git config --global color.ui true\n\n# 配置可以缓存密码，默认缓存时间15分钟\n$ git config --global credential.helper cache\n\n# 配置密码的缓存时间\n# 缓存时间单位：秒\n$ git config --global credential.helper 'cache --timeout=<缓存时间>'\n\n# 配置长期存储密码\n$ git config --global credential.helper store\n```\n\n### git clone\n从远程仓库克隆一个版本库到本地。\n\n```\n# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下\n$ git clone <远程仓库的网址>\n\n# 指定本地仓库的目录\n$ git clone <远程仓库的网址> <本地目录>\n\n# -b 指定要克隆的分支，默认是master分支\n$ git clone <远程仓库的网址> -b <分支名称> <本地目录>\n```\n\n### git init\n初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。\n\n```\n# 初始化本地仓库，在当前目录下生成 .git 文件夹\n$ git init\n```\n\n### git status\n查看本地仓库的状态。\n\n```\n# 查看本地仓库的状态\n$ git status\n\n# 以简短模式查看本地仓库的状态\n# 会显示两列，第一列是文件的状态，第二列是对应的文件\n# 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中\n$ git status -s\n```\n\n### git remote\n操作远程库。\n\n```\n# 列出已经存在的远程仓库\n$ git remote\n\n# 列出远程仓库的详细信息，在别名后面列出URL地址\n$ git remote -v\n$ git remote --verbose\n\n# 添加远程仓库\n$ git remote add <远程仓库的别名> <远程仓库的URL地址>\n\n# 修改远程仓库的别名\n$ git remote rename <原远程仓库的别名> <新的别名>\n\n# 删除指定名称的远程仓库\n$ git remote remove <远程仓库的别名>\n\n# 修改远程仓库的 URL 地址\n$ git remote set-url <远程仓库的别名> <新的远程仓库URL地址>\n\n```\n\n### git branch\n操作 Git 的分支命令。\n\n```\n# 列出本地的所有分支，当前所在分支以 \"*\" 标出\n$ git branch\n\n# 列出本地的所有分支并显示最后一次提交，当前所在分支以 \"*\" 标出\n$ git branch -v\n\n# 创建新分支，新的分支基于上一次提交建立\n$ git branch <分支名>\n\n# 修改分支名称\n# 如果不指定原分支名称则为当前所在分支\n$ git branch -m [<原分支名称>] <新的分支名称>\n# 强制修改分支名称\n$ git branch -M [<原分支名称>] <新的分支名称>\n\n# 删除指定的本地分支\n$ git branch -d <分支名称>\n\n# 强制删除指定的本地分支\n$ git branch -D <分支名称>\n\n# 强制修改分支位置\n# 我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。将 main 分支强制指向 HEAD 的第 3 级父提交。\n$ git branch -f main HEAD~3\n\n```\n\n### git checkout\n检出命令，用于创建、切换分支等。\n\n```\n# 切换到已存在的指定分支\n$ git checkout <分支名称>\n\n# 创建并切换到指定的分支，保留所有的提交记录\n# 等同于 \"git branch\" 和 \"git checkout\" 两个命令合并\n$ git checkout -b <分支名称>\n\n# 创建并切换到指定的分支，删除所有的提交记录\n$ git checkout --orphan <分支名称>\n\n# 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响\n$ git checkout <文件路径>\n```\n\n### git cherry-pick\n把已经提交（多个/单个）的记录有序的合并到当前分支。关键词：多个/有序\n\n```\n# 把已经提交的记录合并到当前分支\n$ git cherry-pick <commit ID>\n\n# 可进行多个提交的抓取 C1 C2 或者 C2 C1 产生的效果完全不一样是有孙旭的提交记录\n$ git cherry-pick C1 C2\n$ git cherry-pick C2 C1\n```\n\n### git add\n把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交\n\n```\n# 把指定的文件添加到暂存区中\n$ git add <文件路径>\n\n# 添加所有修改、已删除的文件到暂存区中\n$ git add -u [<文件路径>]\n$ git add --update [<文件路径>]\n\n# 添加所有修改、已删除、新增的文件到暂存区中，省略 <文件路径> 即为当前目录\n$ git add -A [<文件路径>]\n$ git add --all [<文件路径>]\n\n# 查看所有修改、已删除但没有提交的文件，进入一个子命令系统\n$ git add -i [<文件路径>]\n$ git add --interactive [<文件路径>]\n```\n\n### git commit\n将暂存区中的文件提交到本地仓库中。\n\n```\n# 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息\n$ git commit\n\n# 把暂存区中的文件提交到本地仓库中并添加描述信息\n$ git commit -m \"<提交的描述信息>\"\n\n# 把所有修改、已删除的文件提交到本地仓库中\n# 不包括未被版本库跟踪的文件，等同于先调用了 \"git add -u\"\n$ git commit -a -m \"<提交的描述信息>\"\n\n# 修改上次提交的描述信息\n$ git commit --amend\n```\n### git fetch\ngit fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。\ngit fetch 完成了仅有的但是很重要的两步:\n+ 从远程仓库下载本地仓库中缺失的提交记录\n+ 更新远程分支指针(如 origin/main)\n\ngit fetch 不会做的事: \n+ git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。\n\n理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。\n所以, 你可以将 git fetch 的理解为单纯的下载操作。\n\n```\n# 将远程仓库所有分支的最新版本全部取回到本地\n$ git fetch <远程仓库的别名>\n$ git fetch origin\n\n# 将远程仓库指定分支的最新版本取回到本地\n$ git fetch <远程主机名> <分支名>\n$ git fetch origin pre:pre\n```\n### git merge\n合并分支\n\n```\n# 把指定的分支合并到当前所在的分支下\n$ git merge <分支名称>\n```\n### git diff\n比较版本之间的差异。\n\n```\n# 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改\n$ git diff\n\n# 比较暂存区中的文件和上次提交时的差异\n$ git diff --cached\n$ git diff --staged\n\n# 比较当前文件和上次提交时的差异\n$ git diff HEAD\n\n# 查看从指定的版本之后改动的内容\n$ git diff <commit ID>\n\n# 比较两个分支之间的差异\n$ git diff <分支名称> <分支名称>\n\n# 查看两个分支分开后各自的改动内容\n$ git diff <分支名称>...<分支名称>\n```\n### git pull\n从远程仓库获取最新版本并合并到本地。\n首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。\n\n```\n# 从远程仓库获取最新版本。\n$ git pull\n\n# git pull origin foo 相当于：git fetch origin foo; git merge o/foo\n# git pull origin bar~1:bugFix 相当于：git fetch origin bar~1:bugFix; git merge bugFix\n\n```\n### git push\n把本地仓库的提交推送到远程仓库。远程仓库对应的分支会指向最新的提交，本地的远程分支也会指向最新的提交记录\n\n```\n# push 参数1\n# 把本地仓库的分支推送到远程仓库\n$ git push <远程仓库的别名> <本地分支名>\n$ git push <remote> <place>\n$ git push origin main(本地分支)\n# 把这个命令翻译过来就是：\n# 切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。\n# 我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。\n# 需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！\n\n# push 参数2\n# 把本地仓库的分支推送到远程仓库的指定分支\n$ git push <远程仓库的别名> <本地分支名>:<远程分支名>\n# 当为 git push 指定 place 参数为 main 时，我们同时指定了提交记录的来源和去向。\n# 你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。\n# 当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）\n$ git push origin <source>:<destination>\n# source 可以是任何 Git 能识别的位置：\n$ git push origin HEAD^:foo\n\n# 删除指定的远程仓库的分支\n$ git push <远程仓库的别名> :<远程分支名>\n$ git push <远程仓库的别名> --delete <远程分支名>\n# 为推送当前分支并建立与远程上游的跟踪，使用\n$ git push --set-upstream <远程仓库别名> <远程分支名>\n$ git push --set-upstream origin master\n# 强行推送本地记录\n$ git push -u origin +master\n```\n### git log\n显示提交的记录。\n\n```\n# 打印所有的提交记录\n$ git log\n\n# 打印从第一次提交到指定的提交的记录\n$ git log <commit ID>\n\n# 打印指定数量的最新提交的记录\n$ git log -<指定的数量>\n```\n### git reset\n还原提交记录。\n\n```\n# 重置暂存区，但文件不受影响\n# 相当于将用 \"git add\" 命令更新到暂存区的内容撤出暂存区，可以指定文件\n# 没有指定 commit ID 则默认为当前 HEAD\n$ git reset [<文件路径>]\n$ git reset --mixed [<文件路径>]\n\n# --mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作 （git status 是红色的状态）。\n$ git reset <commit ID>\n$ git reset --mixed <commit ID>\n\n# --soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）\n# 相当于调用 \"git reset --mixed\" 命令后又做了一次 \"git add\"\n$ git reset --soft <commit ID>\n\n# --hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。\n$ git reset --hard <commit ID>\n\n# --merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】\n# --keep 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。\n\n```\n### git revert\n生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。\n\n```\n# 生成一个新的提交来撤销某次提交\n$ git revert <commit ID>\n```\n### git tag\n分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。\n你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？\n当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。\n更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。\n\n```\n# 我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。\n$ git tag v1 C1\n\n# 打印所有的标签\n$ git tag\n\n# 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录\n$ git tag <标签名称> [<commit ID>]\n\n# 添加带有描述信息的附注标签，可以指定之前的提交记录\n$ git tag -a <标签名称> -m <标签描述信息> [<commit ID>]\n\n# 切换到指定的标签\n$ git checkout <标签名称>\n\n# 查看标签的信息\n$ git show <标签名称>\n\n# 删除指定的标签\n$ git tag -d <标签名称>\n\n# 将指定的标签提交到远程仓库\n$ git push <远程仓库的别名> <标签名称>\n\n# 将本地所有的标签全部提交到远程仓库\n$ git push <远程仓库的别名> –tags\n# 强push\n$ git push origin <远程分支名> --force\n```\n### git mv\n重命名文件或者文件夹。\n\n```\n# 重命名指定的文件或者文件夹\n$ git mv <源文件/文件夹> <目标文件/文件夹>\n```\n### git rm\n删除文件或者文件夹。\n\n```\n# 移除跟踪指定的文件，并从本地仓库的文件夹中删除\n$ git rm <文件路径>\n\n# 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除\n$ git rm -r <文件夹路径>\n\n# 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件\n$ git rm --cached\n```\n### git rebase\nRebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。\nRebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。\n\n```\n# 将当前分支变基到目标分支\n$ git rebase <远程分支名>\n\n# 将某个分支变基到另一个分支上 (将分支b变基到分支a上)\n$ git rebase <分支名a> <分支名b>\n$ git rebase a b\n\n# 表示继续下一个冲突(git rebase --continue 就相当于 git commit)\n$ git rebase --continue\n\n# 表示跳过当前冲突\n$ git rebase --skip\n\n# 表示退出rebase模式, 回到运行git rebase master命令之前的状态\n$ git rebase --abort\n```\n\n### git describe\n由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签）\n\n```\n# <ref> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。\ngit describe <ref>\n\n# 它输出的结果是这样的：<tag>_<numCommits>_g<hash>\n# tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。\n# C0(v1) -> C1 -> C2(main)\ngit describe main 会输出：v1_2_gC2 \n```\n\n### git worktree\n仅需维护一个 repo，又可以同时在多个 branch 上工作，互不影响\n默认情况下， git init 或 git clone 初始化的 repo，只有一个 worktree，叫做 main worktree\n在某一个目录下使用 Git 命令，当前目录下要么有 .git 文件夹；要么有 .git 文件，如果只有 .git 文件，里面的内容必须是指向 .git 文件夹的\n\n```\n# 常用worktree 命令\n$ git worktree add [-f] [--detach] [--checkout] [--lock] [-b <new-branch>] <path> [<commit-ish>]\n$ git worktree list [--porcelain]\n$ git worktree remove [-f] <worktree>\n$ git worktree prune [-n] [-v] [--expire <expire>]\n```\n+ 创建一个worktree\n```\ngit worktree add ../feature/feature2\n```\n目录结构\n```\n├── amend-crash-demo\n└── feature\n    └── feature2\n```\ncd ../feature/feature2/ 会发现，这个分支下并不存在 .git 文件夹，却存在一个 .git 文件，打开文件，内容如下：\n```\ngitdir: /Users/rgyb/Documents/projects/amend-crash-demo/.git/worktrees/feature2\n```\n+ git worktree remove\n```\n# 删除一个worktree 参数是文件路径 注意路径前不加 \"/\"\ngit worktree remove feature/feature2\n```\n```\n# 假设你创建一个 worktree，并在里面有改动，突然间这个worktree 又不需要了，此刻你按照上述命令是不能删掉了，此时就需要 -f 参数来帮忙了\ngit worktree remove -f feature/feature2\n```\n```\n# 删除了 worktree，其实在 Git 的文件中，还有很多 administrative 文件是没有用的，为了保持清洁，我们还需要进一步清理\n# 这个命令就是清洁的兜底操作，可以让我们的工作始终保持整洁\ngit worktree prune\n```\n\n## Git操作场景(🌰)\n### 删除掉本地不存在的远程分支\n多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch --all 依然会显示该远程分支，可使用下列的命令进行删除\n\n```\n# 使用 pull 命令，添加 -p 参数\n$ git pull -p\n\n# 等同于下面的命令\n$ git fetch -p\n$ git fetch --prune origin\n```\n### 只提交某次记录\n发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。\n这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！\n最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式\n\n```\n# 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用\n$ git rebase -i\n$ git cherry-pick \n```\n### 本地分支合并远端分支\n\n```\n# 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:\n$ git cherry-pick o/main\n$ git rebase o/main\n$ git merge o/main\n...\n```\n### 远程分支代码比本地分支代码新的情况进行提交\n假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。\n\n这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？\n因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。\n\n```\n# 方式1: rebase\n# 我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。\n$ git fetch; git rebase orgin/main; git push\n\n# 方式2: merge\n# git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。\n# 我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库\n$ git fetch; git merge orgin/main; git push\n\n# 方式3: pull / pull --rebase\n# 要敲那么多命令，有没有更简单一点的？前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写！\n$ git pull --rebase; git push\n$ git pull; git push\n```\n### 远程跟踪\n自定义远程跟踪分支：你可以让任意分支跟踪 o/main, 然后该分支会像 main 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMain 上执行 git push，将工作推送到远程仓库的 main 分支上。\n**需要注意的是 main 并未被更新**\n有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行:\n```\n# 1: git checkout -b\n$ git checkout -b totallyNotMain o/main\n就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main。\n\n# 2: git branch -u\n$ git branch -u o/main foo\n# 这样 foo 就会跟踪 o/main 了。如果当前就在 foo 分支上, 还可以省略 foo：\n$ git branch -u o/main\n```\n### 代码分支迁移到不同仓库\n当我们需要将分支origin(A)/a 迁移到 origin(B)/a 并保留分支记录\n```\n切换到当前origin(A) 更换当前仓库为目标仓库\n$ git remote set-url origin https://gitlab.southinfo.net/ecrp-sg-web.git\n推送当前分支到更换后的目标仓库(需要密码/ssh认证)\n$ git push\n```\n\n### 代码回滚(reset/revert)\n+ 结论\n1. git revert 后会多出一条commit，这里可进行回撤操作\n2. git reset 直接把之前 commit 删掉，非 git reset --hard 的操作是不会删掉修改代码，如果远程已经有之前代码，需要强推 git push -f\n\n+ 应用场景\n1. 如果回退分支的代码以后还需要的话用git revert就再好不过了；\n2. 如果分支我就是提错了没用了还不想让别人发现我错的代码，那就git reset吧\n\n+ git reset\ndevelop将a分支合并后，想要不留痕迹的撤回合并。这个时候用git reset就是很好的选择了\n```\ndevelop ----1      3-----\n             \\   /\nbranch a       a\n```\n\n+ 操作步骤\n1. 切换分支到develop\n2. git log 查看当前分支日志\n3. 我要将develop回退到合并之前的状态，那就是退到 commit 1这了，将commit号复制下来。退出编辑界面。\n```\n3.1 a分支的代码我不需要了，以后应该也不需要了\n  git reset 1（粘贴过来的commit号） --hard\n3.2 a分支的代码我还需要\n  git reset 1（粘贴过来的commit号）\n```\n4. 将回退后的代码推送到远端 git push origin develop\n```\n![rejected] develop -> develop (non-fast-forward)\nerror: 无法推送一些引用到 'git@github.cn:...'\n提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。\n。。。\n```\n因为本地分支的代码落后于远端develop分支, 所以这一步需要强行推送 *--force*\n5. 强推\n```\ngit push origin develop --force\n```\n\n+ git revert\n还是之前的需求，不想要合并a，只想要没合并a时的样子。\n``` \ndevelop ----1      3-----\n             \\   /\nbranch a       a\n```\n\n+ 操作步骤\n1. 切换分支到develop  git checkout develop\n2. git log 查看当前分支日志\n3. 这次和git reset 不同的是我不能复制 commit 1这个commit号了，我需要复制的是commit 2的commit号。因为revert后面跟的是具体需要哪个已经合并了的分支，而并不是需要会退到哪的commit号。\n```\ngit revert 2\n```\n4. push到远端服务器\n```\ngit push origin develop\n```\n\n### 解决合并代码 (Already up-to-date) 问题\n+ 有时我们合并代码会遇到冲突解决的问题, 这个时候如果想取消本次合并如果直接丢弃全部文件会照成远端代码还是保存了本次解决冲突的提交, 当我们重新再合并有冲突的代码就会显示Already up-to-date\n+ 接上个例子, 现在的需求是我之前已经把a分支revert了，但是我现在又需要a分支的代码了，我之前都写过一遍总不能再重新写一遍了。我首先想到的方法，把a分支再merge到develop不就好了。\n```\ngit merge a\n```\n结果\n```\nAlready up-to-date\n```\n因为我们之前提交合并的a分支的代码还在，因此我们并不能在重新合并a分支。\n\n解决方法: 使用revert之前revert的commit号。在上面的例子中就是git revert 4。于是又新增了一个commit，把之前revert的代码又重新revert回来了, 再继续执行合并操作代码冲突又会提示出来了\n","slug":"gitCommand","published":1,"updated":"2024-07-24T05:54:14.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2pn0002lyxx8od9el86","content":"<h2 id=\"Git-概念\"><a href=\"#Git-概念\" class=\"headerlink\" title=\"Git 概念\"></a>Git 概念</h2><p>Workspace：工作区<br>Index &#x2F; Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库<br><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\" alt=\"Git\"></p>\n<h3 id=\"git-HEAD\"><a href=\"#git-HEAD\" class=\"headerlink\" title=\"git HEAD\"></a>git HEAD</h3><p>HEAD 是一个对当前检出记录的符号引用, 也就是指向你正在其基础上进行工作的提交记录。<br>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。<br>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\"># 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：<br># HEAD -&gt; main -&gt; C1<br># HEAD 指向 main， main 指向 C1<br># C1 表示具体的某条提交记录 <br>$ git checkout C1<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-comment\"># 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向</span><br>$ git symbolic-<span class=\"hljs-keyword\">ref</span> HEAD<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-相对引用\"><a href=\"#git-相对引用\" class=\"headerlink\" title=\"git 相对引用\"></a>git 相对引用</h3><p>背景：通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!<br>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。<br>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 使用 ^ 向上移动 1 个提交记录</span><br><span class=\"hljs-comment\"># 所以 main^ 相当于“main 的父节点”。</span><br><span class=\"hljs-comment\"># main^^ 是 main 的第二个父节点</span><br><span class=\"hljs-variable\">$ </span>git checkout main^<br><br><span class=\"hljs-comment\"># 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3</span><br><span class=\"hljs-variable\">$ </span>git checkout main~<span class=\"hljs-number\">3</span><br><br><span class=\"hljs-comment\"># 你也可以将 HEAD 作为相对引用的参照。下面咱们就用 HEAD 在提交树中向上移动几次。</span><br><span class=\"hljs-variable\">$ </span>git checkout HEAD^<br><br><span class=\"hljs-comment\"># 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字, 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</span><br><span class=\"hljs-comment\"># Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。</span><br><span class=\"hljs-comment\"># C0 -&gt; C1 -&gt; C3(main) ｜ C0 -&gt; C2 -&gt; C3(main)</span><br><span class=\"hljs-variable\">$ </span>git checkout main^ (默认指向的是C1而不是C2)<br><span class=\"hljs-variable\">$ </span>git checkout main^<span class=\"hljs-number\">2</span> (默认指向的是C2而不是C1)<br><br><span class=\"hljs-comment\"># 这些操作符还支持链式操作！</span><br><span class=\"hljs-variable\">$ </span>git checkout HEAD~^<span class=\"hljs-number\">2</span>~<span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Git-常用语法\"><a href=\"#Git-常用语法\" class=\"headerlink\" title=\"Git 常用语法\"></a>Git 常用语法</h2><h3 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h3><p>配置 Git 的相关参数。<br>Git 一共有3个配置文件：</p>\n<ol>\n<li>仓库级的配置文件：在仓库的 .git&#x2F;.gitconfig，该配置文件只对所在的仓库有效。</li>\n<li>全局配置文件：Mac 系统在 ~&#x2F;.gitconfig，Windows 系统在 C:\\Users&lt;用户名&gt;.gitconfig。</li>\n<li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 &#x2F;usr&#x2F;local&#x2F;git）的 etc 文件夹中的 gitconfig。</li>\n</ol>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-comment\"># 查看配置信息</span><br><span class=\"hljs-comment\"># --local：仓库级，--global：全局级，--system：系统级</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; -l<br><br><span class=\"hljs-comment\"># 查看当前生效的配置信息</span><br>$ git config -l<br><br><span class=\"hljs-comment\"># 编辑配置文件</span><br><span class=\"hljs-comment\"># --local：仓库级，--global：全局级，--system：系统级</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; -e<br><br><span class=\"hljs-comment\"># 添加配置项</span><br><span class=\"hljs-comment\"># --local：仓库级，--global：全局级，--system：系统级</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; <span class=\"hljs-params\">--add</span> &lt;name&gt; &lt;value&gt;<br><br><span class=\"hljs-comment\"># 获取配置项</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; <span class=\"hljs-params\">--get</span> &lt;name&gt;<br><br><span class=\"hljs-comment\"># 删除配置项</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; <span class=\"hljs-params\">--unset</span> &lt;name&gt;<br><br><span class=\"hljs-comment\"># 配置提交记录中的用户信息</span><br>$ git config <span class=\"hljs-params\">--global</span> user.name &lt;用户名&gt;<br>$ git config <span class=\"hljs-params\">--global</span> user.email &lt;邮箱地址&gt;<br><br><span class=\"hljs-comment\"># 更改Git缓存区的大小</span><br><span class=\"hljs-comment\"># 如果提交的内容较大，默认缓存较小，提交会失败</span><br><span class=\"hljs-comment\"># 缓存大小单位：B，例如：524288000（500MB）</span><br>$ git config <span class=\"hljs-params\">--global</span> http.postBuffer &lt;缓存大小&gt;<br><br><span class=\"hljs-comment\"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span><br>$ git config <span class=\"hljs-params\">--global</span> color.ui <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 配置可以缓存密码，默认缓存时间15分钟</span><br>$ git config <span class=\"hljs-params\">--global</span> credential.helper cache<br><br><span class=\"hljs-comment\"># 配置密码的缓存时间</span><br><span class=\"hljs-comment\"># 缓存时间单位：秒</span><br>$ git config <span class=\"hljs-params\">--global</span> credential.helper &#x27;cache <span class=\"hljs-params\">--timeout=</span>&lt;缓存时间&gt;&#x27;<br><br><span class=\"hljs-comment\"># 配置长期存储密码</span><br>$ git config <span class=\"hljs-params\">--global</span> credential.helper store<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><p>从远程仓库克隆一个版本库到本地。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-comment\"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span><br>$ git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">&lt;远程仓库的网址&gt;</span><br><span class=\"hljs-title\"></span><br><span class=\"hljs-title\"># 指定本地仓库的目录</span><br><span class=\"hljs-title\">$</span> git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">&lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class=\"hljs-title\"></span><br><span class=\"hljs-title\"># -b</span> 指定要克隆的分支，默认是<span class=\"hljs-literal\">master</span>分支<br>$ git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">&lt;远程仓库的网址&gt; -b</span> <span class=\"hljs-tag\">&lt;分支名称&gt;</span> <span class=\"hljs-tag\">&lt;本地目录&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h3><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span><br><span class=\"hljs-variable\">$ </span>git init<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><p>查看本地仓库的状态。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 查看本地仓库的状态</span><br><span class=\"hljs-variable\">$ </span>git status<br><br><span class=\"hljs-comment\"># 以简短模式查看本地仓库的状态</span><br><span class=\"hljs-comment\"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span><br><span class=\"hljs-comment\"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span><br><span class=\"hljs-variable\">$ </span>git status -s<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h3><p>操作远程库。</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\"><span class=\"hljs-comment\"># 列出已经存在的远程仓库</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span><br><br><span class=\"hljs-comment\"># 列出远程仓库的详细信息，在别名后面列出URL地址</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> -<span class=\"hljs-string\">v</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">--verbose</span><br><br><span class=\"hljs-comment\"># 添加远程仓库</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">add</span> &lt;远程仓库的别名&gt; &lt;远程仓库的<span class=\"hljs-string\">URL</span>地址&gt;<br><br><span class=\"hljs-comment\"># 修改远程仓库的别名</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">rename</span> &lt;原远程仓库的别名&gt; &lt;新的别名&gt;<br><br><span class=\"hljs-comment\"># 删除指定名称的远程仓库</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">remove</span> &lt;远程仓库的别名&gt;<br><br><span class=\"hljs-comment\"># 修改远程仓库的 URL 地址</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> &lt;远程仓库的别名&gt; &lt;新的远程仓库<span class=\"hljs-string\">URL</span>地址&gt;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h3><p>操作 Git 的分支命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">列出本地的所有分支，当前所在分支以 <span class=\"hljs-string\">&quot;*&quot;</span> 标出</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">列出本地的所有分支并显示最后一次提交，当前所在分支以 <span class=\"hljs-string\">&quot;*&quot;</span> 标出</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -v</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建新分支，新的分支基于上一次提交建立</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch &lt;分支名&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">修改分支名称</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">如果不指定原分支名称则为当前所在分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">强制修改分支名称</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删除指定的本地分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -d &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">强制删除指定的本地分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -D &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">强制修改分支位置</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。将 main 分支强制指向 HEAD 的第 3 级父提交。</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -f main HEAD~3</span><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h3><p>检出命令，用于创建、切换分支等。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">切换到已存在的指定分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建并切换到指定的分支，保留所有的提交记录</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">等同于 <span class=\"hljs-string\">&quot;git branch&quot;</span> 和 <span class=\"hljs-string\">&quot;git checkout&quot;</span> 两个命令合并</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout -b &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建并切换到指定的分支，删除所有的提交记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout --orphan &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout &lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-cherry-pick\"><a href=\"#git-cherry-pick\" class=\"headerlink\" title=\"git cherry-pick\"></a>git cherry-pick</h3><p>把已经提交（多个&#x2F;单个）的记录有序的合并到当前分支。关键词：多个&#x2F;有序</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 把已经提交的记录合并到当前分支</span><br><span class=\"hljs-variable\">$ </span>git cherry-pick &lt;commit ID&gt;<br><br><span class=\"hljs-comment\"># 可进行多个提交的抓取 C1 C2 或者 C2 C1 产生的效果完全不一样是有孙旭的提交记录</span><br><span class=\"hljs-variable\">$ </span>git cherry-pick C1 C2<br><span class=\"hljs-variable\">$ </span>git cherry-pick C2 C1<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># 把指定的文件添加到暂存区中</span><br>$ git <span class=\"hljs-built_in\">add</span> &lt;文件路径&gt;<br><br><span class=\"hljs-comment\"># 添加所有修改、已删除的文件到暂存区中</span><br>$ git <span class=\"hljs-built_in\">add</span> -u [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-built_in\">add</span> --update [&lt;文件路径&gt;]<br><br><span class=\"hljs-comment\"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span><br>$ git <span class=\"hljs-built_in\">add</span> -A [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-built_in\">add</span> --all [&lt;文件路径&gt;]<br><br><span class=\"hljs-comment\"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span><br>$ git <span class=\"hljs-built_in\">add</span> -i [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-built_in\">add</span> --interactive [&lt;文件路径&gt;]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><p>将暂存区中的文件提交到本地仓库中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把暂存区中的文件提交到本地仓库中并添加描述信息</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit -m <span class=\"hljs-string\">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把所有修改、已删除的文件提交到本地仓库中</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">不包括未被版本库跟踪的文件，等同于先调用了 <span class=\"hljs-string\">&quot;git add -u&quot;</span></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit -a -m <span class=\"hljs-string\">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">修改上次提交的描述信息</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit --amend</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h3><p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。<br>git fetch 完成了仅有的但是很重要的两步:</p>\n<ul>\n<li>从远程仓库下载本地仓库中缺失的提交记录</li>\n<li>更新远程分支指针(如 origin&#x2F;main)</li>\n</ul>\n<p>git fetch 不会做的事: </p>\n<ul>\n<li>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</li>\n</ul>\n<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。<br>所以, 你可以将 git fetch 的理解为单纯的下载操作。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 将远程仓库所有分支的最新版本全部取回到本地</span><br><span class=\"hljs-variable\">$ </span>git fetch &lt;远程仓库的别名&gt;<br><span class=\"hljs-variable\">$ </span>git fetch origin<br><br><span class=\"hljs-comment\"># 将远程仓库指定分支的最新版本取回到本地</span><br><span class=\"hljs-variable\">$ </span>git fetch &lt;远程主机名&gt; &lt;分支名&gt;<br><span class=\"hljs-variable\">$ </span>git fetch origin <span class=\"hljs-symbol\">pre:</span>pre<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h3><p>合并分支</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 把指定的分支合并到当前所在的分支下</span><br><span class=\"hljs-variable\">$ </span>git merge &lt;分支名称&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><p>比较版本之间的差异。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span><br><br><span class=\"hljs-comment\"># 比较暂存区中的文件和上次提交时的差异</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> <span class=\"hljs-literal\">--cached</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> <span class=\"hljs-literal\">--staged</span><br><br><span class=\"hljs-comment\"># 比较当前文件和上次提交时的差异</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> HEAD<br><br><span class=\"hljs-comment\"># 查看从指定的版本之后改动的内容</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> &lt;commit ID&gt;<br><br><span class=\"hljs-comment\"># 比较两个分支之间的差异</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> &lt;分支名称&gt; &lt;分支名称&gt;<br><br><span class=\"hljs-comment\"># 查看两个分支分开后各自的改动内容</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> &lt;分支名称&gt;...&lt;分支名称&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>从远程仓库获取最新版本并合并到本地。<br>首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 从远程仓库获取最新版本。</span><br><span class=\"hljs-variable\">$ </span>git pull<br><br><span class=\"hljs-comment\"># git pull origin foo 相当于：git fetch origin foo; git merge o/foo</span><br><span class=\"hljs-comment\"># git pull origin bar~1:bugFix 相当于：git fetch origin bar~1:bugFix; git merge bugFix</span><br><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><p>把本地仓库的提交推送到远程仓库。远程仓库对应的分支会指向最新的提交，本地的远程分支也会指向最新的提交记录</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-comment\"># push 参数1</span><br><span class=\"hljs-comment\"># 把本地仓库的分支推送到远程仓库</span><br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;<br><span class=\"hljs-variable\">$ </span>git push &lt;remote&gt; &lt;place&gt;<br><span class=\"hljs-variable\">$ </span>git push origin main(本地分支)<br><span class=\"hljs-comment\"># 把这个命令翻译过来就是：</span><br><span class=\"hljs-comment\"># 切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</span><br><span class=\"hljs-comment\"># 我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</span><br><span class=\"hljs-comment\"># 需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</span><br><br><span class=\"hljs-comment\"># push 参数2</span><br><span class=\"hljs-comment\"># 把本地仓库的分支推送到远程仓库的指定分支</span><br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;<span class=\"hljs-symbol\">:&lt;</span>远程分支名&gt;<br><span class=\"hljs-comment\"># 当为 git push 指定 place 参数为 main 时，我们同时指定了提交记录的来源和去向。</span><br><span class=\"hljs-comment\"># 你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。</span><br><span class=\"hljs-comment\"># 当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）</span><br><span class=\"hljs-variable\">$ </span>git push origin &lt;source&gt;<span class=\"hljs-symbol\">:&lt;destination&gt;</span><br><span class=\"hljs-comment\"># source 可以是任何 Git 能识别的位置：</span><br><span class=\"hljs-variable\">$ </span>git push origin <span class=\"hljs-title class_\">HEAD</span>^<span class=\"hljs-symbol\">:foo</span><br><br><span class=\"hljs-comment\"># 删除指定的远程仓库的分支</span><br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; <span class=\"hljs-symbol\">:&lt;</span>远程分支名&gt;<br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;<br><span class=\"hljs-comment\"># 为推送当前分支并建立与远程上游的跟踪，使用</span><br><span class=\"hljs-variable\">$ </span>git push --set-upstream &lt;远程仓库别名&gt; &lt;远程分支名&gt;<br><span class=\"hljs-variable\">$ </span>git push --set-upstream origin master<br><span class=\"hljs-comment\"># 强行推送本地记录</span><br><span class=\"hljs-variable\">$ </span>git push -u origin +master<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h3><p>显示提交的记录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">打印所有的提交记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">log</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">打印从第一次提交到指定的提交的记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">log</span> &lt;commit ID&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">打印指定数量的最新提交的记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">log</span> -&lt;指定的数量&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>还原提交记录。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"># 重置暂存区，但文件不受影响<br># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件<br># 没有指定 <span class=\"hljs-keyword\">commit</span> ID 则默认为当前 HEAD<br>$ git <span class=\"hljs-keyword\">reset</span> [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--mixed [&lt;文件路径&gt;]</span><br><br># <span class=\"hljs-comment\">--mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作 （git status 是红色的状态）。</span><br>$ git <span class=\"hljs-keyword\">reset</span> &lt;<span class=\"hljs-keyword\">commit</span> ID&gt;<br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--mixed &lt;commit ID&gt;</span><br><br># <span class=\"hljs-comment\">--soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）</span><br># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;<br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--soft &lt;commit ID&gt;</span><br><br># <span class=\"hljs-comment\">--hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。</span><br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--hard &lt;commit ID&gt;</span><br><br># <span class=\"hljs-comment\">--merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】</span><br># <span class=\"hljs-comment\">--keep 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。</span><br><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h3><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 生成一个新的提交来撤销某次提交</span><br><span class=\"hljs-variable\">$ </span>git revert &lt;commit ID&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-tag\"><a href=\"#git-tag\" class=\"headerlink\" title=\"git tag\"></a>git tag</h3><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。<br>你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？<br>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。<br>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pf\"><span class=\"hljs-comment\"># 我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。</span><br>$ git <span class=\"hljs-keyword\">tag</span> v1 C1<br><br><span class=\"hljs-comment\"># 打印所有的标签</span><br>$ git <span class=\"hljs-keyword\">tag</span><br><br><span class=\"hljs-comment\"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span><br>$ git <span class=\"hljs-keyword\">tag</span> <span class=\"hljs-variable\">&lt;标签名称&gt;</span> [<span class=\"hljs-variable\">&lt;commit ID&gt;</span>]<br><br><span class=\"hljs-comment\"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span><br>$ git <span class=\"hljs-keyword\">tag</span> -a <span class=\"hljs-variable\">&lt;标签名称&gt;</span> -m <span class=\"hljs-variable\">&lt;标签描述信息&gt;</span> [<span class=\"hljs-variable\">&lt;commit ID&gt;</span>]<br><br><span class=\"hljs-comment\"># 切换到指定的标签</span><br>$ git checkout <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 查看标签的信息</span><br>$ git show <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 删除指定的标签</span><br>$ git <span class=\"hljs-keyword\">tag</span> -d <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 将指定的标签提交到远程仓库</span><br>$ git push <span class=\"hljs-variable\">&lt;远程仓库的别名&gt;</span> <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 将本地所有的标签全部提交到远程仓库</span><br>$ git push <span class=\"hljs-variable\">&lt;远程仓库的别名&gt;</span> –tags<br><span class=\"hljs-comment\"># 强push</span><br>$ git push origin <span class=\"hljs-variable\">&lt;远程分支名&gt;</span> --force<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-mv\"><a href=\"#git-mv\" class=\"headerlink\" title=\"git mv\"></a>git mv</h3><p>重命名文件或者文件夹。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># 重命名指定的文件或者文件夹</span><br>$ git mv &lt;源文件<span class=\"hljs-regexp\">/文件夹&gt; &lt;目标文件/</span>文件夹&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h3><p>删除文件或者文件夹。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">rm</span> &lt;文件路径&gt;<br><br><span class=\"hljs-comment\"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">-r</span> &lt;文件夹路径&gt;<br><br><span class=\"hljs-comment\"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">--cached</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h3><p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。<br>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">将当前分支变基到目标分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase &lt;远程分支名&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">将某个分支变基到另一个分支上 (将分支b变基到分支a上)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase &lt;分支名a&gt; &lt;分支名b&gt;</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase a b</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">表示继续下一个冲突(git rebase --<span class=\"hljs-built_in\">continue</span> 就相当于 git commit)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --<span class=\"hljs-built_in\">continue</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">表示跳过当前冲突</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --skip</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">表示退出rebase模式, 回到运行git rebase master命令之前的状态</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --abort</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-describe\"><a href=\"#git-describe\" class=\"headerlink\" title=\"git describe\"></a>git describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签）</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"># &lt;<span class=\"hljs-built_in\">ref</span>&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。<br>git describe &lt;<span class=\"hljs-built_in\">ref</span>&gt;<br><br># 它输出的结果是这样的：&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;<br># tag 表示的是离 <span class=\"hljs-built_in\">ref</span> 最近的标签， numCommits 是表示这个 <span class=\"hljs-built_in\">ref</span> 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 <span class=\"hljs-built_in\">ref</span> 所表示的提交记录哈希值的前几位。<br># <span class=\"hljs-constructor\">C0(<span class=\"hljs-params\">v1</span>)</span> -&gt; C1 -&gt; <span class=\"hljs-constructor\">C2(<span class=\"hljs-params\">main</span>)</span><br>git describe main 会输出：v1_2_gC2 <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-worktree\"><a href=\"#git-worktree\" class=\"headerlink\" title=\"git worktree\"></a>git worktree</h3><p>仅需维护一个 repo，又可以同时在多个 branch 上工作，互不影响<br>默认情况下， git init 或 git clone 初始化的 repo，只有一个 worktree，叫做 main worktree<br>在某一个目录下使用 Git 命令，当前目录下要么有 .git 文件夹；要么有 .git 文件，如果只有 .git 文件，里面的内容必须是指向 .git 文件夹的</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"># 常用worktree 命令<br>$ git worktree add <span class=\"hljs-comment\">[-f]</span> <span class=\"hljs-comment\">[--detach]</span> <span class=\"hljs-comment\">[--checkout]</span> <span class=\"hljs-comment\">[--lock]</span> <span class=\"hljs-comment\">[-b &lt;new-branch&gt;]</span> &lt;path&gt; <span class=\"hljs-comment\">[&lt;commit-ish&gt;]</span><br>$ git worktree list <span class=\"hljs-comment\">[--porcelain]</span><br>$ git worktree remove <span class=\"hljs-comment\">[-f]</span> &lt;worktree&gt;<br>$ git worktree prune <span class=\"hljs-comment\">[-n]</span> <span class=\"hljs-comment\">[-v]</span> <span class=\"hljs-comment\">[--expire &lt;expire&gt;]</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>创建一个worktree<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">git worktree add ..<span class=\"hljs-regexp\">/feature/</span>feature2<br></code></pre></td></tr></table></figure>\n目录结构<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">├── amend-crash-<span class=\"hljs-built_in\">demo</span><br>└── <span class=\"hljs-built_in\">feature</span><br>    └── feature2<br></code></pre></td></tr></table></figure>\ncd ..&#x2F;feature&#x2F;feature2&#x2F; 会发现，这个分支下并不存在 .git 文件夹，却存在一个 .git 文件，打开文件，内容如下：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">gitdir: <span class=\"hljs-regexp\">/Users/</span>rgyb<span class=\"hljs-regexp\">/Documents/</span>projects<span class=\"hljs-regexp\">/amend-crash-demo/</span>.git<span class=\"hljs-regexp\">/worktrees/</span>feature2<br></code></pre></td></tr></table></figure></li>\n<li>git worktree remove<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"># 删除一个worktree 参数是文件路径 注意路径前不加 <span class=\"hljs-string\">&quot;/&quot;</span><br>git worktree <span class=\"hljs-built_in\">remove</span> <span class=\"hljs-built_in\">feature</span>/feature2<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># 假设你创建一个 worktree，并在里面有改动，突然间这个worktree 又不需要了，此刻你按照上述命令是不能删掉了，此时就需要 -f 参数来帮忙了</span><br>git worktree <span class=\"hljs-built_in\">remove</span> -f feature/feature2<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># 删除了 worktree，其实在 Git 的文件中，还有很多 administrative 文件是没有用的，为了保持清洁，我们还需要进一步清理</span><br><span class=\"hljs-comment\"># 这个命令就是清洁的兜底操作，可以让我们的工作始终保持整洁</span><br><span class=\"hljs-attribute\">git</span> worktree prune<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Git操作场景-🌰\"><a href=\"#Git操作场景-🌰\" class=\"headerlink\" title=\"Git操作场景(🌰)\"></a>Git操作场景(🌰)</h2><h3 id=\"删除掉本地不存在的远程分支\"><a href=\"#删除掉本地不存在的远程分支\" class=\"headerlink\" title=\"删除掉本地不存在的远程分支\"></a>删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch –all 依然会显示该远程分支，可使用下列的命令进行删除</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 使用 pull 命令，添加 -p 参数</span><br><span class=\"hljs-variable\">$ </span>git pull -p<br><br><span class=\"hljs-comment\"># 等同于下面的命令</span><br><span class=\"hljs-variable\">$ </span>git fetch -p<br><span class=\"hljs-variable\">$ </span>git fetch --prune origin<br></code></pre></td></tr></table></figure>\n<h3 id=\"只提交某次记录\"><a href=\"#只提交某次记录\" class=\"headerlink\" title=\"只提交某次记录\"></a>只提交某次记录</h3><p>发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。<br>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！<br>最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</span><br><span class=\"hljs-variable\">$ </span>git rebase -i<br><span class=\"hljs-variable\">$ </span>git cherry-pick <br></code></pre></td></tr></table></figure>\n<h3 id=\"本地分支合并远端分支\"><a href=\"#本地分支合并远端分支\" class=\"headerlink\" title=\"本地分支合并远端分支\"></a>本地分支合并远端分支</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git cherry-pick o/main</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase o/main</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git merge o/main</span><br>...<br></code></pre></td></tr></table></figure>\n<h3 id=\"远程分支代码比本地分支代码新的情况进行提交\"><a href=\"#远程分支代码比本地分支代码新的情况进行提交\" class=\"headerlink\" title=\"远程分支代码比本地分支代码新的情况进行提交\"></a>远程分支代码比本地分支代码新的情况进行提交</h3><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。</p>\n<p>这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？<br>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式1: rebase</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git fetch; git rebase orgin/main; git push</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式2: merge</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git fetch; git merge orgin/main; git push</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式3: pull / pull --rebase</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">要敲那么多命令，有没有更简单一点的？前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写！</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git pull --rebase; git push</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git pull; git push</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"远程跟踪\"><a href=\"#远程跟踪\" class=\"headerlink\" title=\"远程跟踪\"></a>远程跟踪</h3><p>自定义远程跟踪分支：你可以让任意分支跟踪 o&#x2F;main, 然后该分支会像 main 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMain 上执行 git push，将工作推送到远程仓库的 main 分支上。<br><strong>需要注意的是 main 并未被更新</strong><br>有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">1: git checkout -b</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout -b totallyNotMain o/main</span><br>就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main。<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">2: git branch -u</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -u o/main foo</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">这样 foo 就会跟踪 o/main 了。如果当前就在 foo 分支上, 还可以省略 foo：</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -u o/main</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"代码分支迁移到不同仓库\"><a href=\"#代码分支迁移到不同仓库\" class=\"headerlink\" title=\"代码分支迁移到不同仓库\"></a>代码分支迁移到不同仓库</h3><p>当我们需要将分支origin(A)&#x2F;a 迁移到 origin(B)&#x2F;a 并保留分支记录</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\">切换到当前<span class=\"hljs-string\">origin</span>(<span class=\"hljs-string\">A</span>) 更换当前仓库为目标仓库<br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">https</span>://<span class=\"hljs-string\">gitlab</span>.<span class=\"hljs-string\">southinfo</span>.<span class=\"hljs-string\">net</span>/<span class=\"hljs-string\">ecrp-sg-web</span>.<span class=\"hljs-string\">git</span><br>推送当前分支到更换后的目标仓库(需要密码/<span class=\"hljs-string\">ssh</span>认证)<br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">push</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码回滚-reset-x2F-revert\"><a href=\"#代码回滚-reset-x2F-revert\" class=\"headerlink\" title=\"代码回滚(reset&#x2F;revert)\"></a>代码回滚(reset&#x2F;revert)</h3><ul>\n<li>结论</li>\n</ul>\n<ol>\n<li>git revert 后会多出一条commit，这里可进行回撤操作</li>\n<li>git reset 直接把之前 commit 删掉，非 git reset –hard 的操作是不会删掉修改代码，如果远程已经有之前代码，需要强推 git push -f</li>\n</ol>\n<ul>\n<li>应用场景</li>\n</ul>\n<ol>\n<li>如果回退分支的代码以后还需要的话用git revert就再好不过了；</li>\n<li>如果分支我就是提错了没用了还不想让别人发现我错的代码，那就git reset吧</li>\n</ol>\n<ul>\n<li><p>git reset<br>develop将a分支合并后，想要不留痕迹的撤回合并。这个时候用git reset就是很好的选择了</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">develop <span class=\"hljs-comment\">----1      3-----</span><br>             \\   /<br>branch <span class=\"hljs-keyword\">a</span>       <span class=\"hljs-keyword\">a</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>操作步骤</p>\n</li>\n</ul>\n<ol>\n<li>切换分支到develop</li>\n<li>git log 查看当前分支日志</li>\n<li>我要将develop回退到合并之前的状态，那就是退到 commit 1这了，将commit号复制下来。退出编辑界面。<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-number\">3.1</span> a分支的代码我不需要了，以后应该也不需要了<br>  git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-number\">1</span>（粘贴过来的<span class=\"hljs-keyword\">commit</span>号） <span class=\"hljs-comment\">--hard</span><br><span class=\"hljs-number\">3.2</span> a分支的代码我还需要<br>  git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-number\">1</span>（粘贴过来的<span class=\"hljs-keyword\">commit</span>号）<br></code></pre></td></tr></table></figure></li>\n<li>将回退后的代码推送到远端 git push origin develop<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">![rejected] develop -&gt; develop (non-fast-forward)<br><span class=\"hljs-keyword\">error: </span>无法推送一些引用到 &#x27;git@github.cn:...&#x27;<br>提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。<br>。。。<br></code></pre></td></tr></table></figure>\n因为本地分支的代码落后于远端develop分支, 所以这一步需要强行推送 <em>–force</em></li>\n<li>强推<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> develop --force<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><p>git revert<br>还是之前的需求，不想要合并a，只想要没合并a时的样子。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">develop <span class=\"hljs-comment\">----1      3-----</span><br>             \\   /<br>branch <span class=\"hljs-keyword\">a</span>       <span class=\"hljs-keyword\">a</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>操作步骤</p>\n</li>\n</ul>\n<ol>\n<li>切换分支到develop  git checkout develop</li>\n<li>git log 查看当前分支日志</li>\n<li>这次和git reset 不同的是我不能复制 commit 1这个commit号了，我需要复制的是commit 2的commit号。因为revert后面跟的是具体需要哪个已经合并了的分支，而并不是需要会退到哪的commit号。<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">git</span> revert <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure></li>\n<li>push到远端服务器<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> develop<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"解决合并代码-Already-up-to-date-问题\"><a href=\"#解决合并代码-Already-up-to-date-问题\" class=\"headerlink\" title=\"解决合并代码 (Already up-to-date) 问题\"></a>解决合并代码 (Already up-to-date) 问题</h3><ul>\n<li>有时我们合并代码会遇到冲突解决的问题, 这个时候如果想取消本次合并如果直接丢弃全部文件会照成远端代码还是保存了本次解决冲突的提交, 当我们重新再合并有冲突的代码就会显示Already up-to-date</li>\n<li>接上个例子, 现在的需求是我之前已经把a分支revert了，但是我现在又需要a分支的代码了，我之前都写过一遍总不能再重新写一遍了。我首先想到的方法，把a分支再merge到develop不就好了。<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">git <span class=\"hljs-built_in\">merge</span> <span class=\"hljs-keyword\">a</span><br></code></pre></td></tr></table></figure>\n结果<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">Already up-<span class=\"hljs-keyword\">to</span>-<span class=\"hljs-built_in\">date</span><br></code></pre></td></tr></table></figure>\n因为我们之前提交合并的a分支的代码还在，因此我们并不能在重新合并a分支。</li>\n</ul>\n<p>解决方法: 使用revert之前revert的commit号。在上面的例子中就是git revert 4。于是又新增了一个commit，把之前revert的代码又重新revert回来了, 再继续执行合并操作代码冲突又会提示出来了</p>\n","site":{"data":{}},"wordcount":13759,"excerpt":"","more":"<h2 id=\"Git-概念\"><a href=\"#Git-概念\" class=\"headerlink\" title=\"Git 概念\"></a>Git 概念</h2><p>Workspace：工作区<br>Index &#x2F; Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库<br><img src=\"https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\" alt=\"Git\"></p>\n<h3 id=\"git-HEAD\"><a href=\"#git-HEAD\" class=\"headerlink\" title=\"git HEAD\"></a>git HEAD</h3><p>HEAD 是一个对当前检出记录的符号引用, 也就是指向你正在其基础上进行工作的提交记录。<br>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。<br>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\"># 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：<br># HEAD -&gt; main -&gt; C1<br># HEAD 指向 main， main 指向 C1<br># C1 表示具体的某条提交记录 <br>$ git checkout C1<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-comment\"># 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向</span><br>$ git symbolic-<span class=\"hljs-keyword\">ref</span> HEAD<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-相对引用\"><a href=\"#git-相对引用\" class=\"headerlink\" title=\"git 相对引用\"></a>git 相对引用</h3><p>背景：通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 git log 来查查看提交记录的哈希值，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!<br>使用相对引用的话，你就可以从一个易于记忆的地方（比如 bugFix 分支或 HEAD）开始计算。<br>相对引用非常给力，这里我介绍两个简单的用法：</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 使用 ^ 向上移动 1 个提交记录</span><br><span class=\"hljs-comment\"># 所以 main^ 相当于“main 的父节点”。</span><br><span class=\"hljs-comment\"># main^^ 是 main 的第二个父节点</span><br><span class=\"hljs-variable\">$ </span>git checkout main^<br><br><span class=\"hljs-comment\"># 使用 ~&lt;num&gt; 向上移动多个提交记录，如 ~3</span><br><span class=\"hljs-variable\">$ </span>git checkout main~<span class=\"hljs-number\">3</span><br><br><span class=\"hljs-comment\"># 你也可以将 HEAD 作为相对引用的参照。下面咱们就用 HEAD 在提交树中向上移动几次。</span><br><span class=\"hljs-variable\">$ </span>git checkout HEAD^<br><br><span class=\"hljs-comment\"># 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字, 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</span><br><span class=\"hljs-comment\"># Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。</span><br><span class=\"hljs-comment\"># C0 -&gt; C1 -&gt; C3(main) ｜ C0 -&gt; C2 -&gt; C3(main)</span><br><span class=\"hljs-variable\">$ </span>git checkout main^ (默认指向的是C1而不是C2)<br><span class=\"hljs-variable\">$ </span>git checkout main^<span class=\"hljs-number\">2</span> (默认指向的是C2而不是C1)<br><br><span class=\"hljs-comment\"># 这些操作符还支持链式操作！</span><br><span class=\"hljs-variable\">$ </span>git checkout HEAD~^<span class=\"hljs-number\">2</span>~<span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"Git-常用语法\"><a href=\"#Git-常用语法\" class=\"headerlink\" title=\"Git 常用语法\"></a>Git 常用语法</h2><h3 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h3><p>配置 Git 的相关参数。<br>Git 一共有3个配置文件：</p>\n<ol>\n<li>仓库级的配置文件：在仓库的 .git&#x2F;.gitconfig，该配置文件只对所在的仓库有效。</li>\n<li>全局配置文件：Mac 系统在 ~&#x2F;.gitconfig，Windows 系统在 C:\\Users&lt;用户名&gt;.gitconfig。</li>\n<li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 &#x2F;usr&#x2F;local&#x2F;git）的 etc 文件夹中的 gitconfig。</li>\n</ol>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs jboss-cli\"><span class=\"hljs-comment\"># 查看配置信息</span><br><span class=\"hljs-comment\"># --local：仓库级，--global：全局级，--system：系统级</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; -l<br><br><span class=\"hljs-comment\"># 查看当前生效的配置信息</span><br>$ git config -l<br><br><span class=\"hljs-comment\"># 编辑配置文件</span><br><span class=\"hljs-comment\"># --local：仓库级，--global：全局级，--system：系统级</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; -e<br><br><span class=\"hljs-comment\"># 添加配置项</span><br><span class=\"hljs-comment\"># --local：仓库级，--global：全局级，--system：系统级</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; <span class=\"hljs-params\">--add</span> &lt;name&gt; &lt;value&gt;<br><br><span class=\"hljs-comment\"># 获取配置项</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; <span class=\"hljs-params\">--get</span> &lt;name&gt;<br><br><span class=\"hljs-comment\"># 删除配置项</span><br>$ git config &lt;<span class=\"hljs-params\">--local</span> | <span class=\"hljs-params\">--global</span> | <span class=\"hljs-params\">--system</span>&gt; <span class=\"hljs-params\">--unset</span> &lt;name&gt;<br><br><span class=\"hljs-comment\"># 配置提交记录中的用户信息</span><br>$ git config <span class=\"hljs-params\">--global</span> user.name &lt;用户名&gt;<br>$ git config <span class=\"hljs-params\">--global</span> user.email &lt;邮箱地址&gt;<br><br><span class=\"hljs-comment\"># 更改Git缓存区的大小</span><br><span class=\"hljs-comment\"># 如果提交的内容较大，默认缓存较小，提交会失败</span><br><span class=\"hljs-comment\"># 缓存大小单位：B，例如：524288000（500MB）</span><br>$ git config <span class=\"hljs-params\">--global</span> http.postBuffer &lt;缓存大小&gt;<br><br><span class=\"hljs-comment\"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span><br>$ git config <span class=\"hljs-params\">--global</span> color.ui <span class=\"hljs-literal\">true</span><br><br><span class=\"hljs-comment\"># 配置可以缓存密码，默认缓存时间15分钟</span><br>$ git config <span class=\"hljs-params\">--global</span> credential.helper cache<br><br><span class=\"hljs-comment\"># 配置密码的缓存时间</span><br><span class=\"hljs-comment\"># 缓存时间单位：秒</span><br>$ git config <span class=\"hljs-params\">--global</span> credential.helper &#x27;cache <span class=\"hljs-params\">--timeout=</span>&lt;缓存时间&gt;&#x27;<br><br><span class=\"hljs-comment\"># 配置长期存储密码</span><br>$ git config <span class=\"hljs-params\">--global</span> credential.helper store<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><p>从远程仓库克隆一个版本库到本地。</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crmsh\"><span class=\"hljs-comment\"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span><br>$ git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">&lt;远程仓库的网址&gt;</span><br><span class=\"hljs-title\"></span><br><span class=\"hljs-title\"># 指定本地仓库的目录</span><br><span class=\"hljs-title\">$</span> git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">&lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class=\"hljs-title\"></span><br><span class=\"hljs-title\"># -b</span> 指定要克隆的分支，默认是<span class=\"hljs-literal\">master</span>分支<br>$ git <span class=\"hljs-keyword\">clone</span> <span class=\"hljs-title\">&lt;远程仓库的网址&gt; -b</span> <span class=\"hljs-tag\">&lt;分支名称&gt;</span> <span class=\"hljs-tag\">&lt;本地目录&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h3><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span><br><span class=\"hljs-variable\">$ </span>git init<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><p>查看本地仓库的状态。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 查看本地仓库的状态</span><br><span class=\"hljs-variable\">$ </span>git status<br><br><span class=\"hljs-comment\"># 以简短模式查看本地仓库的状态</span><br><span class=\"hljs-comment\"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span><br><span class=\"hljs-comment\"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span><br><span class=\"hljs-variable\">$ </span>git status -s<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h3><p>操作远程库。</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\"><span class=\"hljs-comment\"># 列出已经存在的远程仓库</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span><br><br><span class=\"hljs-comment\"># 列出远程仓库的详细信息，在别名后面列出URL地址</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> -<span class=\"hljs-string\">v</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">--verbose</span><br><br><span class=\"hljs-comment\"># 添加远程仓库</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">add</span> &lt;远程仓库的别名&gt; &lt;远程仓库的<span class=\"hljs-string\">URL</span>地址&gt;<br><br><span class=\"hljs-comment\"># 修改远程仓库的别名</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">rename</span> &lt;原远程仓库的别名&gt; &lt;新的别名&gt;<br><br><span class=\"hljs-comment\"># 删除指定名称的远程仓库</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-string\">remove</span> &lt;远程仓库的别名&gt;<br><br><span class=\"hljs-comment\"># 修改远程仓库的 URL 地址</span><br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> &lt;远程仓库的别名&gt; &lt;新的远程仓库<span class=\"hljs-string\">URL</span>地址&gt;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h3><p>操作 Git 的分支命令。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">列出本地的所有分支，当前所在分支以 <span class=\"hljs-string\">&quot;*&quot;</span> 标出</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">列出本地的所有分支并显示最后一次提交，当前所在分支以 <span class=\"hljs-string\">&quot;*&quot;</span> 标出</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -v</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建新分支，新的分支基于上一次提交建立</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch &lt;分支名&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">修改分支名称</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">如果不指定原分支名称则为当前所在分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">强制修改分支名称</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">删除指定的本地分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -d &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">强制删除指定的本地分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -D &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">强制修改分支位置</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。将 main 分支强制指向 HEAD 的第 3 级父提交。</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -f main HEAD~3</span><br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h3><p>检出命令，用于创建、切换分支等。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">切换到已存在的指定分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建并切换到指定的分支，保留所有的提交记录</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">等同于 <span class=\"hljs-string\">&quot;git branch&quot;</span> 和 <span class=\"hljs-string\">&quot;git checkout&quot;</span> 两个命令合并</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout -b &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">创建并切换到指定的分支，删除所有的提交记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout --orphan &lt;分支名称&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout &lt;文件路径&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-cherry-pick\"><a href=\"#git-cherry-pick\" class=\"headerlink\" title=\"git cherry-pick\"></a>git cherry-pick</h3><p>把已经提交（多个&#x2F;单个）的记录有序的合并到当前分支。关键词：多个&#x2F;有序</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 把已经提交的记录合并到当前分支</span><br><span class=\"hljs-variable\">$ </span>git cherry-pick &lt;commit ID&gt;<br><br><span class=\"hljs-comment\"># 可进行多个提交的抓取 C1 C2 或者 C2 C1 产生的效果完全不一样是有孙旭的提交记录</span><br><span class=\"hljs-variable\">$ </span>git cherry-pick C1 C2<br><span class=\"hljs-variable\">$ </span>git cherry-pick C2 C1<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># 把指定的文件添加到暂存区中</span><br>$ git <span class=\"hljs-built_in\">add</span> &lt;文件路径&gt;<br><br><span class=\"hljs-comment\"># 添加所有修改、已删除的文件到暂存区中</span><br>$ git <span class=\"hljs-built_in\">add</span> -u [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-built_in\">add</span> --update [&lt;文件路径&gt;]<br><br><span class=\"hljs-comment\"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span><br>$ git <span class=\"hljs-built_in\">add</span> -A [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-built_in\">add</span> --all [&lt;文件路径&gt;]<br><br><span class=\"hljs-comment\"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span><br>$ git <span class=\"hljs-built_in\">add</span> -i [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-built_in\">add</span> --interactive [&lt;文件路径&gt;]<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><p>将暂存区中的文件提交到本地仓库中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把暂存区中的文件提交到本地仓库中并添加描述信息</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit -m <span class=\"hljs-string\">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">把所有修改、已删除的文件提交到本地仓库中</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">不包括未被版本库跟踪的文件，等同于先调用了 <span class=\"hljs-string\">&quot;git add -u&quot;</span></span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit -a -m <span class=\"hljs-string\">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">修改上次提交的描述信息</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git commit --amend</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h3><p>git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。<br>git fetch 完成了仅有的但是很重要的两步:</p>\n<ul>\n<li>从远程仓库下载本地仓库中缺失的提交记录</li>\n<li>更新远程分支指针(如 origin&#x2F;main)</li>\n</ul>\n<p>git fetch 不会做的事: </p>\n<ul>\n<li>git fetch 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</li>\n</ul>\n<p>理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。<br>所以, 你可以将 git fetch 的理解为单纯的下载操作。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 将远程仓库所有分支的最新版本全部取回到本地</span><br><span class=\"hljs-variable\">$ </span>git fetch &lt;远程仓库的别名&gt;<br><span class=\"hljs-variable\">$ </span>git fetch origin<br><br><span class=\"hljs-comment\"># 将远程仓库指定分支的最新版本取回到本地</span><br><span class=\"hljs-variable\">$ </span>git fetch &lt;远程主机名&gt; &lt;分支名&gt;<br><span class=\"hljs-variable\">$ </span>git fetch origin <span class=\"hljs-symbol\">pre:</span>pre<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h3><p>合并分支</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 把指定的分支合并到当前所在的分支下</span><br><span class=\"hljs-variable\">$ </span>git merge &lt;分支名称&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><p>比较版本之间的差异。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span><br><br><span class=\"hljs-comment\"># 比较暂存区中的文件和上次提交时的差异</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> <span class=\"hljs-literal\">--cached</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> <span class=\"hljs-literal\">--staged</span><br><br><span class=\"hljs-comment\"># 比较当前文件和上次提交时的差异</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> HEAD<br><br><span class=\"hljs-comment\"># 查看从指定的版本之后改动的内容</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> &lt;commit ID&gt;<br><br><span class=\"hljs-comment\"># 比较两个分支之间的差异</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> &lt;分支名称&gt; &lt;分支名称&gt;<br><br><span class=\"hljs-comment\"># 查看两个分支分开后各自的改动内容</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">diff</span> &lt;分支名称&gt;...&lt;分支名称&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>从远程仓库获取最新版本并合并到本地。<br>首先会执行 git fetch，然后执行 git merge，把获取的分支的 HEAD 合并到当前分支。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 从远程仓库获取最新版本。</span><br><span class=\"hljs-variable\">$ </span>git pull<br><br><span class=\"hljs-comment\"># git pull origin foo 相当于：git fetch origin foo; git merge o/foo</span><br><span class=\"hljs-comment\"># git pull origin bar~1:bugFix 相当于：git fetch origin bar~1:bugFix; git merge bugFix</span><br><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><p>把本地仓库的提交推送到远程仓库。远程仓库对应的分支会指向最新的提交，本地的远程分支也会指向最新的提交记录</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\"><span class=\"hljs-comment\"># push 参数1</span><br><span class=\"hljs-comment\"># 把本地仓库的分支推送到远程仓库</span><br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;<br><span class=\"hljs-variable\">$ </span>git push &lt;remote&gt; &lt;place&gt;<br><span class=\"hljs-variable\">$ </span>git push origin main(本地分支)<br><span class=\"hljs-comment\"># 把这个命令翻译过来就是：</span><br><span class=\"hljs-comment\"># 切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。</span><br><span class=\"hljs-comment\"># 我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。</span><br><span class=\"hljs-comment\"># 需要注意的是，因为我们通过指定参数告诉了 Git 所有它需要的信息, 所以它就忽略了我们所检出的分支的属性！</span><br><br><span class=\"hljs-comment\"># push 参数2</span><br><span class=\"hljs-comment\"># 把本地仓库的分支推送到远程仓库的指定分支</span><br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;<span class=\"hljs-symbol\">:&lt;</span>远程分支名&gt;<br><span class=\"hljs-comment\"># 当为 git push 指定 place 参数为 main 时，我们同时指定了提交记录的来源和去向。</span><br><span class=\"hljs-comment\"># 你可能想问 —— 如果来源和去向分支的名称不同呢？比如你想把本地的 foo 分支推送到远程仓库中的 bar 分支。</span><br><span class=\"hljs-comment\"># 当然是可以的啦 :) Git 拥有超强的灵活性（有点过于灵活了）</span><br><span class=\"hljs-variable\">$ </span>git push origin &lt;source&gt;<span class=\"hljs-symbol\">:&lt;destination&gt;</span><br><span class=\"hljs-comment\"># source 可以是任何 Git 能识别的位置：</span><br><span class=\"hljs-variable\">$ </span>git push origin <span class=\"hljs-title class_\">HEAD</span>^<span class=\"hljs-symbol\">:foo</span><br><br><span class=\"hljs-comment\"># 删除指定的远程仓库的分支</span><br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; <span class=\"hljs-symbol\">:&lt;</span>远程分支名&gt;<br><span class=\"hljs-variable\">$ </span>git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;<br><span class=\"hljs-comment\"># 为推送当前分支并建立与远程上游的跟踪，使用</span><br><span class=\"hljs-variable\">$ </span>git push --set-upstream &lt;远程仓库别名&gt; &lt;远程分支名&gt;<br><span class=\"hljs-variable\">$ </span>git push --set-upstream origin master<br><span class=\"hljs-comment\"># 强行推送本地记录</span><br><span class=\"hljs-variable\">$ </span>git push -u origin +master<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h3><p>显示提交的记录。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">打印所有的提交记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">log</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">打印从第一次提交到指定的提交的记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">log</span> &lt;commit ID&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">打印指定数量的最新提交的记录</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git <span class=\"hljs-built_in\">log</span> -&lt;指定的数量&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>还原提交记录。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"># 重置暂存区，但文件不受影响<br># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件<br># 没有指定 <span class=\"hljs-keyword\">commit</span> ID 则默认为当前 HEAD<br>$ git <span class=\"hljs-keyword\">reset</span> [&lt;文件路径&gt;]<br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--mixed [&lt;文件路径&gt;]</span><br><br># <span class=\"hljs-comment\">--mixed 重置索引，但不重置工作树，更改后的文件标记为未提交（add）的状态。默认操作 （git status 是红色的状态）。</span><br>$ git <span class=\"hljs-keyword\">reset</span> &lt;<span class=\"hljs-keyword\">commit</span> ID&gt;<br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--mixed &lt;commit ID&gt;</span><br><br># <span class=\"hljs-comment\">--soft 回退后a分支修改的代码被保留并标记为add的状态（git status 是绿色的状态）</span><br># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;<br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--soft &lt;commit ID&gt;</span><br><br># <span class=\"hljs-comment\">--hard 重置索引和工作树，并且a分支修改的所有文件和中间的提交，没提交的代码都被丢弃了。</span><br>$ git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-comment\">--hard &lt;commit ID&gt;</span><br><br># <span class=\"hljs-comment\">--merge 和--hard类似，只不过如果在执行reset命令之前你有改动一些文件并且未提交，merge会保留你的这些修改，hard则不会。【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】</span><br># <span class=\"hljs-comment\">--keep 和--hard类似，执行reset之前改动文件如果是a分支修改了的，会提示你修改了相同的文件，不能合并。如果不是a分支修改的文件，会移除缓存区。git status还是可以看到保持了这些修改。</span><br><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-revert\"><a href=\"#git-revert\" class=\"headerlink\" title=\"git revert\"></a>git revert</h3><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 生成一个新的提交来撤销某次提交</span><br><span class=\"hljs-variable\">$ </span>git revert &lt;commit ID&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-tag\"><a href=\"#git-tag\" class=\"headerlink\" title=\"git tag\"></a>git tag</h3><p>分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。<br>你可能会问了：有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？<br>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。<br>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pf\"><span class=\"hljs-comment\"># 我们将这个标签命名为 v1，并且明确地让它指向提交记录 C1，如果你不指定提交记录，Git 会用 HEAD 所指向的位置。</span><br>$ git <span class=\"hljs-keyword\">tag</span> v1 C1<br><br><span class=\"hljs-comment\"># 打印所有的标签</span><br>$ git <span class=\"hljs-keyword\">tag</span><br><br><span class=\"hljs-comment\"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span><br>$ git <span class=\"hljs-keyword\">tag</span> <span class=\"hljs-variable\">&lt;标签名称&gt;</span> [<span class=\"hljs-variable\">&lt;commit ID&gt;</span>]<br><br><span class=\"hljs-comment\"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span><br>$ git <span class=\"hljs-keyword\">tag</span> -a <span class=\"hljs-variable\">&lt;标签名称&gt;</span> -m <span class=\"hljs-variable\">&lt;标签描述信息&gt;</span> [<span class=\"hljs-variable\">&lt;commit ID&gt;</span>]<br><br><span class=\"hljs-comment\"># 切换到指定的标签</span><br>$ git checkout <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 查看标签的信息</span><br>$ git show <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 删除指定的标签</span><br>$ git <span class=\"hljs-keyword\">tag</span> -d <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 将指定的标签提交到远程仓库</span><br>$ git push <span class=\"hljs-variable\">&lt;远程仓库的别名&gt;</span> <span class=\"hljs-variable\">&lt;标签名称&gt;</span><br><br><span class=\"hljs-comment\"># 将本地所有的标签全部提交到远程仓库</span><br>$ git push <span class=\"hljs-variable\">&lt;远程仓库的别名&gt;</span> –tags<br><span class=\"hljs-comment\"># 强push</span><br>$ git push origin <span class=\"hljs-variable\">&lt;远程分支名&gt;</span> --force<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-mv\"><a href=\"#git-mv\" class=\"headerlink\" title=\"git mv\"></a>git mv</h3><p>重命名文件或者文件夹。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-comment\"># 重命名指定的文件或者文件夹</span><br>$ git mv &lt;源文件<span class=\"hljs-regexp\">/文件夹&gt; &lt;目标文件/</span>文件夹&gt;<br></code></pre></td></tr></table></figure>\n<h3 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h3><p>删除文件或者文件夹。</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\"><span class=\"hljs-comment\"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">rm</span> &lt;文件路径&gt;<br><br><span class=\"hljs-comment\"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">-r</span> &lt;文件夹路径&gt;<br><br><span class=\"hljs-comment\"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span><br><span class=\"hljs-variable\">$</span> git <span class=\"hljs-built_in\">rm</span> <span class=\"hljs-literal\">--cached</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h3><p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。<br>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">将当前分支变基到目标分支</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase &lt;远程分支名&gt;</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">将某个分支变基到另一个分支上 (将分支b变基到分支a上)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase &lt;分支名a&gt; &lt;分支名b&gt;</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase a b</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">表示继续下一个冲突(git rebase --<span class=\"hljs-built_in\">continue</span> 就相当于 git commit)</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --<span class=\"hljs-built_in\">continue</span></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">表示跳过当前冲突</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --skip</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">表示退出rebase模式, 回到运行git rebase master命令之前的状态</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --abort</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-describe\"><a href=\"#git-describe\" class=\"headerlink\" title=\"git describe\"></a>git describe</h3><p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来描述离你最近的锚点（也就是标签）</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs reasonml\"># &lt;<span class=\"hljs-built_in\">ref</span>&gt; 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。<br>git describe &lt;<span class=\"hljs-built_in\">ref</span>&gt;<br><br># 它输出的结果是这样的：&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;<br># tag 表示的是离 <span class=\"hljs-built_in\">ref</span> 最近的标签， numCommits 是表示这个 <span class=\"hljs-built_in\">ref</span> 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 <span class=\"hljs-built_in\">ref</span> 所表示的提交记录哈希值的前几位。<br># <span class=\"hljs-constructor\">C0(<span class=\"hljs-params\">v1</span>)</span> -&gt; C1 -&gt; <span class=\"hljs-constructor\">C2(<span class=\"hljs-params\">main</span>)</span><br>git describe main 会输出：v1_2_gC2 <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"git-worktree\"><a href=\"#git-worktree\" class=\"headerlink\" title=\"git worktree\"></a>git worktree</h3><p>仅需维护一个 repo，又可以同时在多个 branch 上工作，互不影响<br>默认情况下， git init 或 git clone 初始化的 repo，只有一个 worktree，叫做 main worktree<br>在某一个目录下使用 Git 命令，当前目录下要么有 .git 文件夹；要么有 .git 文件，如果只有 .git 文件，里面的内容必须是指向 .git 文件夹的</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs inform7\"># 常用worktree 命令<br>$ git worktree add <span class=\"hljs-comment\">[-f]</span> <span class=\"hljs-comment\">[--detach]</span> <span class=\"hljs-comment\">[--checkout]</span> <span class=\"hljs-comment\">[--lock]</span> <span class=\"hljs-comment\">[-b &lt;new-branch&gt;]</span> &lt;path&gt; <span class=\"hljs-comment\">[&lt;commit-ish&gt;]</span><br>$ git worktree list <span class=\"hljs-comment\">[--porcelain]</span><br>$ git worktree remove <span class=\"hljs-comment\">[-f]</span> &lt;worktree&gt;<br>$ git worktree prune <span class=\"hljs-comment\">[-n]</span> <span class=\"hljs-comment\">[-v]</span> <span class=\"hljs-comment\">[--expire &lt;expire&gt;]</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>创建一个worktree<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">git worktree add ..<span class=\"hljs-regexp\">/feature/</span>feature2<br></code></pre></td></tr></table></figure>\n目录结构<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">├── amend-crash-<span class=\"hljs-built_in\">demo</span><br>└── <span class=\"hljs-built_in\">feature</span><br>    └── feature2<br></code></pre></td></tr></table></figure>\ncd ..&#x2F;feature&#x2F;feature2&#x2F; 会发现，这个分支下并不存在 .git 文件夹，却存在一个 .git 文件，打开文件，内容如下：<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">gitdir: <span class=\"hljs-regexp\">/Users/</span>rgyb<span class=\"hljs-regexp\">/Documents/</span>projects<span class=\"hljs-regexp\">/amend-crash-demo/</span>.git<span class=\"hljs-regexp\">/worktrees/</span>feature2<br></code></pre></td></tr></table></figure></li>\n<li>git worktree remove<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\"># 删除一个worktree 参数是文件路径 注意路径前不加 <span class=\"hljs-string\">&quot;/&quot;</span><br>git worktree <span class=\"hljs-built_in\">remove</span> <span class=\"hljs-built_in\">feature</span>/feature2<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\"><span class=\"hljs-comment\"># 假设你创建一个 worktree，并在里面有改动，突然间这个worktree 又不需要了，此刻你按照上述命令是不能删掉了，此时就需要 -f 参数来帮忙了</span><br>git worktree <span class=\"hljs-built_in\">remove</span> -f feature/feature2<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nginx\"><span class=\"hljs-comment\"># 删除了 worktree，其实在 Git 的文件中，还有很多 administrative 文件是没有用的，为了保持清洁，我们还需要进一步清理</span><br><span class=\"hljs-comment\"># 这个命令就是清洁的兜底操作，可以让我们的工作始终保持整洁</span><br><span class=\"hljs-attribute\">git</span> worktree prune<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Git操作场景-🌰\"><a href=\"#Git操作场景-🌰\" class=\"headerlink\" title=\"Git操作场景(🌰)\"></a>Git操作场景(🌰)</h2><h3 id=\"删除掉本地不存在的远程分支\"><a href=\"#删除掉本地不存在的远程分支\" class=\"headerlink\" title=\"删除掉本地不存在的远程分支\"></a>删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 git branch –all 依然会显示该远程分支，可使用下列的命令进行删除</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 使用 pull 命令，添加 -p 参数</span><br><span class=\"hljs-variable\">$ </span>git pull -p<br><br><span class=\"hljs-comment\"># 等同于下面的命令</span><br><span class=\"hljs-variable\">$ </span>git fetch -p<br><span class=\"hljs-variable\">$ </span>git fetch --prune origin<br></code></pre></td></tr></table></figure>\n<h3 id=\"只提交某次记录\"><a href=\"#只提交某次记录\" class=\"headerlink\" title=\"只提交某次记录\"></a>只提交某次记录</h3><p>发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。<br>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！<br>最后就差把 bugFix 分支里的工作合并回 main 分支了。你可以选择通过 fast-forward 快速合并到 main 分支上，但这样的话 main 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式</p>\n<figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs crystal\"><span class=\"hljs-comment\"># 实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</span><br><span class=\"hljs-variable\">$ </span>git rebase -i<br><span class=\"hljs-variable\">$ </span>git cherry-pick <br></code></pre></td></tr></table></figure>\n<h3 id=\"本地分支合并远端分支\"><a href=\"#本地分支合并远端分支\" class=\"headerlink\" title=\"本地分支合并远端分支\"></a>本地分支合并远端分支</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git cherry-pick o/main</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase o/main</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git merge o/main</span><br>...<br></code></pre></td></tr></table></figure>\n<h3 id=\"远程分支代码比本地分支代码新的情况进行提交\"><a href=\"#远程分支代码比本地分支代码新的情况进行提交\" class=\"headerlink\" title=\"远程分支代码比本地分支代码新的情况进行提交\"></a>远程分支代码比本地分支代码新的情况进行提交</h3><p>假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。</p>\n<p>这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，亦或由于你的提交已经过时而直接忽略你的提交？<br>因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式1: rebase</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git fetch; git rebase orgin/main; git push</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式2: merge</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">git merge 不会移动你的工作（它会创建新的合并提交），但是它会告诉 Git 你已经合并了远程仓库的所有变更。这是因为远程分支现在是你本地分支的祖先，也就是说你的提交已经包含了远程分支的所有变化。</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git fetch; git merge orgin/main; git push</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">方式3: pull / pull --rebase</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">要敲那么多命令，有没有更简单一点的？前面已经介绍过 git pull 就是 fetch 和 merge 的简写，类似的 git pull --rebase 就是 fetch 和 rebase 的简写！</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git pull --rebase; git push</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git pull; git push</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"远程跟踪\"><a href=\"#远程跟踪\" class=\"headerlink\" title=\"远程跟踪\"></a>远程跟踪</h3><p>自定义远程跟踪分支：你可以让任意分支跟踪 o&#x2F;main, 然后该分支会像 main 分支一样得到隐含的 push 目的地以及 merge 的目标。 这意味着你可以在分支 totallyNotMain 上执行 git push，将工作推送到远程仓库的 main 分支上。<br><strong>需要注意的是 main 并未被更新</strong><br>有两种方法设置这个属性，第一种就是通过远程分支检出一个新的分支，执行:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">1: git checkout -b</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git checkout -b totallyNotMain o/main</span><br>就可以创建一个名为 totallyNotMain 的分支，它跟踪远程分支 o/main。<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">2: git branch -u</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -u o/main foo</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">这样 foo 就会跟踪 o/main 了。如果当前就在 foo 分支上, 还可以省略 foo：</span><br><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git branch -u o/main</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"代码分支迁移到不同仓库\"><a href=\"#代码分支迁移到不同仓库\" class=\"headerlink\" title=\"代码分支迁移到不同仓库\"></a>代码分支迁移到不同仓库</h3><p>当我们需要将分支origin(A)&#x2F;a 迁移到 origin(B)&#x2F;a 并保留分支记录</p>\n<figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\">切换到当前<span class=\"hljs-string\">origin</span>(<span class=\"hljs-string\">A</span>) 更换当前仓库为目标仓库<br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> <span class=\"hljs-string\">origin</span> <span class=\"hljs-string\">https</span>://<span class=\"hljs-string\">gitlab</span>.<span class=\"hljs-string\">southinfo</span>.<span class=\"hljs-string\">net</span>/<span class=\"hljs-string\">ecrp-sg-web</span>.<span class=\"hljs-string\">git</span><br>推送当前分支到更换后的目标仓库(需要密码/<span class=\"hljs-string\">ssh</span>认证)<br>$ <span class=\"hljs-string\">git</span> <span class=\"hljs-string\">push</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"代码回滚-reset-x2F-revert\"><a href=\"#代码回滚-reset-x2F-revert\" class=\"headerlink\" title=\"代码回滚(reset&#x2F;revert)\"></a>代码回滚(reset&#x2F;revert)</h3><ul>\n<li>结论</li>\n</ul>\n<ol>\n<li>git revert 后会多出一条commit，这里可进行回撤操作</li>\n<li>git reset 直接把之前 commit 删掉，非 git reset –hard 的操作是不会删掉修改代码，如果远程已经有之前代码，需要强推 git push -f</li>\n</ol>\n<ul>\n<li>应用场景</li>\n</ul>\n<ol>\n<li>如果回退分支的代码以后还需要的话用git revert就再好不过了；</li>\n<li>如果分支我就是提错了没用了还不想让别人发现我错的代码，那就git reset吧</li>\n</ol>\n<ul>\n<li><p>git reset<br>develop将a分支合并后，想要不留痕迹的撤回合并。这个时候用git reset就是很好的选择了</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">develop <span class=\"hljs-comment\">----1      3-----</span><br>             \\   /<br>branch <span class=\"hljs-keyword\">a</span>       <span class=\"hljs-keyword\">a</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>操作步骤</p>\n</li>\n</ul>\n<ol>\n<li>切换分支到develop</li>\n<li>git log 查看当前分支日志</li>\n<li>我要将develop回退到合并之前的状态，那就是退到 commit 1这了，将commit号复制下来。退出编辑界面。<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pgsql\"><span class=\"hljs-number\">3.1</span> a分支的代码我不需要了，以后应该也不需要了<br>  git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-number\">1</span>（粘贴过来的<span class=\"hljs-keyword\">commit</span>号） <span class=\"hljs-comment\">--hard</span><br><span class=\"hljs-number\">3.2</span> a分支的代码我还需要<br>  git <span class=\"hljs-keyword\">reset</span> <span class=\"hljs-number\">1</span>（粘贴过来的<span class=\"hljs-keyword\">commit</span>号）<br></code></pre></td></tr></table></figure></li>\n<li>将回退后的代码推送到远端 git push origin develop<figure class=\"highlight subunit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs subunit\">![rejected] develop -&gt; develop (non-fast-forward)<br><span class=\"hljs-keyword\">error: </span>无法推送一些引用到 &#x27;git@github.cn:...&#x27;<br>提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。<br>。。。<br></code></pre></td></tr></table></figure>\n因为本地分支的代码落后于远端develop分支, 所以这一步需要强行推送 <em>–force</em></li>\n<li>强推<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> develop --force<br></code></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li><p>git revert<br>还是之前的需求，不想要合并a，只想要没合并a时的样子。</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">develop <span class=\"hljs-comment\">----1      3-----</span><br>             \\   /<br>branch <span class=\"hljs-keyword\">a</span>       <span class=\"hljs-keyword\">a</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>操作步骤</p>\n</li>\n</ul>\n<ol>\n<li>切换分支到develop  git checkout develop</li>\n<li>git log 查看当前分支日志</li>\n<li>这次和git reset 不同的是我不能复制 commit 1这个commit号了，我需要复制的是commit 2的commit号。因为revert后面跟的是具体需要哪个已经合并了的分支，而并不是需要会退到哪的commit号。<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">git</span> revert <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure></li>\n<li>push到远端服务器<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> develop<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"解决合并代码-Already-up-to-date-问题\"><a href=\"#解决合并代码-Already-up-to-date-问题\" class=\"headerlink\" title=\"解决合并代码 (Already up-to-date) 问题\"></a>解决合并代码 (Already up-to-date) 问题</h3><ul>\n<li>有时我们合并代码会遇到冲突解决的问题, 这个时候如果想取消本次合并如果直接丢弃全部文件会照成远端代码还是保存了本次解决冲突的提交, 当我们重新再合并有冲突的代码就会显示Already up-to-date</li>\n<li>接上个例子, 现在的需求是我之前已经把a分支revert了，但是我现在又需要a分支的代码了，我之前都写过一遍总不能再重新写一遍了。我首先想到的方法，把a分支再merge到develop不就好了。<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">git <span class=\"hljs-built_in\">merge</span> <span class=\"hljs-keyword\">a</span><br></code></pre></td></tr></table></figure>\n结果<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">Already up-<span class=\"hljs-keyword\">to</span>-<span class=\"hljs-built_in\">date</span><br></code></pre></td></tr></table></figure>\n因为我们之前提交合并的a分支的代码还在，因此我们并不能在重新合并a分支。</li>\n</ul>\n<p>解决方法: 使用revert之前revert的commit号。在上面的例子中就是git revert 4。于是又新增了一个commit，把之前revert的代码又重新revert回来了, 再继续执行合并操作代码冲突又会提示出来了</p>\n"},{"title":"JS的四种异步解决方案","date":"2022-10-10T12:43:19.000Z","_content":"\n### 同步&异步的概念\n\n在讲这四种异步方案之前，我们先来明确一下同步和异步的概念：\n\n所谓**同步(synchronization)**，简单来说，就是**顺序执行**，指的是同一时间只能做一件事情，只有目前正在执行的事情做完之后，才能做下一件事情。 比如咱们去火车站买票，假设窗口只有1个，那么同一时间只能处理1个人的购票业务，其余的需要进行排队。这种one by one的动作就是同步。 **同步操作的优点**在于做任何事情都是依次执行，井然有序，不会存在大家同时抢一个资源的问题。 **同步操作的缺点**在于**会阻塞后续代码的执行**。如果当前执行的任务需要花费很长的时间，那么后面的程序就只能一直等待。从而影响效率，对应到前端页面的展示来说，有可能会造成页面渲染的阻塞，大大影响用户体验。\n\n所谓**异步(Asynchronization)**，指的是当前代码的执行不影响后面代码的执行。当程序运行到异步的代码时，会将该异步的代码作为任务放进任务队列，而不是推入主线程的调用栈。等主线程执行完之后，再去任务队列里执行对应的任务即可。 因此，**异步操作的优点就是**：**不会阻塞后续代码的执行**。\n\n### js中异步的应用场景\n\n开篇讲了同步和异步的概念，那么在JS中异步的应用场景有哪些呢？\n\n- 定时任务：setTimeout、setInterval\n- 网络请求：ajax请求、动态创建img标签的加载\n- 事件监听器：addEventListener\n\n### 实现异步的四种方法\n\n对于setTimeout、setInterval、addEventListener这种异步场景，不需要我们手动实现异步，直接调用即可。 但是对于ajax请求、node.js中操作数据库这种异步，就需要我们自己来实现了~\n\n#### 1、 回调函数\n\n在微任务队列出现之前，JS实现异步的主要方式就是通过回调函数。 以一个简易版的Ajax请求为例，代码结构如下所示：\n\n```javascript\nfunction ajax(obj){\n\tlet default = {\n\t  url: '...',\n\t  type:'GET',\n\t  async:true,\n\t  contentType: 'application/json',\n\t  success:function(){}\n    };\n\n\tfor (let key in obj) {\n        defaultParam[key] = obj[key];\n    }\n\n    let xhr;\n    if (window.XMLHttpRequest) {\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    }\n    \n    xhr.open(defaultParam.type, defaultParam.url+'?'+dataStr, defaultParam.async);\n    xhr.send();\n    xhr.onreadystatechange = function (){\n        if (xhr.readyState === 4){\n            if(xhr.status === 200){\n                let result = JSON.parse(xhr.responseText);\n                // 在此处调用回调函数\n                defaultParam.success(result);\n            }\n        }\n    }\n}\n\n```\n\n我们在业务代码里可以这样调用ajax请求：\n\n```javascript\najax({\n   url:'#',\n   type:GET,\n   success:function(e){\n    // 回调函数里就是对请求结果的处理\n   }\n});\n```\n\najax的success方法就是一个回调函数，回调函数中执行的是我们请求成功之后要做的进一步操作。 这样就初步实现了异步，但是回调函数有一个非常严重的缺点，那就是**回调地狱**的问题。 大家可以试想一下，如果我们在回调函数里再发起一个ajax请求呢？那岂不是要在success函数里继续写一个ajax请求？那如果需要多级嵌套发起ajax请求呢？岂不是需要多级嵌套？如果嵌套的层级很深的话，我们的代码结构可能就会变成这样： ![回调地狱示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e467d65234bf4de995ab7efa6bd0fd86~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 因此，为了解决回调地狱的问题，提出了Promise、async/await、generator的概念。\n\n#### 2、Promise\n\nPromise作为典型的微任务之一，它的出现可以使JS达到异步执行的效果。 一个Promise函数的结构如下列代码如下：\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n\tresolve('a');\n});\npromise\n    .then((arg) => { console.log(`执行resolve,参数是${arg}`) })\n    .catch((arg) => { console.log(`执行reject,参数是${arg}`) })\n    .finally(() => { console.log('结束promise') });\n```\n\n如果，我们需要嵌套执行异步代码，相比于回调函数来说，Promise的执行方式如下列代码所示：\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n\tresolve(1);\n});\npromise.then((value) => {\n    \tconsole.log(value);\n    \treturn value * 2;\n    }).then((value) => {\n    \tconsole.log(value);\n    \treturn value * 2;\n    }).then((value) => {\n\t  \tconsole.log(value);\n    }).catch((err) => {\n\t\tconsole.log(err);\n    });\n```\n\n即，通过then来实现多级嵌套(**链式调用**)，这看起来是不是就比回调函数舒服多了~\n\n每个Promise都会经历的生命周期是：\n\n- 进行中（pending） - 此时代码执行尚未结束，所以也叫未处理的（unsettled）\n- 已处理（settled）   - 异步代码已执行结束 已处理的代码会进入两种状态中的一种：\n  - 已完成（fulfilled） - 表明异步代码执行成功，由resolve()触发\n  - 已拒绝（rejected）- 遇到错误，异步代码执行失败 ，由reject()触发\n\n因此，pending，fulfilled, rejected就是Promise中的三种状态啦~ 大家一定要牢记，在Promise中，要么包含resolve()来表示Promise的状态为fulfilled,要么包含reject()来表示Promise的状态为rejected。 不然我们的Promise就会一直处于pending的状态，直至程序崩溃...\n\n除此之外，Promise不仅很好的解决了链式调用的问题，它还有很多神奇的操作呢：\n\n- **Promise.all(promises)**：接收一个包含多个Promise对象的数组，等待所有都完成时，返回存放它们结果的数组。如果任一被拒绝，则立即抛出错误，其他已完成的结果会被忽略\n- **Promise.allSettled(promises)**: 接收一个包含多个Promise对象的数组，等待所有都已完成或者已拒绝时，返回存放它们结果对象的数组。每个结果对象的结构为{status:'fulfilled' // 或 'rejected', value // 或reason}\n- **Promise.race(promises)**: 接收一个包含多个Promise对象的数组，等待第一个有结果（完成/拒绝）的Promise，并把其result/error作为结果返回\n\n```javascript\nfunction getPromises(){\n    return [\n        new Promise(((resolve, reject) => setTimeout(() => resolve(1), 1000))),\n        new Promise(((resolve, reject) => setTimeout(() => reject(new Error('2')), 2000))),\n        new Promise(((resolve, reject) => setTimeout(() => resolve(3), 3000))),\n    ];\n}\n\nPromise.all(getPromises()).then(console.log);\nPromise.allSettled(getPromises()).then(console.log);\nPromise.race(getPromises()).then(console.log);\n```\n\n打印结果如下：\n ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deb4f7993f4f4280b388b861f6eb9c2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60e6b6e792de4b218071b160e78198df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c85c530253b44cdb65dbea0114fcf5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\n\n#### 3、Generator\n\nGenerator是ES6提出的一种异步编程的方案。因为手动创建一个iterator十分麻烦，因此ES6推出了generator，用于更方便的创建iterator。也就是说，Generator就是一个返回值为iterator对象的函数。\n 在讲Generator之前，我们先来看看iterator是什么：\n **iterator是什么？**\n **iterator中文名叫迭代器。它为js中各种不同的数据结构(Object、Array、Set、Map)提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。** 因此iterator也是一种对象，不过相比于普通对象来说，它有着专为迭代而设计的接口。\n\n**iterator 的作用：**\n\n- 为各种数据结构，提供一个统一的、简便的访问接口；\n- 使得数据结构的成员能够按某种次序排列；\n- ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费\n\n**iterator的结构：** 它有**next**方法，该方法返回一个包含**value**和**done**两个属性的对象（我们假设叫result）。**value**是迭代的值，后者是表明迭代是否完成的标志。true表示迭代完成，false表示没有。iterator内部有指向迭代位置的指针，每次调用**next**，自动移动指针并返回相应的result。\n\n原生具备iterator接口的数据结构如下：\n\n- Array\n- Map\n- Set\n- String\n- TypedArray\n- 函数里的arguments对象\n- NodeList对象 这些数据结构都有一个Symbol.iterator属性，可以直接通过这个属性来直接创建一个迭代器。 也就是说，Symbol.iterator属性只是一个用来创建迭代器的接口，而不是一个迭代器，因为它不含遍历的部分。\n   使用Symbol.iterator接口生成iterator迭代器来遍历数组的过程为：\n\n```javascript\nlet arr = ['a','b','c'];\n\nlet iter = arr[Symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n```\n\n**for ... of的循环内部实现机制其实就是iterator，它首先调用被遍历集合对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象是可以拥有.next()方法的任何对象，然后，在 for ... of 的每次循环中，都将调用该迭代器对象上的 .next 方法。然后使用for i of打印出来的i也就是调用.next方法后得到的对象上的value属性。**\n\n对于原生不具备iterator接口的数据结构，比如Object，我们可以采用自定义的方式来创建一个遍历器。\n\n比如，我们可以自定义一个iterator来遍历对象：\n\n```javascript\nlet obj = {a: \"hello\", b: \"world\"};\n// 自定义迭代器\nfunction createIterator(items) {\n    let keyArr = Object.keys(items);\n    let i = 0;\n    return {\n        next: function () {\n            let done = (i >= keyArr.length);\n            let value = !done ? items[keyArr[i++]] : undefined;\n            return {\n                value: value,\n                done: done,\n            };\n        }\n    };\n}\n\nlet iterator = createIterator(obj);\nconsole.log(iterator.next()); // \"{ value: 'hello', done: false }\"\nconsole.log(iterator.next());  // \"{ value: 'world', done: false }\"\nconsole.log(iterator.next());  // \"{ value: undefined, done: true }\"\n```\n\n**接下来，我们来聊聊Generator:**\n 我们通过一个例子来看看Gnerator的特征：\n\n```javascript\nfunction* createIterator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n// generators可以像正常函数一样被调用，不同的是会返回一个 iterator\nlet iterator = createIterator();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\n```\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案。形式上，Generator 函数是一个普通函数，但是有两个特征:\n\n- function关键字与函数名之间有一个星号\n- 函数体内部使用yield语句，定义不同的内部状态\n\nGenerator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（**Iterator Object**）\n\n打印看看Generator函数返回值的内容： ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5d88ad317c4ede817c1b56ffb10a40~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 发现generator函数的返回值的原型链上确实有iterator对象该有的next，**这充分说明了generator的返回值是一个iterator**。除此之外还有函数该有的return方法和throw方法。\n\n在普通函数中，我们想要一个函数最终的执行结果，一般都是return出来，或者以return作为结束函数的标准。运行函数时也不能被打断，期间也不能从外部再传入值到函数体内。 但在generator中，就打破了这几点，所以generator和普通的函数完全不同。 当以function*的方式声明了一个Generator生成器时，内部是可以有许多状态的，以yield进行断点间隔。期间我们执行调用这个生成的Generator,他会返回一个遍历器对象，用这个对象上的方法，实现获得一个yield后面输出的结果。\n\n```javascript\nfunction* generator() {\n    yield 1\n    yield 2\n};\nlet iterator = generator();\niterator.next()  // {value: 1, done: false}\niterator.next()  // {value: 2, done: false}\niterator.next()  // {value: undefined, done: true}\n```\n\n**yield和return的区别：**\n\n- 都能返回紧跟在语句后面的那个表达式的值\n- yield相比于return来说，更像是一个断点。遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。\n- 一个函数里面，只能执行一个return语句，但是可以执行多次yield表达式。\n- 正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield\n\n语法注意点：\n\n- yield表达式只能用在 Generator 函数里面\n- yield表达式如果用在另一个表达式之中，必须放在圆括号里面\n- yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\n- 如果 return 语句后面还有 yield 表达式，那么后面的 yield 完全不生效\n\n**使用Generator的其余注意事项：**\n\n- 需要注意的是，yield 不能跨函数。并且yield需要和*配套使用，别处使用无效\n\n```javascript\nfunction* createIterator(items) {\n  items.forEach(function (item) {\n    // 语法错误\n    yield item + 1;\n  });\n}\n```\n\n- 箭头函数不能用做 generator\n\n**讲了这么多，那么Generator到底有什么用呢？**\n\n- 因为Generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。\n- Generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个在ajax请求中很有用，避免了回调地狱.\n\n#### 4、 async/await\n\n最后我们来讲讲async/await,终于讲到这儿了！！！\n async/await是ES7提出的关于异步的终极解决方案。我看网上关于async/await是谁的语法糖这块有两个版本：\n\n- 第一个版本说async/await是Generator的语法糖\n- 第二个版本说async/await是Promise的语法糖\n\n其实，这两种说法都没有错。\n **关于async/await是Generator的语法糖：** 所谓Generator语法糖，表明的就是aysnc/await实现的就是generator实现的功能。但是async/await比generator要好用。因为generator执行yield设下的断点采用的方式就是不断的调用iterator方法，这是个手动调用的过程。针对generator的这个缺点，后面提出了co这个库函数来自动执行next，相比于之前的方案，这种方式确实有了进步，但是仍然麻烦。而async配合await得到的就是断点执行后的结果。因此async/await比generator使用更普遍。\n\n**总结下来，async函数对 Generator函数的改进，主要体现在以下三点:**\n\n- 内置执行器：Generator函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co函数库。但是，async函数和正常的函数一样执行，也不用 co函数库，也不用使用 next方法，而 async函数自带执行器，会自动执行。\n- 适用性更好：co函数库有条件约束，yield命令后面只能是 Thunk函数或 Promise对象，但是 async函数的 await关键词后面，可以不受约束。\n- 可读性更好：async和 await，比起使用 *号和 yield，语义更清晰明了。\n\n**关于async/await是Promise的语法糖：** 如果不使用async/await的话，Promise就需要通过链式调用来依次执行then之后的代码：\n\n```javascript\nfunction counter(n){\n\treturn new Promise((resolve, reject) => { \n\t   resolve(n + 1);\n    });\n}\n\nfunction adder(a, b){\n    return new Promise((resolve, reject) => { \n\t   resolve(a + b);\n    });\n}\n\nfunction delay(a){\n    return new Promise((resolve, reject) => { \n\t   setTimeout(() => resolve(a), 1000);\n    });\n}\n// 链式调用写法\nfunction callAll(){\n    counter(1)\n       .then((val) => adder(val, 3))\n       .then((val) => delay(val))\n       .then(console.log);\n}\ncallAll();//5\n```\n\n虽然相比于回调地狱来说，链式调用确实顺眼多了。但是其呈现仍然略繁琐了一些。 而**async/await的出现，就使得我们可以通过同步代码来达到异步的效果**：\n\n```javascript\nasync function callAll(){\n   const count = await counter(1);\n   const sum = await adder(count, 3);\n   console.log(await delay(sum));\n}\ncallAll();// 5\n```\n\n由此可见，Promise搭配async/await的使用才是正解！\n\n**总结**\n\n- promise让异步执行看起来更清晰明了，通过then让异步执行结果分离出来。\n- async/await其实是基于Promise的。async函数其实是把promise包装了一下。使用async函数可以让代码简洁很多，不需要promise一样需要些then，不需要写匿名函数处理promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。\n- async函数是Generator函数的语法糖。async函数的返回值是 promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。同时，我们还可以用await来替代then方法指定下一步的操作。\n- 感觉Promise+async的操作最为常见。因为Generator的常用功能可以直接由async来体现呀~\n\n\n\n作者：DoubleSweet0824\n链接：https://juejin.cn/post/7082753409060716574","source":"_posts/jsAsync.md","raw":"---\ntitle: JS的四种异步解决方案\ndate: 2022-10-10 20:43:19\ntags: JS\n---\n\n### 同步&异步的概念\n\n在讲这四种异步方案之前，我们先来明确一下同步和异步的概念：\n\n所谓**同步(synchronization)**，简单来说，就是**顺序执行**，指的是同一时间只能做一件事情，只有目前正在执行的事情做完之后，才能做下一件事情。 比如咱们去火车站买票，假设窗口只有1个，那么同一时间只能处理1个人的购票业务，其余的需要进行排队。这种one by one的动作就是同步。 **同步操作的优点**在于做任何事情都是依次执行，井然有序，不会存在大家同时抢一个资源的问题。 **同步操作的缺点**在于**会阻塞后续代码的执行**。如果当前执行的任务需要花费很长的时间，那么后面的程序就只能一直等待。从而影响效率，对应到前端页面的展示来说，有可能会造成页面渲染的阻塞，大大影响用户体验。\n\n所谓**异步(Asynchronization)**，指的是当前代码的执行不影响后面代码的执行。当程序运行到异步的代码时，会将该异步的代码作为任务放进任务队列，而不是推入主线程的调用栈。等主线程执行完之后，再去任务队列里执行对应的任务即可。 因此，**异步操作的优点就是**：**不会阻塞后续代码的执行**。\n\n### js中异步的应用场景\n\n开篇讲了同步和异步的概念，那么在JS中异步的应用场景有哪些呢？\n\n- 定时任务：setTimeout、setInterval\n- 网络请求：ajax请求、动态创建img标签的加载\n- 事件监听器：addEventListener\n\n### 实现异步的四种方法\n\n对于setTimeout、setInterval、addEventListener这种异步场景，不需要我们手动实现异步，直接调用即可。 但是对于ajax请求、node.js中操作数据库这种异步，就需要我们自己来实现了~\n\n#### 1、 回调函数\n\n在微任务队列出现之前，JS实现异步的主要方式就是通过回调函数。 以一个简易版的Ajax请求为例，代码结构如下所示：\n\n```javascript\nfunction ajax(obj){\n\tlet default = {\n\t  url: '...',\n\t  type:'GET',\n\t  async:true,\n\t  contentType: 'application/json',\n\t  success:function(){}\n    };\n\n\tfor (let key in obj) {\n        defaultParam[key] = obj[key];\n    }\n\n    let xhr;\n    if (window.XMLHttpRequest) {\n        xhr = new XMLHttpRequest();\n    } else {\n        xhr = new ActiveXObject('Microsoft.XMLHTTP');\n    }\n    \n    xhr.open(defaultParam.type, defaultParam.url+'?'+dataStr, defaultParam.async);\n    xhr.send();\n    xhr.onreadystatechange = function (){\n        if (xhr.readyState === 4){\n            if(xhr.status === 200){\n                let result = JSON.parse(xhr.responseText);\n                // 在此处调用回调函数\n                defaultParam.success(result);\n            }\n        }\n    }\n}\n\n```\n\n我们在业务代码里可以这样调用ajax请求：\n\n```javascript\najax({\n   url:'#',\n   type:GET,\n   success:function(e){\n    // 回调函数里就是对请求结果的处理\n   }\n});\n```\n\najax的success方法就是一个回调函数，回调函数中执行的是我们请求成功之后要做的进一步操作。 这样就初步实现了异步，但是回调函数有一个非常严重的缺点，那就是**回调地狱**的问题。 大家可以试想一下，如果我们在回调函数里再发起一个ajax请求呢？那岂不是要在success函数里继续写一个ajax请求？那如果需要多级嵌套发起ajax请求呢？岂不是需要多级嵌套？如果嵌套的层级很深的话，我们的代码结构可能就会变成这样： ![回调地狱示意图](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e467d65234bf4de995ab7efa6bd0fd86~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 因此，为了解决回调地狱的问题，提出了Promise、async/await、generator的概念。\n\n#### 2、Promise\n\nPromise作为典型的微任务之一，它的出现可以使JS达到异步执行的效果。 一个Promise函数的结构如下列代码如下：\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n\tresolve('a');\n});\npromise\n    .then((arg) => { console.log(`执行resolve,参数是${arg}`) })\n    .catch((arg) => { console.log(`执行reject,参数是${arg}`) })\n    .finally(() => { console.log('结束promise') });\n```\n\n如果，我们需要嵌套执行异步代码，相比于回调函数来说，Promise的执行方式如下列代码所示：\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n\tresolve(1);\n});\npromise.then((value) => {\n    \tconsole.log(value);\n    \treturn value * 2;\n    }).then((value) => {\n    \tconsole.log(value);\n    \treturn value * 2;\n    }).then((value) => {\n\t  \tconsole.log(value);\n    }).catch((err) => {\n\t\tconsole.log(err);\n    });\n```\n\n即，通过then来实现多级嵌套(**链式调用**)，这看起来是不是就比回调函数舒服多了~\n\n每个Promise都会经历的生命周期是：\n\n- 进行中（pending） - 此时代码执行尚未结束，所以也叫未处理的（unsettled）\n- 已处理（settled）   - 异步代码已执行结束 已处理的代码会进入两种状态中的一种：\n  - 已完成（fulfilled） - 表明异步代码执行成功，由resolve()触发\n  - 已拒绝（rejected）- 遇到错误，异步代码执行失败 ，由reject()触发\n\n因此，pending，fulfilled, rejected就是Promise中的三种状态啦~ 大家一定要牢记，在Promise中，要么包含resolve()来表示Promise的状态为fulfilled,要么包含reject()来表示Promise的状态为rejected。 不然我们的Promise就会一直处于pending的状态，直至程序崩溃...\n\n除此之外，Promise不仅很好的解决了链式调用的问题，它还有很多神奇的操作呢：\n\n- **Promise.all(promises)**：接收一个包含多个Promise对象的数组，等待所有都完成时，返回存放它们结果的数组。如果任一被拒绝，则立即抛出错误，其他已完成的结果会被忽略\n- **Promise.allSettled(promises)**: 接收一个包含多个Promise对象的数组，等待所有都已完成或者已拒绝时，返回存放它们结果对象的数组。每个结果对象的结构为{status:'fulfilled' // 或 'rejected', value // 或reason}\n- **Promise.race(promises)**: 接收一个包含多个Promise对象的数组，等待第一个有结果（完成/拒绝）的Promise，并把其result/error作为结果返回\n\n```javascript\nfunction getPromises(){\n    return [\n        new Promise(((resolve, reject) => setTimeout(() => resolve(1), 1000))),\n        new Promise(((resolve, reject) => setTimeout(() => reject(new Error('2')), 2000))),\n        new Promise(((resolve, reject) => setTimeout(() => resolve(3), 3000))),\n    ];\n}\n\nPromise.all(getPromises()).then(console.log);\nPromise.allSettled(getPromises()).then(console.log);\nPromise.race(getPromises()).then(console.log);\n```\n\n打印结果如下：\n ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deb4f7993f4f4280b388b861f6eb9c2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60e6b6e792de4b218071b160e78198df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c85c530253b44cdb65dbea0114fcf5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)\n\n#### 3、Generator\n\nGenerator是ES6提出的一种异步编程的方案。因为手动创建一个iterator十分麻烦，因此ES6推出了generator，用于更方便的创建iterator。也就是说，Generator就是一个返回值为iterator对象的函数。\n 在讲Generator之前，我们先来看看iterator是什么：\n **iterator是什么？**\n **iterator中文名叫迭代器。它为js中各种不同的数据结构(Object、Array、Set、Map)提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。** 因此iterator也是一种对象，不过相比于普通对象来说，它有着专为迭代而设计的接口。\n\n**iterator 的作用：**\n\n- 为各种数据结构，提供一个统一的、简便的访问接口；\n- 使得数据结构的成员能够按某种次序排列；\n- ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费\n\n**iterator的结构：** 它有**next**方法，该方法返回一个包含**value**和**done**两个属性的对象（我们假设叫result）。**value**是迭代的值，后者是表明迭代是否完成的标志。true表示迭代完成，false表示没有。iterator内部有指向迭代位置的指针，每次调用**next**，自动移动指针并返回相应的result。\n\n原生具备iterator接口的数据结构如下：\n\n- Array\n- Map\n- Set\n- String\n- TypedArray\n- 函数里的arguments对象\n- NodeList对象 这些数据结构都有一个Symbol.iterator属性，可以直接通过这个属性来直接创建一个迭代器。 也就是说，Symbol.iterator属性只是一个用来创建迭代器的接口，而不是一个迭代器，因为它不含遍历的部分。\n   使用Symbol.iterator接口生成iterator迭代器来遍历数组的过程为：\n\n```javascript\nlet arr = ['a','b','c'];\n\nlet iter = arr[Symbol.iterator]();\n\niter.next() // { value: 'a', done: false }\niter.next() // { value: 'b', done: false }\niter.next() // { value: 'c', done: false }\niter.next() // { value: undefined, done: true }\n```\n\n**for ... of的循环内部实现机制其实就是iterator，它首先调用被遍历集合对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象是可以拥有.next()方法的任何对象，然后，在 for ... of 的每次循环中，都将调用该迭代器对象上的 .next 方法。然后使用for i of打印出来的i也就是调用.next方法后得到的对象上的value属性。**\n\n对于原生不具备iterator接口的数据结构，比如Object，我们可以采用自定义的方式来创建一个遍历器。\n\n比如，我们可以自定义一个iterator来遍历对象：\n\n```javascript\nlet obj = {a: \"hello\", b: \"world\"};\n// 自定义迭代器\nfunction createIterator(items) {\n    let keyArr = Object.keys(items);\n    let i = 0;\n    return {\n        next: function () {\n            let done = (i >= keyArr.length);\n            let value = !done ? items[keyArr[i++]] : undefined;\n            return {\n                value: value,\n                done: done,\n            };\n        }\n    };\n}\n\nlet iterator = createIterator(obj);\nconsole.log(iterator.next()); // \"{ value: 'hello', done: false }\"\nconsole.log(iterator.next());  // \"{ value: 'world', done: false }\"\nconsole.log(iterator.next());  // \"{ value: undefined, done: true }\"\n```\n\n**接下来，我们来聊聊Generator:**\n 我们通过一个例子来看看Gnerator的特征：\n\n```javascript\nfunction* createIterator() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n// generators可以像正常函数一样被调用，不同的是会返回一个 iterator\nlet iterator = createIterator();\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\nconsole.log(iterator.next().value); // 3\n```\n\nGenerator 函数是 ES6 提供的一种异步编程解决方案。形式上，Generator 函数是一个普通函数，但是有两个特征:\n\n- function关键字与函数名之间有一个星号\n- 函数体内部使用yield语句，定义不同的内部状态\n\nGenerator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（**Iterator Object**）\n\n打印看看Generator函数返回值的内容： ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5d88ad317c4ede817c1b56ffb10a40~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp) 发现generator函数的返回值的原型链上确实有iterator对象该有的next，**这充分说明了generator的返回值是一个iterator**。除此之外还有函数该有的return方法和throw方法。\n\n在普通函数中，我们想要一个函数最终的执行结果，一般都是return出来，或者以return作为结束函数的标准。运行函数时也不能被打断，期间也不能从外部再传入值到函数体内。 但在generator中，就打破了这几点，所以generator和普通的函数完全不同。 当以function*的方式声明了一个Generator生成器时，内部是可以有许多状态的，以yield进行断点间隔。期间我们执行调用这个生成的Generator,他会返回一个遍历器对象，用这个对象上的方法，实现获得一个yield后面输出的结果。\n\n```javascript\nfunction* generator() {\n    yield 1\n    yield 2\n};\nlet iterator = generator();\niterator.next()  // {value: 1, done: false}\niterator.next()  // {value: 2, done: false}\niterator.next()  // {value: undefined, done: true}\n```\n\n**yield和return的区别：**\n\n- 都能返回紧跟在语句后面的那个表达式的值\n- yield相比于return来说，更像是一个断点。遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。\n- 一个函数里面，只能执行一个return语句，但是可以执行多次yield表达式。\n- 正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield\n\n语法注意点：\n\n- yield表达式只能用在 Generator 函数里面\n- yield表达式如果用在另一个表达式之中，必须放在圆括号里面\n- yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。\n- 如果 return 语句后面还有 yield 表达式，那么后面的 yield 完全不生效\n\n**使用Generator的其余注意事项：**\n\n- 需要注意的是，yield 不能跨函数。并且yield需要和*配套使用，别处使用无效\n\n```javascript\nfunction* createIterator(items) {\n  items.forEach(function (item) {\n    // 语法错误\n    yield item + 1;\n  });\n}\n```\n\n- 箭头函数不能用做 generator\n\n**讲了这么多，那么Generator到底有什么用呢？**\n\n- 因为Generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。\n- Generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个在ajax请求中很有用，避免了回调地狱.\n\n#### 4、 async/await\n\n最后我们来讲讲async/await,终于讲到这儿了！！！\n async/await是ES7提出的关于异步的终极解决方案。我看网上关于async/await是谁的语法糖这块有两个版本：\n\n- 第一个版本说async/await是Generator的语法糖\n- 第二个版本说async/await是Promise的语法糖\n\n其实，这两种说法都没有错。\n **关于async/await是Generator的语法糖：** 所谓Generator语法糖，表明的就是aysnc/await实现的就是generator实现的功能。但是async/await比generator要好用。因为generator执行yield设下的断点采用的方式就是不断的调用iterator方法，这是个手动调用的过程。针对generator的这个缺点，后面提出了co这个库函数来自动执行next，相比于之前的方案，这种方式确实有了进步，但是仍然麻烦。而async配合await得到的就是断点执行后的结果。因此async/await比generator使用更普遍。\n\n**总结下来，async函数对 Generator函数的改进，主要体现在以下三点:**\n\n- 内置执行器：Generator函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co函数库。但是，async函数和正常的函数一样执行，也不用 co函数库，也不用使用 next方法，而 async函数自带执行器，会自动执行。\n- 适用性更好：co函数库有条件约束，yield命令后面只能是 Thunk函数或 Promise对象，但是 async函数的 await关键词后面，可以不受约束。\n- 可读性更好：async和 await，比起使用 *号和 yield，语义更清晰明了。\n\n**关于async/await是Promise的语法糖：** 如果不使用async/await的话，Promise就需要通过链式调用来依次执行then之后的代码：\n\n```javascript\nfunction counter(n){\n\treturn new Promise((resolve, reject) => { \n\t   resolve(n + 1);\n    });\n}\n\nfunction adder(a, b){\n    return new Promise((resolve, reject) => { \n\t   resolve(a + b);\n    });\n}\n\nfunction delay(a){\n    return new Promise((resolve, reject) => { \n\t   setTimeout(() => resolve(a), 1000);\n    });\n}\n// 链式调用写法\nfunction callAll(){\n    counter(1)\n       .then((val) => adder(val, 3))\n       .then((val) => delay(val))\n       .then(console.log);\n}\ncallAll();//5\n```\n\n虽然相比于回调地狱来说，链式调用确实顺眼多了。但是其呈现仍然略繁琐了一些。 而**async/await的出现，就使得我们可以通过同步代码来达到异步的效果**：\n\n```javascript\nasync function callAll(){\n   const count = await counter(1);\n   const sum = await adder(count, 3);\n   console.log(await delay(sum));\n}\ncallAll();// 5\n```\n\n由此可见，Promise搭配async/await的使用才是正解！\n\n**总结**\n\n- promise让异步执行看起来更清晰明了，通过then让异步执行结果分离出来。\n- async/await其实是基于Promise的。async函数其实是把promise包装了一下。使用async函数可以让代码简洁很多，不需要promise一样需要些then，不需要写匿名函数处理promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。\n- async函数是Generator函数的语法糖。async函数的返回值是 promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。同时，我们还可以用await来替代then方法指定下一步的操作。\n- 感觉Promise+async的操作最为常见。因为Generator的常用功能可以直接由async来体现呀~\n\n\n\n作者：DoubleSweet0824\n链接：https://juejin.cn/post/7082753409060716574","slug":"jsAsync","published":1,"updated":"2024-07-24T05:54:14.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2pt0004lyxx72h69a1o","content":"<h3 id=\"同步-amp-异步的概念\"><a href=\"#同步-amp-异步的概念\" class=\"headerlink\" title=\"同步&amp;异步的概念\"></a>同步&amp;异步的概念</h3><p>在讲这四种异步方案之前，我们先来明确一下同步和异步的概念：</p>\n<p>所谓<strong>同步(synchronization)<strong>，简单来说，就是</strong>顺序执行</strong>，指的是同一时间只能做一件事情，只有目前正在执行的事情做完之后，才能做下一件事情。 比如咱们去火车站买票，假设窗口只有1个，那么同一时间只能处理1个人的购票业务，其余的需要进行排队。这种one by one的动作就是同步。 <strong>同步操作的优点</strong>在于做任何事情都是依次执行，井然有序，不会存在大家同时抢一个资源的问题。 <strong>同步操作的缺点</strong>在于<strong>会阻塞后续代码的执行</strong>。如果当前执行的任务需要花费很长的时间，那么后面的程序就只能一直等待。从而影响效率，对应到前端页面的展示来说，有可能会造成页面渲染的阻塞，大大影响用户体验。</p>\n<p>所谓<strong>异步(Asynchronization)<strong>，指的是当前代码的执行不影响后面代码的执行。当程序运行到异步的代码时，会将该异步的代码作为任务放进任务队列，而不是推入主线程的调用栈。等主线程执行完之后，再去任务队列里执行对应的任务即可。 因此，</strong>异步操作的优点就是</strong>：<strong>不会阻塞后续代码的执行</strong>。</p>\n<h3 id=\"js中异步的应用场景\"><a href=\"#js中异步的应用场景\" class=\"headerlink\" title=\"js中异步的应用场景\"></a>js中异步的应用场景</h3><p>开篇讲了同步和异步的概念，那么在JS中异步的应用场景有哪些呢？</p>\n<ul>\n<li>定时任务：setTimeout、setInterval</li>\n<li>网络请求：ajax请求、动态创建img标签的加载</li>\n<li>事件监听器：addEventListener</li>\n</ul>\n<h3 id=\"实现异步的四种方法\"><a href=\"#实现异步的四种方法\" class=\"headerlink\" title=\"实现异步的四种方法\"></a>实现异步的四种方法</h3><p>对于setTimeout、setInterval、addEventListener这种异步场景，不需要我们手动实现异步，直接调用即可。 但是对于ajax请求、node.js中操作数据库这种异步，就需要我们自己来实现了~</p>\n<h4 id=\"1、-回调函数\"><a href=\"#1、-回调函数\" class=\"headerlink\" title=\"1、 回调函数\"></a>1、 回调函数</h4><p>在微任务队列出现之前，JS实现异步的主要方式就是通过回调函数。 以一个简易版的Ajax请求为例，代码结构如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ajax</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>\t<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">default</span> = &#123;<br>\t  <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;...&#x27;</span>,<br>\t  <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">&#x27;GET&#x27;</span>,<br>\t  <span class=\"hljs-attr\">async</span>:<span class=\"hljs-literal\">true</span>,<br>\t  <span class=\"hljs-attr\">contentType</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>,<br>\t  <span class=\"hljs-attr\">success</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br>    &#125;;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> obj) &#123;<br>        defaultParam[key] = obj[key];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">let</span> xhr;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">XMLHttpRequest</span>) &#123;<br>        xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ActiveXObject</span>(<span class=\"hljs-string\">&#x27;Microsoft.XMLHTTP&#x27;</span>);<br>    &#125;<br>    <br>    xhr.<span class=\"hljs-title function_\">open</span>(defaultParam.<span class=\"hljs-property\">type</span>, defaultParam.<span class=\"hljs-property\">url</span>+<span class=\"hljs-string\">&#x27;?&#x27;</span>+dataStr, defaultParam.<span class=\"hljs-property\">async</span>);<br>    xhr.<span class=\"hljs-title function_\">send</span>();<br>    xhr.<span class=\"hljs-property\">onreadystatechange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> === <span class=\"hljs-number\">4</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(xhr.<span class=\"hljs-property\">status</span> === <span class=\"hljs-number\">200</span>)&#123;<br>                <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(xhr.<span class=\"hljs-property\">responseText</span>);<br>                <span class=\"hljs-comment\">// 在此处调用回调函数</span><br>                defaultParam.<span class=\"hljs-title function_\">success</span>(result);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>我们在业务代码里可以这样调用ajax请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">ajax</span>(&#123;<br>   <span class=\"hljs-attr\">url</span>:<span class=\"hljs-string\">&#x27;#&#x27;</span>,<br>   <span class=\"hljs-attr\">type</span>:<span class=\"hljs-variable constant_\">GET</span>,<br>   <span class=\"hljs-attr\">success</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)&#123;<br>    <span class=\"hljs-comment\">// 回调函数里就是对请求结果的处理</span><br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>ajax的success方法就是一个回调函数，回调函数中执行的是我们请求成功之后要做的进一步操作。 这样就初步实现了异步，但是回调函数有一个非常严重的缺点，那就是<strong>回调地狱</strong>的问题。 大家可以试想一下，如果我们在回调函数里再发起一个ajax请求呢？那岂不是要在success函数里继续写一个ajax请求？那如果需要多级嵌套发起ajax请求呢？岂不是需要多级嵌套？如果嵌套的层级很深的话，我们的代码结构可能就会变成这样： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e467d65234bf4de995ab7efa6bd0fd86~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"回调地狱示意图\"> 因此，为了解决回调地狱的问题，提出了Promise、async&#x2F;await、generator的概念。</p>\n<h4 id=\"2、Promise\"><a href=\"#2、Promise\" class=\"headerlink\" title=\"2、Promise\"></a>2、Promise</h4><p>Promise作为典型的微任务之一，它的出现可以使JS达到异步执行的效果。 一个Promise函数的结构如下列代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>\t<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>&#125;);<br>promise<br>    .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =&gt;</span> &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`执行resolve,参数是<span class=\"hljs-subst\">$&#123;arg&#125;</span>`</span>) &#125;)<br>    .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =&gt;</span> &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`执行reject,参数是<span class=\"hljs-subst\">$&#123;arg&#125;</span>`</span>) &#125;)<br>    .<span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;结束promise&#x27;</span>) &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>如果，我们需要嵌套执行异步代码，相比于回调函数来说，Promise的执行方式如下列代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>\t<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>);<br>&#125;);<br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>    \t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    \t<span class=\"hljs-keyword\">return</span> value * <span class=\"hljs-number\">2</span>;<br>    &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>    \t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    \t<span class=\"hljs-keyword\">return</span> value * <span class=\"hljs-number\">2</span>;<br>    &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>\t  \t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    &#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>即，通过then来实现多级嵌套(<strong>链式调用</strong>)，这看起来是不是就比回调函数舒服多了~</p>\n<p>每个Promise都会经历的生命周期是：</p>\n<ul>\n<li>进行中（pending） - 此时代码执行尚未结束，所以也叫未处理的（unsettled）</li>\n<li>已处理（settled）   - 异步代码已执行结束 已处理的代码会进入两种状态中的一种：<ul>\n<li>已完成（fulfilled） - 表明异步代码执行成功，由resolve()触发</li>\n<li>已拒绝（rejected）- 遇到错误，异步代码执行失败 ，由reject()触发</li>\n</ul>\n</li>\n</ul>\n<p>因此，pending，fulfilled, rejected就是Promise中的三种状态啦~ 大家一定要牢记，在Promise中，要么包含resolve()来表示Promise的状态为fulfilled,要么包含reject()来表示Promise的状态为rejected。 不然我们的Promise就会一直处于pending的状态，直至程序崩溃…</p>\n<p>除此之外，Promise不仅很好的解决了链式调用的问题，它还有很多神奇的操作呢：</p>\n<ul>\n<li>**Promise.all(promises)**：接收一个包含多个Promise对象的数组，等待所有都完成时，返回存放它们结果的数组。如果任一被拒绝，则立即抛出错误，其他已完成的结果会被忽略</li>\n<li><strong>Promise.allSettled(promises)</strong>: 接收一个包含多个Promise对象的数组，等待所有都已完成或者已拒绝时，返回存放它们结果对象的数组。每个结果对象的结构为{status:’fulfilled’ &#x2F;&#x2F; 或 ‘rejected’, value &#x2F;&#x2F; 或reason}</li>\n<li><strong>Promise.race(promises)</strong>: 接收一个包含多个Promise对象的数组，等待第一个有结果（完成&#x2F;拒绝）的Promise，并把其result&#x2F;error作为结果返回</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPromises</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> [<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>((<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>), <span class=\"hljs-number\">1000</span>))),<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>((<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;2&#x27;</span>)), <span class=\"hljs-number\">2000</span>))),<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>((<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">3</span>), <span class=\"hljs-number\">3000</span>))),<br>    ];<br>&#125;<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(<span class=\"hljs-title function_\">getPromises</span>()).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">allSettled</span>(<span class=\"hljs-title function_\">getPromises</span>()).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>(<span class=\"hljs-title function_\">getPromises</span>()).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br></code></pre></td></tr></table></figure>\n\n<p>打印结果如下：<br> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deb4f7993f4f4280b388b861f6eb9c2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60e6b6e792de4b218071b160e78198df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c85c530253b44cdb65dbea0114fcf5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"3、Generator\"><a href=\"#3、Generator\" class=\"headerlink\" title=\"3、Generator\"></a>3、Generator</h4><p>Generator是ES6提出的一种异步编程的方案。因为手动创建一个iterator十分麻烦，因此ES6推出了generator，用于更方便的创建iterator。也就是说，Generator就是一个返回值为iterator对象的函数。<br> 在讲Generator之前，我们先来看看iterator是什么：<br> <strong>iterator是什么？</strong><br> <strong>iterator中文名叫迭代器。它为js中各种不同的数据结构(Object、Array、Set、Map)提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</strong> 因此iterator也是一种对象，不过相比于普通对象来说，它有着专为迭代而设计的接口。</p>\n<p><strong>iterator 的作用：</strong></p>\n<ul>\n<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>\n<li>使得数据结构的成员能够按某种次序排列；</li>\n<li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费</li>\n</ul>\n<p><strong>iterator的结构：</strong> 它有<strong>next</strong>方法，该方法返回一个包含<strong>value</strong>和<strong>done</strong>两个属性的对象（我们假设叫result）。<strong>value</strong>是迭代的值，后者是表明迭代是否完成的标志。true表示迭代完成，false表示没有。iterator内部有指向迭代位置的指针，每次调用<strong>next</strong>，自动移动指针并返回相应的result。</p>\n<p>原生具备iterator接口的数据结构如下：</p>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数里的arguments对象</li>\n<li>NodeList对象 这些数据结构都有一个Symbol.iterator属性，可以直接通过这个属性来直接创建一个迭代器。 也就是说，Symbol.iterator属性只是一个用来创建迭代器的接口，而不是一个迭代器，因为它不含遍历的部分。<br> 使用Symbol.iterator接口生成iterator迭代器来遍历数组的过程为：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><br><span class=\"hljs-keyword\">let</span> iter = arr[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: &#x27;a&#x27;, done: false &#125;</span><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: &#x27;b&#x27;, done: false &#125;</span><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: &#x27;c&#x27;, done: false &#125;</span><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>for … of的循环内部实现机制其实就是iterator，它首先调用被遍历集合对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象是可以拥有.next()方法的任何对象，然后，在 for … of 的每次循环中，都将调用该迭代器对象上的 .next 方法。然后使用for i of打印出来的i也就是调用.next方法后得到的对象上的value属性。</strong></p>\n<p>对于原生不具备iterator接口的数据结构，比如Object，我们可以采用自定义的方式来创建一个遍历器。</p>\n<p>比如，我们可以自定义一个iterator来遍历对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;world&quot;</span>&#125;;<br><span class=\"hljs-comment\">// 自定义迭代器</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createIterator</span>(<span class=\"hljs-params\">items</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> keyArr = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(items);<br>    <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>            <span class=\"hljs-keyword\">let</span> done = (i &gt;= keyArr.<span class=\"hljs-property\">length</span>);<br>            <span class=\"hljs-keyword\">let</span> value = !done ? items[keyArr[i++]] : <span class=\"hljs-literal\">undefined</span>;<br>            <span class=\"hljs-keyword\">return</span> &#123;<br>                <span class=\"hljs-attr\">value</span>: value,<br>                <span class=\"hljs-attr\">done</span>: done,<br>            &#125;;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> iterator = <span class=\"hljs-title function_\">createIterator</span>(obj);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &quot;&#123; value: &#x27;hello&#x27;, done: false &#125;&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());  <span class=\"hljs-comment\">// &quot;&#123; value: &#x27;world&#x27;, done: false &#125;&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());  <span class=\"hljs-comment\">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>接下来，我们来聊聊Generator:</strong><br> 我们通过一个例子来看看Gnerator的特征：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">createIterator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><span class=\"hljs-comment\">// generators可以像正常函数一样被调用，不同的是会返回一个 iterator</span><br><span class=\"hljs-keyword\">let</span> iterator = <span class=\"hljs-title function_\">createIterator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案。形式上，Generator 函数是一个普通函数，但是有两个特征:</p>\n<ul>\n<li>function关键字与函数名之间有一个星号</li>\n<li>函数体内部使用yield语句，定义不同的内部状态</li>\n</ul>\n<p>Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（<strong>Iterator Object</strong>）</p>\n<p>打印看看Generator函数返回值的内容： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5d88ad317c4ede817c1b56ffb10a40~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"> 发现generator函数的返回值的原型链上确实有iterator对象该有的next，<strong>这充分说明了generator的返回值是一个iterator</strong>。除此之外还有函数该有的return方法和throw方法。</p>\n<p>在普通函数中，我们想要一个函数最终的执行结果，一般都是return出来，或者以return作为结束函数的标准。运行函数时也不能被打断，期间也不能从外部再传入值到函数体内。 但在generator中，就打破了这几点，所以generator和普通的函数完全不同。 当以function*的方式声明了一个Generator生成器时，内部是可以有许多状态的，以yield进行断点间隔。期间我们执行调用这个生成的Generator,他会返回一个遍历器对象，用这个对象上的方法，实现获得一个yield后面输出的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">generator</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span><br>&#125;;<br><span class=\"hljs-keyword\">let</span> iterator = <span class=\"hljs-title function_\">generator</span>();<br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123;value: 1, done: false&#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123;value: 2, done: false&#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>yield和return的区别：</strong></p>\n<ul>\n<li>都能返回紧跟在语句后面的那个表达式的值</li>\n<li>yield相比于return来说，更像是一个断点。遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。</li>\n<li>一个函数里面，只能执行一个return语句，但是可以执行多次yield表达式。</li>\n<li>正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield</li>\n</ul>\n<p>语法注意点：</p>\n<ul>\n<li>yield表达式只能用在 Generator 函数里面</li>\n<li>yield表达式如果用在另一个表达式之中，必须放在圆括号里面</li>\n<li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</li>\n<li>如果 return 语句后面还有 yield 表达式，那么后面的 yield 完全不生效</li>\n</ul>\n<p><strong>使用Generator的其余注意事项：</strong></p>\n<ul>\n<li>需要注意的是，yield 不能跨函数。并且yield需要和*配套使用，别处使用无效</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">createIterator</span>(<span class=\"hljs-params\">items</span>) &#123;<br>  items.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>    <span class=\"hljs-comment\">// 语法错误</span><br>    <span class=\"hljs-keyword\">yield</span> item + <span class=\"hljs-number\">1</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>箭头函数不能用做 generator</li>\n</ul>\n<p><strong>讲了这么多，那么Generator到底有什么用呢？</strong></p>\n<ul>\n<li>因为Generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。</li>\n<li>Generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个在ajax请求中很有用，避免了回调地狱.</li>\n</ul>\n<h4 id=\"4、-async-x2F-await\"><a href=\"#4、-async-x2F-await\" class=\"headerlink\" title=\"4、 async&#x2F;await\"></a>4、 async&#x2F;await</h4><p>最后我们来讲讲async&#x2F;await,终于讲到这儿了！！！<br> async&#x2F;await是ES7提出的关于异步的终极解决方案。我看网上关于async&#x2F;await是谁的语法糖这块有两个版本：</p>\n<ul>\n<li>第一个版本说async&#x2F;await是Generator的语法糖</li>\n<li>第二个版本说async&#x2F;await是Promise的语法糖</li>\n</ul>\n<p>其实，这两种说法都没有错。<br> <strong>关于async&#x2F;await是Generator的语法糖：</strong> 所谓Generator语法糖，表明的就是aysnc&#x2F;await实现的就是generator实现的功能。但是async&#x2F;await比generator要好用。因为generator执行yield设下的断点采用的方式就是不断的调用iterator方法，这是个手动调用的过程。针对generator的这个缺点，后面提出了co这个库函数来自动执行next，相比于之前的方案，这种方式确实有了进步，但是仍然麻烦。而async配合await得到的就是断点执行后的结果。因此async&#x2F;await比generator使用更普遍。</p>\n<p><strong>总结下来，async函数对 Generator函数的改进，主要体现在以下三点:</strong></p>\n<ul>\n<li>内置执行器：Generator函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co函数库。但是，async函数和正常的函数一样执行，也不用 co函数库，也不用使用 next方法，而 async函数自带执行器，会自动执行。</li>\n<li>适用性更好：co函数库有条件约束，yield命令后面只能是 Thunk函数或 Promise对象，但是 async函数的 await关键词后面，可以不受约束。</li>\n<li>可读性更好：async和 await，比起使用 *号和 yield，语义更清晰明了。</li>\n</ul>\n<p><strong>关于async&#x2F;await是Promise的语法糖：</strong> 如果不使用async&#x2F;await的话，Promise就需要通过链式调用来依次执行then之后的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">counter</span>(<span class=\"hljs-params\">n</span>)&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; <br>\t   <span class=\"hljs-title function_\">resolve</span>(n + <span class=\"hljs-number\">1</span>);<br>    &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">adder</span>(<span class=\"hljs-params\">a, b</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; <br>\t   <span class=\"hljs-title function_\">resolve</span>(a + b);<br>    &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-params\">a</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; <br>\t   <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(a), <span class=\"hljs-number\">1000</span>);<br>    &#125;);<br>&#125;<br><span class=\"hljs-comment\">// 链式调用写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">callAll</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-title function_\">counter</span>(<span class=\"hljs-number\">1</span>)<br>       .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> <span class=\"hljs-title function_\">adder</span>(val, <span class=\"hljs-number\">3</span>))<br>       .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> <span class=\"hljs-title function_\">delay</span>(val))<br>       .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br>&#125;<br><span class=\"hljs-title function_\">callAll</span>();<span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n\n<p>虽然相比于回调地狱来说，链式调用确实顺眼多了。但是其呈现仍然略繁琐了一些。 而<strong>async&#x2F;await的出现，就使得我们可以通过同步代码来达到异步的效果</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">callAll</span>(<span class=\"hljs-params\"></span>)&#123;<br>   <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">counter</span>(<span class=\"hljs-number\">1</span>);<br>   <span class=\"hljs-keyword\">const</span> sum = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">adder</span>(count, <span class=\"hljs-number\">3</span>);<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">delay</span>(sum));<br>&#125;<br><span class=\"hljs-title function_\">callAll</span>();<span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n\n<p>由此可见，Promise搭配async&#x2F;await的使用才是正解！</p>\n<p><strong>总结</strong></p>\n<ul>\n<li>promise让异步执行看起来更清晰明了，通过then让异步执行结果分离出来。</li>\n<li>async&#x2F;await其实是基于Promise的。async函数其实是把promise包装了一下。使用async函数可以让代码简洁很多，不需要promise一样需要些then，不需要写匿名函数处理promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。</li>\n<li>async函数是Generator函数的语法糖。async函数的返回值是 promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。同时，我们还可以用await来替代then方法指定下一步的操作。</li>\n<li>感觉Promise+async的操作最为常见。因为Generator的常用功能可以直接由async来体现呀~</li>\n</ul>\n<p>作者：DoubleSweet0824<br>链接：<a href=\"https://juejin.cn/post/7082753409060716574\">https://juejin.cn/post/7082753409060716574</a></p>\n","site":{"data":{}},"wordcount":9625,"excerpt":"","more":"<h3 id=\"同步-amp-异步的概念\"><a href=\"#同步-amp-异步的概念\" class=\"headerlink\" title=\"同步&amp;异步的概念\"></a>同步&amp;异步的概念</h3><p>在讲这四种异步方案之前，我们先来明确一下同步和异步的概念：</p>\n<p>所谓<strong>同步(synchronization)<strong>，简单来说，就是</strong>顺序执行</strong>，指的是同一时间只能做一件事情，只有目前正在执行的事情做完之后，才能做下一件事情。 比如咱们去火车站买票，假设窗口只有1个，那么同一时间只能处理1个人的购票业务，其余的需要进行排队。这种one by one的动作就是同步。 <strong>同步操作的优点</strong>在于做任何事情都是依次执行，井然有序，不会存在大家同时抢一个资源的问题。 <strong>同步操作的缺点</strong>在于<strong>会阻塞后续代码的执行</strong>。如果当前执行的任务需要花费很长的时间，那么后面的程序就只能一直等待。从而影响效率，对应到前端页面的展示来说，有可能会造成页面渲染的阻塞，大大影响用户体验。</p>\n<p>所谓<strong>异步(Asynchronization)<strong>，指的是当前代码的执行不影响后面代码的执行。当程序运行到异步的代码时，会将该异步的代码作为任务放进任务队列，而不是推入主线程的调用栈。等主线程执行完之后，再去任务队列里执行对应的任务即可。 因此，</strong>异步操作的优点就是</strong>：<strong>不会阻塞后续代码的执行</strong>。</p>\n<h3 id=\"js中异步的应用场景\"><a href=\"#js中异步的应用场景\" class=\"headerlink\" title=\"js中异步的应用场景\"></a>js中异步的应用场景</h3><p>开篇讲了同步和异步的概念，那么在JS中异步的应用场景有哪些呢？</p>\n<ul>\n<li>定时任务：setTimeout、setInterval</li>\n<li>网络请求：ajax请求、动态创建img标签的加载</li>\n<li>事件监听器：addEventListener</li>\n</ul>\n<h3 id=\"实现异步的四种方法\"><a href=\"#实现异步的四种方法\" class=\"headerlink\" title=\"实现异步的四种方法\"></a>实现异步的四种方法</h3><p>对于setTimeout、setInterval、addEventListener这种异步场景，不需要我们手动实现异步，直接调用即可。 但是对于ajax请求、node.js中操作数据库这种异步，就需要我们自己来实现了~</p>\n<h4 id=\"1、-回调函数\"><a href=\"#1、-回调函数\" class=\"headerlink\" title=\"1、 回调函数\"></a>1、 回调函数</h4><p>在微任务队列出现之前，JS实现异步的主要方式就是通过回调函数。 以一个简易版的Ajax请求为例，代码结构如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ajax</span>(<span class=\"hljs-params\">obj</span>)&#123;<br>\t<span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">default</span> = &#123;<br>\t  <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;...&#x27;</span>,<br>\t  <span class=\"hljs-attr\">type</span>:<span class=\"hljs-string\">&#x27;GET&#x27;</span>,<br>\t  <span class=\"hljs-attr\">async</span>:<span class=\"hljs-literal\">true</span>,<br>\t  <span class=\"hljs-attr\">contentType</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>,<br>\t  <span class=\"hljs-attr\">success</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)&#123;&#125;<br>    &#125;;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> obj) &#123;<br>        defaultParam[key] = obj[key];<br>    &#125;<br><br>    <span class=\"hljs-keyword\">let</span> xhr;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">XMLHttpRequest</span>) &#123;<br>        xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">XMLHttpRequest</span>();<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        xhr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ActiveXObject</span>(<span class=\"hljs-string\">&#x27;Microsoft.XMLHTTP&#x27;</span>);<br>    &#125;<br>    <br>    xhr.<span class=\"hljs-title function_\">open</span>(defaultParam.<span class=\"hljs-property\">type</span>, defaultParam.<span class=\"hljs-property\">url</span>+<span class=\"hljs-string\">&#x27;?&#x27;</span>+dataStr, defaultParam.<span class=\"hljs-property\">async</span>);<br>    xhr.<span class=\"hljs-title function_\">send</span>();<br>    xhr.<span class=\"hljs-property\">onreadystatechange</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>)&#123;<br>        <span class=\"hljs-keyword\">if</span> (xhr.<span class=\"hljs-property\">readyState</span> === <span class=\"hljs-number\">4</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(xhr.<span class=\"hljs-property\">status</span> === <span class=\"hljs-number\">200</span>)&#123;<br>                <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(xhr.<span class=\"hljs-property\">responseText</span>);<br>                <span class=\"hljs-comment\">// 在此处调用回调函数</span><br>                defaultParam.<span class=\"hljs-title function_\">success</span>(result);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>我们在业务代码里可以这样调用ajax请求：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">ajax</span>(&#123;<br>   <span class=\"hljs-attr\">url</span>:<span class=\"hljs-string\">&#x27;#&#x27;</span>,<br>   <span class=\"hljs-attr\">type</span>:<span class=\"hljs-variable constant_\">GET</span>,<br>   <span class=\"hljs-attr\">success</span>:<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>)&#123;<br>    <span class=\"hljs-comment\">// 回调函数里就是对请求结果的处理</span><br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>ajax的success方法就是一个回调函数，回调函数中执行的是我们请求成功之后要做的进一步操作。 这样就初步实现了异步，但是回调函数有一个非常严重的缺点，那就是<strong>回调地狱</strong>的问题。 大家可以试想一下，如果我们在回调函数里再发起一个ajax请求呢？那岂不是要在success函数里继续写一个ajax请求？那如果需要多级嵌套发起ajax请求呢？岂不是需要多级嵌套？如果嵌套的层级很深的话，我们的代码结构可能就会变成这样： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e467d65234bf4de995ab7efa6bd0fd86~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"回调地狱示意图\"> 因此，为了解决回调地狱的问题，提出了Promise、async&#x2F;await、generator的概念。</p>\n<h4 id=\"2、Promise\"><a href=\"#2、Promise\" class=\"headerlink\" title=\"2、Promise\"></a>2、Promise</h4><p>Promise作为典型的微任务之一，它的出现可以使JS达到异步执行的效果。 一个Promise函数的结构如下列代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>\t<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>&#125;);<br>promise<br>    .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =&gt;</span> &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`执行resolve,参数是<span class=\"hljs-subst\">$&#123;arg&#125;</span>`</span>) &#125;)<br>    .<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">arg</span>) =&gt;</span> &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`执行reject,参数是<span class=\"hljs-subst\">$&#123;arg&#125;</span>`</span>) &#125;)<br>    .<span class=\"hljs-title function_\">finally</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;结束promise&#x27;</span>) &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>如果，我们需要嵌套执行异步代码，相比于回调函数来说，Promise的执行方式如下列代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> promise = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>\t<span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>);<br>&#125;);<br>promise.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>    \t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    \t<span class=\"hljs-keyword\">return</span> value * <span class=\"hljs-number\">2</span>;<br>    &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>    \t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    \t<span class=\"hljs-keyword\">return</span> value * <span class=\"hljs-number\">2</span>;<br>    &#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> &#123;<br>\t  \t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value);<br>    &#125;).<span class=\"hljs-title function_\">catch</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>\t\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>即，通过then来实现多级嵌套(<strong>链式调用</strong>)，这看起来是不是就比回调函数舒服多了~</p>\n<p>每个Promise都会经历的生命周期是：</p>\n<ul>\n<li>进行中（pending） - 此时代码执行尚未结束，所以也叫未处理的（unsettled）</li>\n<li>已处理（settled）   - 异步代码已执行结束 已处理的代码会进入两种状态中的一种：<ul>\n<li>已完成（fulfilled） - 表明异步代码执行成功，由resolve()触发</li>\n<li>已拒绝（rejected）- 遇到错误，异步代码执行失败 ，由reject()触发</li>\n</ul>\n</li>\n</ul>\n<p>因此，pending，fulfilled, rejected就是Promise中的三种状态啦~ 大家一定要牢记，在Promise中，要么包含resolve()来表示Promise的状态为fulfilled,要么包含reject()来表示Promise的状态为rejected。 不然我们的Promise就会一直处于pending的状态，直至程序崩溃…</p>\n<p>除此之外，Promise不仅很好的解决了链式调用的问题，它还有很多神奇的操作呢：</p>\n<ul>\n<li>**Promise.all(promises)**：接收一个包含多个Promise对象的数组，等待所有都完成时，返回存放它们结果的数组。如果任一被拒绝，则立即抛出错误，其他已完成的结果会被忽略</li>\n<li><strong>Promise.allSettled(promises)</strong>: 接收一个包含多个Promise对象的数组，等待所有都已完成或者已拒绝时，返回存放它们结果对象的数组。每个结果对象的结构为{status:’fulfilled’ &#x2F;&#x2F; 或 ‘rejected’, value &#x2F;&#x2F; 或reason}</li>\n<li><strong>Promise.race(promises)</strong>: 接收一个包含多个Promise对象的数组，等待第一个有结果（完成&#x2F;拒绝）的Promise，并把其result&#x2F;error作为结果返回</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">getPromises</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> [<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>((<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">1</span>), <span class=\"hljs-number\">1000</span>))),<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>((<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;2&#x27;</span>)), <span class=\"hljs-number\">2000</span>))),<br>        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>((<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-number\">3</span>), <span class=\"hljs-number\">3000</span>))),<br>    ];<br>&#125;<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(<span class=\"hljs-title function_\">getPromises</span>()).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">allSettled</span>(<span class=\"hljs-title function_\">getPromises</span>()).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>(<span class=\"hljs-title function_\">getPromises</span>()).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br></code></pre></td></tr></table></figure>\n\n<p>打印结果如下：<br> <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/deb4f7993f4f4280b388b861f6eb9c2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60e6b6e792de4b218071b160e78198df~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c85c530253b44cdb65dbea0114fcf5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"3、Generator\"><a href=\"#3、Generator\" class=\"headerlink\" title=\"3、Generator\"></a>3、Generator</h4><p>Generator是ES6提出的一种异步编程的方案。因为手动创建一个iterator十分麻烦，因此ES6推出了generator，用于更方便的创建iterator。也就是说，Generator就是一个返回值为iterator对象的函数。<br> 在讲Generator之前，我们先来看看iterator是什么：<br> <strong>iterator是什么？</strong><br> <strong>iterator中文名叫迭代器。它为js中各种不同的数据结构(Object、Array、Set、Map)提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。</strong> 因此iterator也是一种对象，不过相比于普通对象来说，它有着专为迭代而设计的接口。</p>\n<p><strong>iterator 的作用：</strong></p>\n<ul>\n<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>\n<li>使得数据结构的成员能够按某种次序排列；</li>\n<li>ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费</li>\n</ul>\n<p><strong>iterator的结构：</strong> 它有<strong>next</strong>方法，该方法返回一个包含<strong>value</strong>和<strong>done</strong>两个属性的对象（我们假设叫result）。<strong>value</strong>是迭代的值，后者是表明迭代是否完成的标志。true表示迭代完成，false表示没有。iterator内部有指向迭代位置的指针，每次调用<strong>next</strong>，自动移动指针并返回相应的result。</p>\n<p>原生具备iterator接口的数据结构如下：</p>\n<ul>\n<li>Array</li>\n<li>Map</li>\n<li>Set</li>\n<li>String</li>\n<li>TypedArray</li>\n<li>函数里的arguments对象</li>\n<li>NodeList对象 这些数据结构都有一个Symbol.iterator属性，可以直接通过这个属性来直接创建一个迭代器。 也就是说，Symbol.iterator属性只是一个用来创建迭代器的接口，而不是一个迭代器，因为它不含遍历的部分。<br> 使用Symbol.iterator接口生成iterator迭代器来遍历数组的过程为：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><br><span class=\"hljs-keyword\">let</span> iter = arr[<span class=\"hljs-title class_\">Symbol</span>.<span class=\"hljs-property\">iterator</span>]();<br><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: &#x27;a&#x27;, done: false &#125;</span><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: &#x27;b&#x27;, done: false &#125;</span><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: &#x27;c&#x27;, done: false &#125;</span><br>iter.<span class=\"hljs-title function_\">next</span>() <span class=\"hljs-comment\">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>for … of的循环内部实现机制其实就是iterator，它首先调用被遍历集合对象的 Symbol.iterator 方法，该方法返回一个迭代器对象，迭代器对象是可以拥有.next()方法的任何对象，然后，在 for … of 的每次循环中，都将调用该迭代器对象上的 .next 方法。然后使用for i of打印出来的i也就是调用.next方法后得到的对象上的value属性。</strong></p>\n<p>对于原生不具备iterator接口的数据结构，比如Object，我们可以采用自定义的方式来创建一个遍历器。</p>\n<p>比如，我们可以自定义一个iterator来遍历对象：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> obj = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-string\">&quot;hello&quot;</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">&quot;world&quot;</span>&#125;;<br><span class=\"hljs-comment\">// 自定义迭代器</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createIterator</span>(<span class=\"hljs-params\">items</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> keyArr = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(items);<br>    <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">return</span> &#123;<br>        <span class=\"hljs-attr\">next</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>            <span class=\"hljs-keyword\">let</span> done = (i &gt;= keyArr.<span class=\"hljs-property\">length</span>);<br>            <span class=\"hljs-keyword\">let</span> value = !done ? items[keyArr[i++]] : <span class=\"hljs-literal\">undefined</span>;<br>            <span class=\"hljs-keyword\">return</span> &#123;<br>                <span class=\"hljs-attr\">value</span>: value,<br>                <span class=\"hljs-attr\">done</span>: done,<br>            &#125;;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> iterator = <span class=\"hljs-title function_\">createIterator</span>(obj);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &quot;&#123; value: &#x27;hello&#x27;, done: false &#125;&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());  <span class=\"hljs-comment\">// &quot;&#123; value: &#x27;world&#x27;, done: false &#125;&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>());  <span class=\"hljs-comment\">// &quot;&#123; value: undefined, done: true &#125;&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>接下来，我们来聊聊Generator:</strong><br> 我们通过一个例子来看看Gnerator的特征：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">createIterator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><span class=\"hljs-comment\">// generators可以像正常函数一样被调用，不同的是会返回一个 iterator</span><br><span class=\"hljs-keyword\">let</span> iterator = <span class=\"hljs-title function_\">createIterator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 2</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(iterator.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n\n<p>Generator 函数是 ES6 提供的一种异步编程解决方案。形式上，Generator 函数是一个普通函数，但是有两个特征:</p>\n<ul>\n<li>function关键字与函数名之间有一个星号</li>\n<li>函数体内部使用yield语句，定义不同的内部状态</li>\n</ul>\n<p>Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（<strong>Iterator Object</strong>）</p>\n<p>打印看看Generator函数返回值的内容： <img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c5d88ad317c4ede817c1b56ffb10a40~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"> 发现generator函数的返回值的原型链上确实有iterator对象该有的next，<strong>这充分说明了generator的返回值是一个iterator</strong>。除此之外还有函数该有的return方法和throw方法。</p>\n<p>在普通函数中，我们想要一个函数最终的执行结果，一般都是return出来，或者以return作为结束函数的标准。运行函数时也不能被打断，期间也不能从外部再传入值到函数体内。 但在generator中，就打破了这几点，所以generator和普通的函数完全不同。 当以function*的方式声明了一个Generator生成器时，内部是可以有许多状态的，以yield进行断点间隔。期间我们执行调用这个生成的Generator,他会返回一个遍历器对象，用这个对象上的方法，实现获得一个yield后面输出的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">generator</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span><br>&#125;;<br><span class=\"hljs-keyword\">let</span> iterator = <span class=\"hljs-title function_\">generator</span>();<br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123;value: 1, done: false&#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123;value: 2, done: false&#125;</span><br>iterator.<span class=\"hljs-title function_\">next</span>()  <span class=\"hljs-comment\">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>yield和return的区别：</strong></p>\n<ul>\n<li>都能返回紧跟在语句后面的那个表达式的值</li>\n<li>yield相比于return来说，更像是一个断点。遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。</li>\n<li>一个函数里面，只能执行一个return语句，但是可以执行多次yield表达式。</li>\n<li>正常函数只能返回一个值，因为只能执行一次return；Generator 函数可以返回一系列的值，因为可以有任意多个yield</li>\n</ul>\n<p>语法注意点：</p>\n<ul>\n<li>yield表达式只能用在 Generator 函数里面</li>\n<li>yield表达式如果用在另一个表达式之中，必须放在圆括号里面</li>\n<li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</li>\n<li>如果 return 语句后面还有 yield 表达式，那么后面的 yield 完全不生效</li>\n</ul>\n<p><strong>使用Generator的其余注意事项：</strong></p>\n<ul>\n<li>需要注意的是，yield 不能跨函数。并且yield需要和*配套使用，别处使用无效</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">createIterator</span>(<span class=\"hljs-params\">items</span>) &#123;<br>  items.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) &#123;<br>    <span class=\"hljs-comment\">// 语法错误</span><br>    <span class=\"hljs-keyword\">yield</span> item + <span class=\"hljs-number\">1</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>箭头函数不能用做 generator</li>\n</ul>\n<p><strong>讲了这么多，那么Generator到底有什么用呢？</strong></p>\n<ul>\n<li>因为Generator可以在执行过程中多次返回，所以它看上去就像一个可以记住执行状态的函数，利用这一点，写一个generator就可以实现需要用面向对象才能实现的功能。</li>\n<li>Generator还有另一个巨大的好处，就是把异步回调代码变成“同步”代码。这个在ajax请求中很有用，避免了回调地狱.</li>\n</ul>\n<h4 id=\"4、-async-x2F-await\"><a href=\"#4、-async-x2F-await\" class=\"headerlink\" title=\"4、 async&#x2F;await\"></a>4、 async&#x2F;await</h4><p>最后我们来讲讲async&#x2F;await,终于讲到这儿了！！！<br> async&#x2F;await是ES7提出的关于异步的终极解决方案。我看网上关于async&#x2F;await是谁的语法糖这块有两个版本：</p>\n<ul>\n<li>第一个版本说async&#x2F;await是Generator的语法糖</li>\n<li>第二个版本说async&#x2F;await是Promise的语法糖</li>\n</ul>\n<p>其实，这两种说法都没有错。<br> <strong>关于async&#x2F;await是Generator的语法糖：</strong> 所谓Generator语法糖，表明的就是aysnc&#x2F;await实现的就是generator实现的功能。但是async&#x2F;await比generator要好用。因为generator执行yield设下的断点采用的方式就是不断的调用iterator方法，这是个手动调用的过程。针对generator的这个缺点，后面提出了co这个库函数来自动执行next，相比于之前的方案，这种方式确实有了进步，但是仍然麻烦。而async配合await得到的就是断点执行后的结果。因此async&#x2F;await比generator使用更普遍。</p>\n<p><strong>总结下来，async函数对 Generator函数的改进，主要体现在以下三点:</strong></p>\n<ul>\n<li>内置执行器：Generator函数的执行必须靠执行器，因为不能一次性执行完成，所以之后才有了开源的 co函数库。但是，async函数和正常的函数一样执行，也不用 co函数库，也不用使用 next方法，而 async函数自带执行器，会自动执行。</li>\n<li>适用性更好：co函数库有条件约束，yield命令后面只能是 Thunk函数或 Promise对象，但是 async函数的 await关键词后面，可以不受约束。</li>\n<li>可读性更好：async和 await，比起使用 *号和 yield，语义更清晰明了。</li>\n</ul>\n<p><strong>关于async&#x2F;await是Promise的语法糖：</strong> 如果不使用async&#x2F;await的话，Promise就需要通过链式调用来依次执行then之后的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">counter</span>(<span class=\"hljs-params\">n</span>)&#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; <br>\t   <span class=\"hljs-title function_\">resolve</span>(n + <span class=\"hljs-number\">1</span>);<br>    &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">adder</span>(<span class=\"hljs-params\">a, b</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; <br>\t   <span class=\"hljs-title function_\">resolve</span>(a + b);<br>    &#125;);<br>&#125;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-params\">a</span>)&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123; <br>\t   <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(a), <span class=\"hljs-number\">1000</span>);<br>    &#125;);<br>&#125;<br><span class=\"hljs-comment\">// 链式调用写法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">callAll</span>(<span class=\"hljs-params\"></span>)&#123;<br>    <span class=\"hljs-title function_\">counter</span>(<span class=\"hljs-number\">1</span>)<br>       .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> <span class=\"hljs-title function_\">adder</span>(val, <span class=\"hljs-number\">3</span>))<br>       .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">val</span>) =&gt;</span> <span class=\"hljs-title function_\">delay</span>(val))<br>       .<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-property\">log</span>);<br>&#125;<br><span class=\"hljs-title function_\">callAll</span>();<span class=\"hljs-comment\">//5</span><br></code></pre></td></tr></table></figure>\n\n<p>虽然相比于回调地狱来说，链式调用确实顺眼多了。但是其呈现仍然略繁琐了一些。 而<strong>async&#x2F;await的出现，就使得我们可以通过同步代码来达到异步的效果</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">callAll</span>(<span class=\"hljs-params\"></span>)&#123;<br>   <span class=\"hljs-keyword\">const</span> count = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">counter</span>(<span class=\"hljs-number\">1</span>);<br>   <span class=\"hljs-keyword\">const</span> sum = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">adder</span>(count, <span class=\"hljs-number\">3</span>);<br>   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">delay</span>(sum));<br>&#125;<br><span class=\"hljs-title function_\">callAll</span>();<span class=\"hljs-comment\">// 5</span><br></code></pre></td></tr></table></figure>\n\n<p>由此可见，Promise搭配async&#x2F;await的使用才是正解！</p>\n<p><strong>总结</strong></p>\n<ul>\n<li>promise让异步执行看起来更清晰明了，通过then让异步执行结果分离出来。</li>\n<li>async&#x2F;await其实是基于Promise的。async函数其实是把promise包装了一下。使用async函数可以让代码简洁很多，不需要promise一样需要些then，不需要写匿名函数处理promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。</li>\n<li>async函数是Generator函数的语法糖。async函数的返回值是 promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。同时，我们还可以用await来替代then方法指定下一步的操作。</li>\n<li>感觉Promise+async的操作最为常见。因为Generator的常用功能可以直接由async来体现呀~</li>\n</ul>\n<p>作者：DoubleSweet0824<br>链接：<a href=\"https://juejin.cn/post/7082753409060716574\">https://juejin.cn/post/7082753409060716574</a></p>\n"},{"title":"Markdown 基本语法","date":"2022-04-03T12:43:19.000Z","_content":"\n## Markdown 常用语法记录 + 栗子展示\n\n### 🌰例子1 : \n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n\n```\n  # 这是一级标题\n  ## 这是二级标题\n  ### 这是三级标题\n```\n\n### 🌰例子2(字体) : \n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n```\n  **这是加粗的文字**\n  *这是倾斜的文字*`\n  ***这是斜体加粗的文字***\n  ~~这是加删除线的文字~~\n```\n\n### 🌰例子3(引用) : \n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n\n```\n  >这是引用的内容\n  >>这是引用的内容\n  >>>>>>>>>>这是引用的内容\n```\n\n### 🌰例子4(分割线) : \n---\n----\n***\n*****\n\n```\n  ---\n  ----\n  ***\n  *****\n```\n\n### 🌰例子5(图片) : \n![图片alt](图片地址 ''图片title'')\n图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加\n![blockchain](http://ra2xog64f.bkt.clouddn.com/blog/647DC87B-FDA7-4079-BADE-299589ECD64F.jpeg \"萌妹子\")\n\n```\n  ![blockchain](http://ra2xog64f.bkt.clouddn.com/blog/647DC87B-FDA7-4079-BADE-299589ECD64F.jpeg \"萌妹子\")\n```\n\n### 🌰例子6(超链接) : \n[我的blog](https://cosimac.github.io/ \"我的blog\")\n[超链接名](超链接地址 \"超链接title\")\ntitle可加可不加\n\n```\n  [我的blog](https://cosimac.github.io/ \"我的blog\")\n```\n\n### 🌰例子7(无序列表) : \n- 列表内容\n+ 列表内容\n* 列表内容\n\n注意：- + * 跟内容之间都要有一个空格\n\n```\n  - 列表内容\n  + 列表内容\n  * 列表内容\n```\n\n### 🌰例子8(有序列表) : \n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n注意：序号跟内容之间要有空格\n\n```\n  1. 列表内容\n  2. 列表内容\n  3. 列表内容\n```\n列表的嵌套\n- 1\n  - 11\n  - 22\n\n### 🌰例子9(表格) : \n| 姓名 | 技能  | 排行 |\n| ---- | :---: | ---: |\n| 刘备 |  哭   | 大哥 |\n| 关羽 |  打   | 二哥 |\n| 张飞 |  骂   | 三弟 |\n\n第二行分割表头和内容。\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来。此处省略\n\n```\n  | 姓名 | 技能  | 排行 |\n  | ---- | :---: | ---: |\n  | 刘备 |  哭   | 大哥 |\n  | 关羽 |  打   | 二哥 |\n  | 张飞 |  骂   | 三弟 |\n```\n\n### 🌰例子10(代码行) : \n语法：\n单行代码：代码之间分别用一个反引号包起来\n  `代码内容`\n代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n````\n  代码...\n  代码...\n  代码...\n````\n\n### 🌰例子11(流程图) : \n>未完待续...","source":"_posts/markdown.md","raw":"---\ntitle: Markdown 基本语法\ndate: 2022-04-03 20:43:19\ntags:\n---\n\n## Markdown 常用语法记录 + 栗子展示\n\n### 🌰例子1 : \n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n\n```\n  # 这是一级标题\n  ## 这是二级标题\n  ### 这是三级标题\n```\n\n### 🌰例子2(字体) : \n**这是加粗的文字**\n*这是倾斜的文字*`\n***这是斜体加粗的文字***\n~~这是加删除线的文字~~\n\n```\n  **这是加粗的文字**\n  *这是倾斜的文字*`\n  ***这是斜体加粗的文字***\n  ~~这是加删除线的文字~~\n```\n\n### 🌰例子3(引用) : \n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n\n```\n  >这是引用的内容\n  >>这是引用的内容\n  >>>>>>>>>>这是引用的内容\n```\n\n### 🌰例子4(分割线) : \n---\n----\n***\n*****\n\n```\n  ---\n  ----\n  ***\n  *****\n```\n\n### 🌰例子5(图片) : \n![图片alt](图片地址 ''图片title'')\n图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加\n![blockchain](http://ra2xog64f.bkt.clouddn.com/blog/647DC87B-FDA7-4079-BADE-299589ECD64F.jpeg \"萌妹子\")\n\n```\n  ![blockchain](http://ra2xog64f.bkt.clouddn.com/blog/647DC87B-FDA7-4079-BADE-299589ECD64F.jpeg \"萌妹子\")\n```\n\n### 🌰例子6(超链接) : \n[我的blog](https://cosimac.github.io/ \"我的blog\")\n[超链接名](超链接地址 \"超链接title\")\ntitle可加可不加\n\n```\n  [我的blog](https://cosimac.github.io/ \"我的blog\")\n```\n\n### 🌰例子7(无序列表) : \n- 列表内容\n+ 列表内容\n* 列表内容\n\n注意：- + * 跟内容之间都要有一个空格\n\n```\n  - 列表内容\n  + 列表内容\n  * 列表内容\n```\n\n### 🌰例子8(有序列表) : \n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n注意：序号跟内容之间要有空格\n\n```\n  1. 列表内容\n  2. 列表内容\n  3. 列表内容\n```\n列表的嵌套\n- 1\n  - 11\n  - 22\n\n### 🌰例子9(表格) : \n| 姓名 | 技能  | 排行 |\n| ---- | :---: | ---: |\n| 刘备 |  哭   | 大哥 |\n| 关羽 |  打   | 二哥 |\n| 张飞 |  骂   | 三弟 |\n\n第二行分割表头和内容。\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来。此处省略\n\n```\n  | 姓名 | 技能  | 排行 |\n  | ---- | :---: | ---: |\n  | 刘备 |  哭   | 大哥 |\n  | 关羽 |  打   | 二哥 |\n  | 张飞 |  骂   | 三弟 |\n```\n\n### 🌰例子10(代码行) : \n语法：\n单行代码：代码之间分别用一个反引号包起来\n  `代码内容`\n代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n````\n  代码...\n  代码...\n  代码...\n````\n\n### 🌰例子11(流程图) : \n>未完待续...","slug":"markdown","published":1,"updated":"2024-07-24T05:54:14.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2pu0005lyxxd2hy8t7j","content":"<h2 id=\"Markdown-常用语法记录-栗子展示\"><a href=\"#Markdown-常用语法记录-栗子展示\" class=\"headerlink\" title=\"Markdown 常用语法记录 + 栗子展示\"></a>Markdown 常用语法记录 + 栗子展示</h2><h3 id=\"🌰例子1\"><a href=\"#🌰例子1\" class=\"headerlink\" title=\"🌰例子1 :\"></a>🌰例子1 :</h3><h1 id=\"这是一级标题\"><a href=\"#这是一级标题\" class=\"headerlink\" title=\"这是一级标题\"></a>这是一级标题</h1><h2 id=\"这是二级标题\"><a href=\"#这是二级标题\" class=\"headerlink\" title=\"这是二级标题\"></a>这是二级标题</h2><h3 id=\"这是三级标题\"><a href=\"#这是三级标题\" class=\"headerlink\" title=\"这是三级标题\"></a>这是三级标题</h3><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\"># 这是一级标题<br>## 这是二级标题<br>### 这是三级标题<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子2-字体\"><a href=\"#🌰例子2-字体\" class=\"headerlink\" title=\"🌰例子2(字体) :\"></a>🌰例子2(字体) :</h3><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>&#96;<br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-strong\">**这是加粗的文字**</span><br><span class=\"hljs-emphasis\">*这是倾斜的文字*</span>`<br><span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*这是斜体加粗的文字*</span>**</span><br>~~这是加删除线的文字~~<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子3-引用\"><a href=\"#🌰例子3-引用\" class=\"headerlink\" title=\"🌰例子3(引用) :\"></a>🌰例子3(引用) :</h3><blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>这是引用的内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">&gt;</span><span class=\"language-bash\">这是引用的内容</span><br><span class=\"hljs-meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;这是引用的内容</span><br><span class=\"hljs-meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子4-分割线\"><a href=\"#🌰例子4-分割线\" class=\"headerlink\" title=\"🌰例子4(分割线) :\"></a>🌰例子4(分割线) :</h3><hr>\n<hr>\n<hr>\n<hr>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-section\">---</span><br><span class=\"hljs-section\">----</span><br><span class=\"hljs-bullet\">***</span><br><span class=\"hljs-bullet\"></span><span class=\"hljs-strong\">*****</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子5-图片\"><a href=\"#🌰例子5-图片\" class=\"headerlink\" title=\"🌰例子5(图片) :\"></a>🌰例子5(图片) :</h3><p>![图片alt](图片地址 ‘’图片title’’)<br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br><img src=\"http://ra2xog64f.bkt.clouddn.com/blog/647DC87B-FDA7-4079-BADE-299589ECD64F.jpeg\" alt=\"blockchain\" title=\"萌妹子\"></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">![blockchain](http:<span class=\"hljs-regexp\">//</span>ra2xog64f.bkt.clouddn.com<span class=\"hljs-regexp\">/blog/</span><span class=\"hljs-number\">647</span>DC87B-FDA7-<span class=\"hljs-number\">4079</span>-BADE-<span class=\"hljs-number\">299589</span>ECD64F.jpeg <span class=\"hljs-string\">&quot;萌妹子&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子6-超链接\"><a href=\"#🌰例子6-超链接\" class=\"headerlink\" title=\"🌰例子6(超链接) :\"></a>🌰例子6(超链接) :</h3><p><a href=\"https://cosimac.github.io/\" title=\"我的blog\">我的blog</a><br><a href=\"%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" title=\"超链接title\">超链接名</a><br>title可加可不加</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">[我的blog](https:<span class=\"hljs-regexp\">//</span>cosimac.github.io/ <span class=\"hljs-string\">&quot;我的blog&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子7-无序列表\"><a href=\"#🌰例子7-无序列表\" class=\"headerlink\" title=\"🌰例子7(无序列表) :\"></a>🌰例子7(无序列表) :</h3><ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<p>注意：- + * 跟内容之间都要有一个空格</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">-</span> 列表内容<br><span class=\"hljs-bullet\">+</span> 列表内容<br><span class=\"hljs-bullet\">*</span> 列表内容<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子8-有序列表\"><a href=\"#🌰例子8-有序列表\" class=\"headerlink\" title=\"🌰例子8(有序列表) :\"></a>🌰例子8(有序列表) :</h3><ol>\n<li>列表内容</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ol>\n<p>注意：序号跟内容之间要有空格</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 列表内容<br><span class=\"hljs-bullet\">2.</span> 列表内容<br><span class=\"hljs-bullet\">3.</span> 列表内容<br></code></pre></td></tr></table></figure>\n<p>列表的嵌套</p>\n<ul>\n<li>1<ul>\n<li>11</li>\n<li>22</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"🌰例子9-表格\"><a href=\"#🌰例子9-表格\" class=\"headerlink\" title=\"🌰例子9(表格) :\"></a>🌰例子9(表格) :</h3><table>\n<thead>\n<tr>\n<th>姓名</th>\n<th align=\"center\">技能</th>\n<th align=\"right\">排行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>刘备</td>\n<td align=\"center\">哭</td>\n<td align=\"right\">大哥</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td align=\"center\">打</td>\n<td align=\"right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td align=\"center\">骂</td>\n<td align=\"right\">三弟</td>\n</tr>\n</tbody></table>\n<p>第二行分割表头和内容。<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</p>\n<figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gherkin\">|<span class=\"hljs-string\"> 姓名 </span>|<span class=\"hljs-string\"> 技能  </span>|<span class=\"hljs-string\"> 排行 </span>|<br>|<span class=\"hljs-string\"> ---- </span>|<span class=\"hljs-string\"> :---: </span>|<span class=\"hljs-string\"> ---: </span>|<br>|<span class=\"hljs-string\"> 刘备 </span>|<span class=\"hljs-string\">  哭   </span>|<span class=\"hljs-string\"> 大哥 </span>|<br>|<span class=\"hljs-string\"> 关羽 </span>|<span class=\"hljs-string\">  打   </span>|<span class=\"hljs-string\"> 二哥 </span>|<br>|<span class=\"hljs-string\"> 张飞 </span>|<span class=\"hljs-string\">  骂   </span>|<span class=\"hljs-string\"> 三弟 </span>|<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子10-代码行\"><a href=\"#🌰例子10-代码行\" class=\"headerlink\" title=\"🌰例子10(代码行) :\"></a>🌰例子10(代码行) :</h3><p>语法：<br>单行代码：代码之间分别用一个反引号包起来<br>  <code>代码内容</code><br>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang\">代码...<br>代码...<br>代码...<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子11-流程图\"><a href=\"#🌰例子11-流程图\" class=\"headerlink\" title=\"🌰例子11(流程图) :\"></a>🌰例子11(流程图) :</h3><blockquote>\n<p>未完待续…</p>\n</blockquote>\n","site":{"data":{}},"wordcount":992,"excerpt":"","more":"<h2 id=\"Markdown-常用语法记录-栗子展示\"><a href=\"#Markdown-常用语法记录-栗子展示\" class=\"headerlink\" title=\"Markdown 常用语法记录 + 栗子展示\"></a>Markdown 常用语法记录 + 栗子展示</h2><h3 id=\"🌰例子1\"><a href=\"#🌰例子1\" class=\"headerlink\" title=\"🌰例子1 :\"></a>🌰例子1 :</h3><h1 id=\"这是一级标题\"><a href=\"#这是一级标题\" class=\"headerlink\" title=\"这是一级标题\"></a>这是一级标题</h1><h2 id=\"这是二级标题\"><a href=\"#这是二级标题\" class=\"headerlink\" title=\"这是二级标题\"></a>这是二级标题</h2><h3 id=\"这是三级标题\"><a href=\"#这是三级标题\" class=\"headerlink\" title=\"这是三级标题\"></a>这是三级标题</h3><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clean\"># 这是一级标题<br>## 这是二级标题<br>### 这是三级标题<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子2-字体\"><a href=\"#🌰例子2-字体\" class=\"headerlink\" title=\"🌰例子2(字体) :\"></a>🌰例子2(字体) :</h3><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>&#96;<br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-strong\">**这是加粗的文字**</span><br><span class=\"hljs-emphasis\">*这是倾斜的文字*</span>`<br><span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*这是斜体加粗的文字*</span>**</span><br>~~这是加删除线的文字~~<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子3-引用\"><a href=\"#🌰例子3-引用\" class=\"headerlink\" title=\"🌰例子3(引用) :\"></a>🌰例子3(引用) :</h3><blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<p>这是引用的内容</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>这是引用的内容</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">&gt;</span><span class=\"language-bash\">这是引用的内容</span><br><span class=\"hljs-meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;这是引用的内容</span><br><span class=\"hljs-meta prompt_\">&gt;</span><span class=\"language-bash\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子4-分割线\"><a href=\"#🌰例子4-分割线\" class=\"headerlink\" title=\"🌰例子4(分割线) :\"></a>🌰例子4(分割线) :</h3><hr>\n<hr>\n<hr>\n<hr>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\"><span class=\"hljs-section\">---</span><br><span class=\"hljs-section\">----</span><br><span class=\"hljs-bullet\">***</span><br><span class=\"hljs-bullet\"></span><span class=\"hljs-strong\">*****</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子5-图片\"><a href=\"#🌰例子5-图片\" class=\"headerlink\" title=\"🌰例子5(图片) :\"></a>🌰例子5(图片) :</h3><p>![图片alt](图片地址 ‘’图片title’’)<br>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加<br><img src=\"http://ra2xog64f.bkt.clouddn.com/blog/647DC87B-FDA7-4079-BADE-299589ECD64F.jpeg\" alt=\"blockchain\" title=\"萌妹子\"></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">![blockchain](http:<span class=\"hljs-regexp\">//</span>ra2xog64f.bkt.clouddn.com<span class=\"hljs-regexp\">/blog/</span><span class=\"hljs-number\">647</span>DC87B-FDA7-<span class=\"hljs-number\">4079</span>-BADE-<span class=\"hljs-number\">299589</span>ECD64F.jpeg <span class=\"hljs-string\">&quot;萌妹子&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子6-超链接\"><a href=\"#🌰例子6-超链接\" class=\"headerlink\" title=\"🌰例子6(超链接) :\"></a>🌰例子6(超链接) :</h3><p><a href=\"https://cosimac.github.io/\" title=\"我的blog\">我的blog</a><br><a href=\"%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80\" title=\"超链接title\">超链接名</a><br>title可加可不加</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">[我的blog](https:<span class=\"hljs-regexp\">//</span>cosimac.github.io/ <span class=\"hljs-string\">&quot;我的blog&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子7-无序列表\"><a href=\"#🌰例子7-无序列表\" class=\"headerlink\" title=\"🌰例子7(无序列表) :\"></a>🌰例子7(无序列表) :</h3><ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<ul>\n<li>列表内容</li>\n</ul>\n<p>注意：- + * 跟内容之间都要有一个空格</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">-</span> 列表内容<br><span class=\"hljs-bullet\">+</span> 列表内容<br><span class=\"hljs-bullet\">*</span> 列表内容<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子8-有序列表\"><a href=\"#🌰例子8-有序列表\" class=\"headerlink\" title=\"🌰例子8(有序列表) :\"></a>🌰例子8(有序列表) :</h3><ol>\n<li>列表内容</li>\n<li>列表内容</li>\n<li>列表内容</li>\n</ol>\n<p>注意：序号跟内容之间要有空格</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 列表内容<br><span class=\"hljs-bullet\">2.</span> 列表内容<br><span class=\"hljs-bullet\">3.</span> 列表内容<br></code></pre></td></tr></table></figure>\n<p>列表的嵌套</p>\n<ul>\n<li>1<ul>\n<li>11</li>\n<li>22</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"🌰例子9-表格\"><a href=\"#🌰例子9-表格\" class=\"headerlink\" title=\"🌰例子9(表格) :\"></a>🌰例子9(表格) :</h3><table>\n<thead>\n<tr>\n<th>姓名</th>\n<th align=\"center\">技能</th>\n<th align=\"right\">排行</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>刘备</td>\n<td align=\"center\">哭</td>\n<td align=\"right\">大哥</td>\n</tr>\n<tr>\n<td>关羽</td>\n<td align=\"center\">打</td>\n<td align=\"right\">二哥</td>\n</tr>\n<tr>\n<td>张飞</td>\n<td align=\"center\">骂</td>\n<td align=\"right\">三弟</td>\n</tr>\n</tbody></table>\n<p>第二行分割表头和内容。<br>文字默认居左<br>-两边加：表示文字居中<br>-右边加：表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</p>\n<figure class=\"highlight gherkin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gherkin\">|<span class=\"hljs-string\"> 姓名 </span>|<span class=\"hljs-string\"> 技能  </span>|<span class=\"hljs-string\"> 排行 </span>|<br>|<span class=\"hljs-string\"> ---- </span>|<span class=\"hljs-string\"> :---: </span>|<span class=\"hljs-string\"> ---: </span>|<br>|<span class=\"hljs-string\"> 刘备 </span>|<span class=\"hljs-string\">  哭   </span>|<span class=\"hljs-string\"> 大哥 </span>|<br>|<span class=\"hljs-string\"> 关羽 </span>|<span class=\"hljs-string\">  打   </span>|<span class=\"hljs-string\"> 二哥 </span>|<br>|<span class=\"hljs-string\"> 张飞 </span>|<span class=\"hljs-string\">  骂   </span>|<span class=\"hljs-string\"> 三弟 </span>|<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子10-代码行\"><a href=\"#🌰例子10-代码行\" class=\"headerlink\" title=\"🌰例子10(代码行) :\"></a>🌰例子10(代码行) :</h3><p>语法：<br>单行代码：代码之间分别用一个反引号包起来<br>  <code>代码内容</code><br>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs erlang\">代码...<br>代码...<br>代码...<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"🌰例子11-流程图\"><a href=\"#🌰例子11-流程图\" class=\"headerlink\" title=\"🌰例子11(流程图) :\"></a>🌰例子11(流程图) :</h3><blockquote>\n<p>未完待续…</p>\n</blockquote>\n"},{"title":"正则表达式不要背","date":"2022-10-28T12:43:19.000Z","_content":"\n![正则表达式不要背](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9df51b66af0~tplv-t2oaga2asx-zoom-crop-mark:3024:3024:3024:1702.awebp)\n\n正则表达式一直是困扰很多程序员的一门技术，当然也包括曾经的我。大多数时候我们在开发过程中要用到某些正则表达式的时候，都会打开谷歌或百度直接搜索然后拷贝粘贴。当下一次再遇到相同问题的时候，同样的场景又再来一遍。作为一门用途很广的技术，我相信深入理解正则表达式并能融会贯通是值得的。所以，希望这篇文章能帮助大家理清思路，搞懂正则表达式各种符号之间的内在联系，形成知识体系，当下次再遇到正则表达式的时候可以不借助搜索引擎，自己解决。\n\n# 正则表达式到底是什么\n\n正则表达式(Regular Expression)其实就是一门工具，**目的**是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种**用来描述规则的表达式**。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用[regexper.com](https://link.juejin.cn/?target=https%3A%2F%2Fregexper.com%2F)这个工具很好地可视化自己写的正则表达式:\n\n如`/\\d\\w+/`这个正则生成的状态机图:\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9d9357f691c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\n\n\n\n对于具体的算法实现，大家如果感兴趣可以阅读《算法导论》。\n\n# 从字符出发\n\n我们学习一个系统化的知识，一定要从其基础构成来了解。正则表达式的基本**组成元素**可以分为：**字符和元字符**。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。利用这些元字符，才能构造出强大的表达式模式(pattern)。接下来，我们就来从这些基本单位出发，来学习一下如何构建正则表达式。\n\n## 单个字符\n\n最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在'apple'这个单词里找到‘a'这个字符，就直接用`/a/`这个正则就可以了。\n\n但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**`\\`**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：\n\n我想匹配`*`这个符号，由于`*`这个符号本身是个特殊字符，所以我要利用转义元字符`\\`来让它失去其本来的含义：\n\n```\n/\\*/\n```\n\n如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式：\n\n| 特殊字符   | 正则表达式 | 记忆方式                                     |\n| ---------- | ---------- | -------------------------------------------- |\n| 换行符     | \\n         | **n**ew line                                 |\n| 换页符     | \\f         | **f**orm feed                                |\n| 回车符     | \\r         | **r**eturn                                   |\n| 空白符     | \\s         | **s**pace                                    |\n| 制表符     | \\t         | **t**ab                                      |\n| 垂直制表符 | \\v         | **v**ertical tab                             |\n| 回退符     | [\\b]       | **b**ackspace,之所以使用[]符号是避免和\\b重复 |\n\n## 多个字符\n\n单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。\n\n在正则表达式里，集合的定义方式是使用中括号`[`和`]`。如`/[123]/`这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符`-`就可以用来表示区间范围，利用`/[0-9]/`就能匹配所有的数字, `/[a-z]/`则可以匹配所有的英文小写字母。\n\n即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式:\n\n| 匹配区间                                      | 正则表达式 | 记忆方式            |\n| --------------------------------------------- | ---------- | ------------------- |\n| 除了换行符之外的任何字符                      | .          | 句号,除了句子结束符 |\n| 单个数字, [0-9]                               | \\d         | **d**igit           |\n| 除了[0-9]                                     | \\D         | **not** **d**igit   |\n| 包括下划线在内的单个字符，[A-Za-z0-9_]        | \\w         | **w**ord            |\n| 非单字字符                                    | \\W         | **not** **w**ord    |\n| 匹配空白字符,包括空格、制表符、换页符和换行符 | \\s         | **s**pace           |\n| 匹配非空白字符                                | \\S         | **not** **s**pace   |\n\n# 循环与重复\n\n一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。\n\n## 0 | 1\n\n元字符`?`代表了匹配一个字符或0个字符。设想一下，如果你要匹配`color`和`colour`这两个单词，就需要同时保证`u`这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：`/colou?r/`。\n\n## >= 0\n\n元字符`*`用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。\n\n## >= 1\n\n元字符`+`适用于要匹配同个字符出现1次或多次的情况。\n\n## 特定次数\n\n在某些情况下，我们需要匹配特定的重复次数，元字符`{`和`}`用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就使用`/a{3}/`这个正则，或者说'a'我想匹配至少两次就是用`/a{2,}/`这个正则。\n\n以下是完整的语法：\n\n```arduino\n- {x}: x次\n\n- {min, max}： 介于min次到max次之间\n\n- {min, }: 至少min次\n\n- {0, max}： 至多max次\n```\n\n由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。\n\n| 匹配规则    | 元字符          | 联想方式                                                                                     |\n| ----------- | --------------- | -------------------------------------------------------------------------------------------- |\n| 0次或1次    | ?               | 且**问**,此事**有**还**无**                                                                  |\n| 0次或无数次 | *               | 宇宙洪荒,**辰宿**列张：宇宙伊始，从无到有，最后星宿布满星空                                  |\n| 1次或无数次 | +               | **一加**, +1                                                                                 |\n| 特定次数    | {x}, {min, max} | 可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界 |\n\n# 位置边界\n\n上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。\n\n## 单词边界\n\n单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：\n\n```sql\nThe cat scattered his food all over the room.\n```\n\n我想找到`cat`这个单词，但是如果只是使用`/cat/`这个正则，就会同时匹配到`cat`和`scattered`这两处文本。这时候我们就需要使用边界正则表达式`\\b`，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。\n\n上面的例子改写成`/\\bcat\\b/`这样就能匹配到`cat`这个单词了。\n\n## 字符串边界\n\n匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符`^`用来匹配字符串的开头。而元字符`$`用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配`I am scq000`这个句子：\n\n```css\nI am scq000.\nI am scq000.\nI am scq000.\n```\n\n我们可以使用`/^I am scq000\\.$/m`这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。\n\n最后，总结一下：\n\n| 边界和标志 | 正则表达式 | 记忆方式                              |\n| ---------- | ---------- | ------------------------------------- |\n| 单词边界   | \\b         | **b**oundary                          |\n| 非单词边界 | \\B         | **not** **b**oundary                  |\n| 字符串开头 | ^          | 小**头尖尖**那么大个                  |\n| 字符串结尾 | $          | **终结**者，美国科幻电影，美元符$     |\n| 多行模式   | m标志      | **m**ultiple of lines                 |\n| 忽略大小写 | i标志      | **i**gnore case, case-**i**nsensitive |\n| 全局模式   | g标志      | **g**lobal                            |\n\n# 子表达式\n\n字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。\n\n从简单到复杂的正则表达式演变通常要采用**分组、回溯引用和逻辑处理**的思想。利用这三种规则，可以推演出无限复杂的正则表达式。\n\n## 分组\n\n其中分组体现在：所有以`(`和`)`元字符所包含的正则表达式被分为一组，每一个分组都是一个**子表达式**，它也是构成高级正则表达式的基础。如果只是使用简单的`(regex)`匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。\n\n## 回溯引用\n\n所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像`\\1`,`\\2`,....,其中`\\1`表示引用的第一个子表达式，`\\2`表示引用的第二个子表达式，以此类推。而`\\0`则表示整个表达式。\n\n假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？\n\n```csharp\nHello what what is the first thing, and I am am scq000.\n```\n\n利用回溯引用，我们可以很容易地写出`\\b(\\w+)\\s\\1`这样的正则。\n\n回溯引用在替换字符串中十分常用，语法上有些许区别，用`$1`,`$2`...来引用要被替换的字符串。下面以js代码作演示：\n\n```javascript\nvar str = 'abc abc 123';\nstr.replace(/(ab)c/g,'$1g');\n// 得到结果 'abg abg 123'\n```\n\n如果我们不想子表达式被引用，可以使用**非捕获**正则`(?:regex)`这样就可以避免浪费内存。\n\n```javascript\nvar str = 'scq000'.\nstr.replace(/(scq00)(?:0)/, '$1,$2')\n// 返回scq00,$2\n// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2\n```\n\n有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。\n\n### 前向查找\n\n前向查找(lookahead)是用来限制后缀的。凡是以`(?=regex)`包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如`happy happily`这两个单词，我想获得以`happ`开头的副词，那么就可以使用`happ(?=ily)`来匹配。如果我想过滤所有以`happ`开头的副词，那么也可以采用**负前向查找**的正则`happ(?!ily)`，就会匹配到`happy`单词的`happ`前缀。\n\n### 后向查找\n\n介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： `apple`和`people`都包含`ple`这个后缀，那么如果我只想找到`apple`的`ple`，该怎么做呢？我们可以通过限制`app`这个前缀，就能唯一确定`ple`这个单词了。\n\n```ruby\n/(?<=app)ple/\n```\n\n其中`(?<=regex)`的语法就是我们这里要介绍的后向查找。`regex`指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向**后**查找。另外一种限制匹配是利用`(?<!regex)` 语法，这里称为**负后向查找**。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找`apple`的`ple`也可以这么写成`/(?<!peo)ple`。\n\n需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子：\n\n```perl\n// 比如我想替换apple的ple为ply\nvar str = 'apple people';\nstr.split('').reverse().join('').replace(/elp(?=pa)/, 'ylp').split('').reverse().join('');\n```\n\n最后回顾一下这部分内容：\n\n| 回溯查找   | 正则                   | 记忆方式                                                            |\n| ---------- | ---------------------- | ------------------------------------------------------------------- |\n| 引用       | \\0,\\1,\\2 和 $0, $1, $2 | 转义+数字                                                           |\n| 非捕获组   | (?:)                   | 引用表达式(()), 本身不被消费(?),引用(:)                             |\n| 前向查找   | (?=)                   | 引用子表达式(())，本身不被消费(?), 正向的查找(=)                    |\n| 前向负查找 | (?!)                   | 引用子表达式(())，本身不被消费(?), 负向的查找(!)                    |\n| 后向查找   | (?<=)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=) |\n| 后向负查找 | (?<!)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!) |\n\n## 逻辑处理\n\n计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。\n\n在正则里面，默认的正则规则都是**与**的关系所以这里不讨论。\n\n而**非**关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用`^`这个元字符。在这里要着重记忆一下：**只有在`[`和`]`内部使用的`^`才表示非的关系**。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式`(?!regex)`或后向负查找子表达式`(?<!regex)`。\n\n或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用`(a|b)`这样的子表达式。\n\n| 逻辑关系 | 正则元字符  |\n| -------- | ----------- |\n| 与       | 无          |\n| 非       | [^regex]和! |\n| 或       | \\|          |\n\n# 总结\n\n对于正则来说，符号之抽象往往让很多程序员却步。针对不好记忆的特点，我通过分类和联想的方式努力让其变得有意义。我们先从一对一的单字符，再到多对多的子字符串介绍，然后通过分组、回溯引用和逻辑处理的方式来构建高级的正则表达式。\n\n转至 [正则表达式不要背](https://juejin.cn/post/6844903845227659271 )\n","source":"_posts/reg.md","raw":"---\ntitle: 正则表达式不要背\ndate: 2022-10-28 20:43:19\ntags: reg\n---\n\n![正则表达式不要背](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9df51b66af0~tplv-t2oaga2asx-zoom-crop-mark:3024:3024:3024:1702.awebp)\n\n正则表达式一直是困扰很多程序员的一门技术，当然也包括曾经的我。大多数时候我们在开发过程中要用到某些正则表达式的时候，都会打开谷歌或百度直接搜索然后拷贝粘贴。当下一次再遇到相同问题的时候，同样的场景又再来一遍。作为一门用途很广的技术，我相信深入理解正则表达式并能融会贯通是值得的。所以，希望这篇文章能帮助大家理清思路，搞懂正则表达式各种符号之间的内在联系，形成知识体系，当下次再遇到正则表达式的时候可以不借助搜索引擎，自己解决。\n\n# 正则表达式到底是什么\n\n正则表达式(Regular Expression)其实就是一门工具，**目的**是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种**用来描述规则的表达式**。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用[regexper.com](https://link.juejin.cn/?target=https%3A%2F%2Fregexper.com%2F)这个工具很好地可视化自己写的正则表达式:\n\n如`/\\d\\w+/`这个正则生成的状态机图:\n\n\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9d9357f691c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)\n\n\n\n对于具体的算法实现，大家如果感兴趣可以阅读《算法导论》。\n\n# 从字符出发\n\n我们学习一个系统化的知识，一定要从其基础构成来了解。正则表达式的基本**组成元素**可以分为：**字符和元字符**。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。利用这些元字符，才能构造出强大的表达式模式(pattern)。接下来，我们就来从这些基本单位出发，来学习一下如何构建正则表达式。\n\n## 单个字符\n\n最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在'apple'这个单词里找到‘a'这个字符，就直接用`/a/`这个正则就可以了。\n\n但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**`\\`**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：\n\n我想匹配`*`这个符号，由于`*`这个符号本身是个特殊字符，所以我要利用转义元字符`\\`来让它失去其本来的含义：\n\n```\n/\\*/\n```\n\n如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式：\n\n| 特殊字符   | 正则表达式 | 记忆方式                                     |\n| ---------- | ---------- | -------------------------------------------- |\n| 换行符     | \\n         | **n**ew line                                 |\n| 换页符     | \\f         | **f**orm feed                                |\n| 回车符     | \\r         | **r**eturn                                   |\n| 空白符     | \\s         | **s**pace                                    |\n| 制表符     | \\t         | **t**ab                                      |\n| 垂直制表符 | \\v         | **v**ertical tab                             |\n| 回退符     | [\\b]       | **b**ackspace,之所以使用[]符号是避免和\\b重复 |\n\n## 多个字符\n\n单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。\n\n在正则表达式里，集合的定义方式是使用中括号`[`和`]`。如`/[123]/`这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符`-`就可以用来表示区间范围，利用`/[0-9]/`就能匹配所有的数字, `/[a-z]/`则可以匹配所有的英文小写字母。\n\n即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式:\n\n| 匹配区间                                      | 正则表达式 | 记忆方式            |\n| --------------------------------------------- | ---------- | ------------------- |\n| 除了换行符之外的任何字符                      | .          | 句号,除了句子结束符 |\n| 单个数字, [0-9]                               | \\d         | **d**igit           |\n| 除了[0-9]                                     | \\D         | **not** **d**igit   |\n| 包括下划线在内的单个字符，[A-Za-z0-9_]        | \\w         | **w**ord            |\n| 非单字字符                                    | \\W         | **not** **w**ord    |\n| 匹配空白字符,包括空格、制表符、换页符和换行符 | \\s         | **s**pace           |\n| 匹配非空白字符                                | \\S         | **not** **s**pace   |\n\n# 循环与重复\n\n一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。\n\n## 0 | 1\n\n元字符`?`代表了匹配一个字符或0个字符。设想一下，如果你要匹配`color`和`colour`这两个单词，就需要同时保证`u`这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：`/colou?r/`。\n\n## >= 0\n\n元字符`*`用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。\n\n## >= 1\n\n元字符`+`适用于要匹配同个字符出现1次或多次的情况。\n\n## 特定次数\n\n在某些情况下，我们需要匹配特定的重复次数，元字符`{`和`}`用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就使用`/a{3}/`这个正则，或者说'a'我想匹配至少两次就是用`/a{2,}/`这个正则。\n\n以下是完整的语法：\n\n```arduino\n- {x}: x次\n\n- {min, max}： 介于min次到max次之间\n\n- {min, }: 至少min次\n\n- {0, max}： 至多max次\n```\n\n由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。\n\n| 匹配规则    | 元字符          | 联想方式                                                                                     |\n| ----------- | --------------- | -------------------------------------------------------------------------------------------- |\n| 0次或1次    | ?               | 且**问**,此事**有**还**无**                                                                  |\n| 0次或无数次 | *               | 宇宙洪荒,**辰宿**列张：宇宙伊始，从无到有，最后星宿布满星空                                  |\n| 1次或无数次 | +               | **一加**, +1                                                                                 |\n| 特定次数    | {x}, {min, max} | 可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界 |\n\n# 位置边界\n\n上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。\n\n## 单词边界\n\n单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：\n\n```sql\nThe cat scattered his food all over the room.\n```\n\n我想找到`cat`这个单词，但是如果只是使用`/cat/`这个正则，就会同时匹配到`cat`和`scattered`这两处文本。这时候我们就需要使用边界正则表达式`\\b`，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。\n\n上面的例子改写成`/\\bcat\\b/`这样就能匹配到`cat`这个单词了。\n\n## 字符串边界\n\n匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符`^`用来匹配字符串的开头。而元字符`$`用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配`I am scq000`这个句子：\n\n```css\nI am scq000.\nI am scq000.\nI am scq000.\n```\n\n我们可以使用`/^I am scq000\\.$/m`这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。\n\n最后，总结一下：\n\n| 边界和标志 | 正则表达式 | 记忆方式                              |\n| ---------- | ---------- | ------------------------------------- |\n| 单词边界   | \\b         | **b**oundary                          |\n| 非单词边界 | \\B         | **not** **b**oundary                  |\n| 字符串开头 | ^          | 小**头尖尖**那么大个                  |\n| 字符串结尾 | $          | **终结**者，美国科幻电影，美元符$     |\n| 多行模式   | m标志      | **m**ultiple of lines                 |\n| 忽略大小写 | i标志      | **i**gnore case, case-**i**nsensitive |\n| 全局模式   | g标志      | **g**lobal                            |\n\n# 子表达式\n\n字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。\n\n从简单到复杂的正则表达式演变通常要采用**分组、回溯引用和逻辑处理**的思想。利用这三种规则，可以推演出无限复杂的正则表达式。\n\n## 分组\n\n其中分组体现在：所有以`(`和`)`元字符所包含的正则表达式被分为一组，每一个分组都是一个**子表达式**，它也是构成高级正则表达式的基础。如果只是使用简单的`(regex)`匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。\n\n## 回溯引用\n\n所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像`\\1`,`\\2`,....,其中`\\1`表示引用的第一个子表达式，`\\2`表示引用的第二个子表达式，以此类推。而`\\0`则表示整个表达式。\n\n假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？\n\n```csharp\nHello what what is the first thing, and I am am scq000.\n```\n\n利用回溯引用，我们可以很容易地写出`\\b(\\w+)\\s\\1`这样的正则。\n\n回溯引用在替换字符串中十分常用，语法上有些许区别，用`$1`,`$2`...来引用要被替换的字符串。下面以js代码作演示：\n\n```javascript\nvar str = 'abc abc 123';\nstr.replace(/(ab)c/g,'$1g');\n// 得到结果 'abg abg 123'\n```\n\n如果我们不想子表达式被引用，可以使用**非捕获**正则`(?:regex)`这样就可以避免浪费内存。\n\n```javascript\nvar str = 'scq000'.\nstr.replace(/(scq00)(?:0)/, '$1,$2')\n// 返回scq00,$2\n// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2\n```\n\n有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。\n\n### 前向查找\n\n前向查找(lookahead)是用来限制后缀的。凡是以`(?=regex)`包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如`happy happily`这两个单词，我想获得以`happ`开头的副词，那么就可以使用`happ(?=ily)`来匹配。如果我想过滤所有以`happ`开头的副词，那么也可以采用**负前向查找**的正则`happ(?!ily)`，就会匹配到`happy`单词的`happ`前缀。\n\n### 后向查找\n\n介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： `apple`和`people`都包含`ple`这个后缀，那么如果我只想找到`apple`的`ple`，该怎么做呢？我们可以通过限制`app`这个前缀，就能唯一确定`ple`这个单词了。\n\n```ruby\n/(?<=app)ple/\n```\n\n其中`(?<=regex)`的语法就是我们这里要介绍的后向查找。`regex`指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向**后**查找。另外一种限制匹配是利用`(?<!regex)` 语法，这里称为**负后向查找**。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找`apple`的`ple`也可以这么写成`/(?<!peo)ple`。\n\n需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子：\n\n```perl\n// 比如我想替换apple的ple为ply\nvar str = 'apple people';\nstr.split('').reverse().join('').replace(/elp(?=pa)/, 'ylp').split('').reverse().join('');\n```\n\n最后回顾一下这部分内容：\n\n| 回溯查找   | 正则                   | 记忆方式                                                            |\n| ---------- | ---------------------- | ------------------------------------------------------------------- |\n| 引用       | \\0,\\1,\\2 和 $0, $1, $2 | 转义+数字                                                           |\n| 非捕获组   | (?:)                   | 引用表达式(()), 本身不被消费(?),引用(:)                             |\n| 前向查找   | (?=)                   | 引用子表达式(())，本身不被消费(?), 正向的查找(=)                    |\n| 前向负查找 | (?!)                   | 引用子表达式(())，本身不被消费(?), 负向的查找(!)                    |\n| 后向查找   | (?<=)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，正的查找(=) |\n| 后向负查找 | (?<!)                  | 引用子表达式(())，本身不被消费(?), 后向的(<，开口往后)，负的查找(!) |\n\n## 逻辑处理\n\n计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。\n\n在正则里面，默认的正则规则都是**与**的关系所以这里不讨论。\n\n而**非**关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用`^`这个元字符。在这里要着重记忆一下：**只有在`[`和`]`内部使用的`^`才表示非的关系**。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式`(?!regex)`或后向负查找子表达式`(?<!regex)`。\n\n或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用`(a|b)`这样的子表达式。\n\n| 逻辑关系 | 正则元字符  |\n| -------- | ----------- |\n| 与       | 无          |\n| 非       | [^regex]和! |\n| 或       | \\|          |\n\n# 总结\n\n对于正则来说，符号之抽象往往让很多程序员却步。针对不好记忆的特点，我通过分类和联想的方式努力让其变得有意义。我们先从一对一的单字符，再到多对多的子字符串介绍，然后通过分组、回溯引用和逻辑处理的方式来构建高级的正则表达式。\n\n转至 [正则表达式不要背](https://juejin.cn/post/6844903845227659271 )\n","slug":"reg","published":1,"updated":"2024-07-24T05:54:14.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2pw0006lyxx3s2c5q0i","content":"<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9df51b66af0~tplv-t2oaga2asx-zoom-crop-mark:3024:3024:3024:1702.awebp\" alt=\"正则表达式不要背\"></p>\n<p>正则表达式一直是困扰很多程序员的一门技术，当然也包括曾经的我。大多数时候我们在开发过程中要用到某些正则表达式的时候，都会打开谷歌或百度直接搜索然后拷贝粘贴。当下一次再遇到相同问题的时候，同样的场景又再来一遍。作为一门用途很广的技术，我相信深入理解正则表达式并能融会贯通是值得的。所以，希望这篇文章能帮助大家理清思路，搞懂正则表达式各种符号之间的内在联系，形成知识体系，当下次再遇到正则表达式的时候可以不借助搜索引擎，自己解决。</p>\n<h1 id=\"正则表达式到底是什么\"><a href=\"#正则表达式到底是什么\" class=\"headerlink\" title=\"正则表达式到底是什么\"></a>正则表达式到底是什么</h1><p>正则表达式(Regular Expression)其实就是一门工具，<strong>目的</strong>是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种<strong>用来描述规则的表达式</strong>。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用<a href=\"https://link.juejin.cn/?target=https://regexper.com/\">regexper.com</a>这个工具很好地可视化自己写的正则表达式:</p>\n<p>如<code>/\\d\\w+/</code>这个正则生成的状态机图:</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9d9357f691c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"img\"></p>\n<p>对于具体的算法实现，大家如果感兴趣可以阅读《算法导论》。</p>\n<h1 id=\"从字符出发\"><a href=\"#从字符出发\" class=\"headerlink\" title=\"从字符出发\"></a>从字符出发</h1><p>我们学习一个系统化的知识，一定要从其基础构成来了解。正则表达式的基本<strong>组成元素</strong>可以分为：<strong>字符和元字符</strong>。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。利用这些元字符，才能构造出强大的表达式模式(pattern)。接下来，我们就来从这些基本单位出发，来学习一下如何构建正则表达式。</p>\n<h2 id=\"单个字符\"><a href=\"#单个字符\" class=\"headerlink\" title=\"单个字符\"></a>单个字符</h2><p>最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在’apple’这个单词里找到‘a’这个字符，就直接用<code>/a/</code>这个正则就可以了。</p>\n<p>但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**<code>\\</code>**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：</p>\n<p>我想匹配<code>*</code>这个符号，由于<code>*</code>这个符号本身是个特殊字符，所以我要利用转义元字符<code>\\</code>来让它失去其本来的含义：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">/\\*/</span><br></code></pre></td></tr></table></figure>\n\n<p>如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式：</p>\n<table>\n<thead>\n<tr>\n<th>特殊字符</th>\n<th>正则表达式</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>换行符</td>\n<td>\\n</td>\n<td><strong>n</strong>ew line</td>\n</tr>\n<tr>\n<td>换页符</td>\n<td>\\f</td>\n<td><strong>f</strong>orm feed</td>\n</tr>\n<tr>\n<td>回车符</td>\n<td>\\r</td>\n<td><strong>r</strong>eturn</td>\n</tr>\n<tr>\n<td>空白符</td>\n<td>\\s</td>\n<td><strong>s</strong>pace</td>\n</tr>\n<tr>\n<td>制表符</td>\n<td>\\t</td>\n<td><strong>t</strong>ab</td>\n</tr>\n<tr>\n<td>垂直制表符</td>\n<td>\\v</td>\n<td><strong>v</strong>ertical tab</td>\n</tr>\n<tr>\n<td>回退符</td>\n<td>[\\b]</td>\n<td><strong>b</strong>ackspace,之所以使用[]符号是避免和\\b重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"多个字符\"><a href=\"#多个字符\" class=\"headerlink\" title=\"多个字符\"></a>多个字符</h2><p>单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。</p>\n<p>在正则表达式里，集合的定义方式是使用中括号<code>[</code>和<code>]</code>。如<code>/[123]/</code>这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符<code>-</code>就可以用来表示区间范围，利用<code>/[0-9]/</code>就能匹配所有的数字, <code>/[a-z]/</code>则可以匹配所有的英文小写字母。</p>\n<p>即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式:</p>\n<table>\n<thead>\n<tr>\n<th>匹配区间</th>\n<th>正则表达式</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>除了换行符之外的任何字符</td>\n<td>.</td>\n<td>句号,除了句子结束符</td>\n</tr>\n<tr>\n<td>单个数字, [0-9]</td>\n<td>\\d</td>\n<td><strong>d</strong>igit</td>\n</tr>\n<tr>\n<td>除了[0-9]</td>\n<td>\\D</td>\n<td><strong>not</strong> <strong>d</strong>igit</td>\n</tr>\n<tr>\n<td>包括下划线在内的单个字符，[A-Za-z0-9_]</td>\n<td>\\w</td>\n<td><strong>w</strong>ord</td>\n</tr>\n<tr>\n<td>非单字字符</td>\n<td>\\W</td>\n<td><strong>not</strong> <strong>w</strong>ord</td>\n</tr>\n<tr>\n<td>匹配空白字符,包括空格、制表符、换页符和换行符</td>\n<td>\\s</td>\n<td><strong>s</strong>pace</td>\n</tr>\n<tr>\n<td>匹配非空白字符</td>\n<td>\\S</td>\n<td><strong>not</strong> <strong>s</strong>pace</td>\n</tr>\n</tbody></table>\n<h1 id=\"循环与重复\"><a href=\"#循环与重复\" class=\"headerlink\" title=\"循环与重复\"></a>循环与重复</h1><p>一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。</p>\n<h2 id=\"0-1\"><a href=\"#0-1\" class=\"headerlink\" title=\"0 | 1\"></a>0 | 1</h2><p>元字符<code>?</code>代表了匹配一个字符或0个字符。设想一下，如果你要匹配<code>color</code>和<code>colour</code>这两个单词，就需要同时保证<code>u</code>这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：<code>/colou?r/</code>。</p>\n<h2 id=\"gt-x3D-0\"><a href=\"#gt-x3D-0\" class=\"headerlink\" title=\"&gt;&#x3D; 0\"></a>&gt;&#x3D; 0</h2><p>元字符<code>*</code>用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。</p>\n<h2 id=\"gt-x3D-1\"><a href=\"#gt-x3D-1\" class=\"headerlink\" title=\"&gt;&#x3D; 1\"></a>&gt;&#x3D; 1</h2><p>元字符<code>+</code>适用于要匹配同个字符出现1次或多次的情况。</p>\n<h2 id=\"特定次数\"><a href=\"#特定次数\" class=\"headerlink\" title=\"特定次数\"></a>特定次数</h2><p>在某些情况下，我们需要匹配特定的重复次数，元字符<code>&#123;</code>和<code>&#125;</code>用来给重复匹配设置精确的区间范围。如’a’我想匹配3次,那么我就使用<code>/a&#123;3&#125;/</code>这个正则，或者说’a’我想匹配至少两次就是用<code>/a&#123;2,&#125;/</code>这个正则。</p>\n<p>以下是完整的语法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">- &#123;x&#125;: x次<br><br>- &#123;min, max&#125;： 介于min次到max次之间<br><br>- &#123;min, &#125;: 至少min次<br><br>- &#123;<span class=\"hljs-number\">0</span>, max&#125;： 至多max次<br></code></pre></td></tr></table></figure>\n\n<p>由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。</p>\n<table>\n<thead>\n<tr>\n<th>匹配规则</th>\n<th>元字符</th>\n<th>联想方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0次或1次</td>\n<td>?</td>\n<td>且<strong>问</strong>,此事<strong>有</strong>还<strong>无</strong></td>\n</tr>\n<tr>\n<td>0次或无数次</td>\n<td>*</td>\n<td>宇宙洪荒,<strong>辰宿</strong>列张：宇宙伊始，从无到有，最后星宿布满星空</td>\n</tr>\n<tr>\n<td>1次或无数次</td>\n<td>+</td>\n<td><strong>一加</strong>, +1</td>\n</tr>\n<tr>\n<td>特定次数</td>\n<td>{x}, {min, max}</td>\n<td>可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界</td>\n</tr>\n</tbody></table>\n<h1 id=\"位置边界\"><a href=\"#位置边界\" class=\"headerlink\" title=\"位置边界\"></a>位置边界</h1><p>上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。</p>\n<h2 id=\"单词边界\"><a href=\"#单词边界\" class=\"headerlink\" title=\"单词边界\"></a>单词边界</h2><p>单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">The cat scattered his food <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">over</span> the room.<br></code></pre></td></tr></table></figure>\n\n<p>我想找到<code>cat</code>这个单词，但是如果只是使用<code>/cat/</code>这个正则，就会同时匹配到<code>cat</code>和<code>scattered</code>这两处文本。这时候我们就需要使用边界正则表达式<code>\\b</code>，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。</p>\n<p>上面的例子改写成<code>/\\bcat\\b/</code>这样就能匹配到<code>cat</code>这个单词了。</p>\n<h2 id=\"字符串边界\"><a href=\"#字符串边界\" class=\"headerlink\" title=\"字符串边界\"></a>字符串边界</h2><p>匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符<code>^</code>用来匹配字符串的开头。而元字符<code>$</code>用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配<code>I am scq000</code>这个句子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">I</span> am scq000.<br><span class=\"hljs-selector-tag\">I</span> am scq000.<br><span class=\"hljs-selector-tag\">I</span> am scq000.<br></code></pre></td></tr></table></figure>\n\n<p>我们可以使用<code>/^I am scq000\\.$/m</code>这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。</p>\n<p>最后，总结一下：</p>\n<table>\n<thead>\n<tr>\n<th>边界和标志</th>\n<th>正则表达式</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单词边界</td>\n<td>\\b</td>\n<td><strong>b</strong>oundary</td>\n</tr>\n<tr>\n<td>非单词边界</td>\n<td>\\B</td>\n<td><strong>not</strong> <strong>b</strong>oundary</td>\n</tr>\n<tr>\n<td>字符串开头</td>\n<td>^</td>\n<td>小<strong>头尖尖</strong>那么大个</td>\n</tr>\n<tr>\n<td>字符串结尾</td>\n<td>$</td>\n<td><strong>终结</strong>者，美国科幻电影，美元符$</td>\n</tr>\n<tr>\n<td>多行模式</td>\n<td>m标志</td>\n<td><strong>m</strong>ultiple of lines</td>\n</tr>\n<tr>\n<td>忽略大小写</td>\n<td>i标志</td>\n<td><strong>i</strong>gnore case, case-<strong>i</strong>nsensitive</td>\n</tr>\n<tr>\n<td>全局模式</td>\n<td>g标志</td>\n<td><strong>g</strong>lobal</td>\n</tr>\n</tbody></table>\n<h1 id=\"子表达式\"><a href=\"#子表达式\" class=\"headerlink\" title=\"子表达式\"></a>子表达式</h1><p>字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。</p>\n<p>从简单到复杂的正则表达式演变通常要采用<strong>分组、回溯引用和逻辑处理</strong>的思想。利用这三种规则，可以推演出无限复杂的正则表达式。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>其中分组体现在：所有以<code>(</code>和<code>)</code>元字符所包含的正则表达式被分为一组，每一个分组都是一个<strong>子表达式</strong>，它也是构成高级正则表达式的基础。如果只是使用简单的<code>(regex)</code>匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。</p>\n<h2 id=\"回溯引用\"><a href=\"#回溯引用\" class=\"headerlink\" title=\"回溯引用\"></a>回溯引用</h2><p>所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像<code>\\1</code>,<code>\\2</code>,….,其中<code>\\1</code>表示引用的第一个子表达式，<code>\\2</code>表示引用的第二个子表达式，以此类推。而<code>\\0</code>则表示整个表达式。</p>\n<p>假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\">Hello what what <span class=\"hljs-keyword\">is</span> the first thing, <span class=\"hljs-keyword\">and</span> I am am scq000.<br></code></pre></td></tr></table></figure>\n\n<p>利用回溯引用，我们可以很容易地写出<code>\\b(\\w+)\\s\\1</code>这样的正则。</p>\n<p>回溯引用在替换字符串中十分常用，语法上有些许区别，用<code>$1</code>,<code>$2</code>…来引用要被替换的字符串。下面以js代码作演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">&#x27;abc abc 123&#x27;</span>;<br>str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(ab)c/g</span>,<span class=\"hljs-string\">&#x27;$1g&#x27;</span>);<br><span class=\"hljs-comment\">// 得到结果 &#x27;abg abg 123&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果我们不想子表达式被引用，可以使用<strong>非捕获</strong>正则<code>(?:regex)</code>这样就可以避免浪费内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">&#x27;scq000&#x27;</span>.<br>str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(scq00)(?:0)/</span>, <span class=\"hljs-string\">&#x27;$1,$2&#x27;</span>)<br><span class=\"hljs-comment\">// 返回scq00,$2</span><br><span class=\"hljs-comment\">// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2</span><br></code></pre></td></tr></table></figure>\n\n<p>有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。</p>\n<h3 id=\"前向查找\"><a href=\"#前向查找\" class=\"headerlink\" title=\"前向查找\"></a>前向查找</h3><p>前向查找(lookahead)是用来限制后缀的。凡是以<code>(?=regex)</code>包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如<code>happy happily</code>这两个单词，我想获得以<code>happ</code>开头的副词，那么就可以使用<code>happ(?=ily)</code>来匹配。如果我想过滤所有以<code>happ</code>开头的副词，那么也可以采用<strong>负前向查找</strong>的正则<code>happ(?!ily)</code>，就会匹配到<code>happy</code>单词的<code>happ</code>前缀。</p>\n<h3 id=\"后向查找\"><a href=\"#后向查找\" class=\"headerlink\" title=\"后向查找\"></a>后向查找</h3><p>介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： <code>apple</code>和<code>people</code>都包含<code>ple</code>这个后缀，那么如果我只想找到<code>apple</code>的<code>ple</code>，该怎么做呢？我们可以通过限制<code>app</code>这个前缀，就能唯一确定<code>ple</code>这个单词了。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">/(<span class=\"hljs-string\">?&lt;</span>=app)ple/<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>(?&lt;=regex)</code>的语法就是我们这里要介绍的后向查找。<code>regex</code>指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向<strong>后</strong>查找。另外一种限制匹配是利用<code>(?&lt;!regex)</code> 语法，这里称为<strong>负后向查找</strong>。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找<code>apple</code>的<code>ple</code>也可以这么写成<code>/(?&lt;!peo)ple</code>。</p>\n<p>需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">// 比如我想替换apple的ple为ply<br>var str = <span class=\"hljs-string\">&#x27;apple people&#x27;</span>;<br>str.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-keyword\">reverse</span>().join(<span class=\"hljs-string\">&#x27;&#x27;</span>).replace(<span class=\"hljs-regexp\">/elp(?=pa)/</span>, <span class=\"hljs-string\">&#x27;ylp&#x27;</span>).<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-keyword\">reverse</span>().join(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>最后回顾一下这部分内容：</p>\n<table>\n<thead>\n<tr>\n<th>回溯查找</th>\n<th>正则</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>引用</td>\n<td>\\0,\\1,\\2 和 $0, $1, $2</td>\n<td>转义+数字</td>\n</tr>\n<tr>\n<td>非捕获组</td>\n<td>(?:)</td>\n<td>引用表达式(()), 本身不被消费(?),引用(:)</td>\n</tr>\n<tr>\n<td>前向查找</td>\n<td>(?&#x3D;)</td>\n<td>引用子表达式(())，本身不被消费(?), 正向的查找(&#x3D;)</td>\n</tr>\n<tr>\n<td>前向负查找</td>\n<td>(?!)</td>\n<td>引用子表达式(())，本身不被消费(?), 负向的查找(!)</td>\n</tr>\n<tr>\n<td>后向查找</td>\n<td>(?&lt;&#x3D;)</td>\n<td>引用子表达式(())，本身不被消费(?), 后向的(&lt;，开口往后)，正的查找(&#x3D;)</td>\n</tr>\n<tr>\n<td>后向负查找</td>\n<td>(?&lt;!)</td>\n<td>引用子表达式(())，本身不被消费(?), 后向的(&lt;，开口往后)，负的查找(!)</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑处理\"><a href=\"#逻辑处理\" class=\"headerlink\" title=\"逻辑处理\"></a>逻辑处理</h2><p>计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。</p>\n<p>在正则里面，默认的正则规则都是<strong>与</strong>的关系所以这里不讨论。</p>\n<p>而<strong>非</strong>关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用<code>^</code>这个元字符。在这里要着重记忆一下：<strong>只有在<code>[</code>和<code>]</code>内部使用的<code>^</code>才表示非的关系</strong>。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式<code>(?!regex)</code>或后向负查找子表达式<code>(?&lt;!regex)</code>。</p>\n<p>或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用<code>(a|b)</code>这样的子表达式。</p>\n<table>\n<thead>\n<tr>\n<th>逻辑关系</th>\n<th>正则元字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>与</td>\n<td>无</td>\n</tr>\n<tr>\n<td>非</td>\n<td>[^regex]和!</td>\n</tr>\n<tr>\n<td>或</td>\n<td>|</td>\n</tr>\n</tbody></table>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于正则来说，符号之抽象往往让很多程序员却步。针对不好记忆的特点，我通过分类和联想的方式努力让其变得有意义。我们先从一对一的单字符，再到多对多的子字符串介绍，然后通过分组、回溯引用和逻辑处理的方式来构建高级的正则表达式。</p>\n<p>转至 <a href=\"https://juejin.cn/post/6844903845227659271\">正则表达式不要背</a></p>\n","site":{"data":{}},"wordcount":5462,"excerpt":"","more":"<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9df51b66af0~tplv-t2oaga2asx-zoom-crop-mark:3024:3024:3024:1702.awebp\" alt=\"正则表达式不要背\"></p>\n<p>正则表达式一直是困扰很多程序员的一门技术，当然也包括曾经的我。大多数时候我们在开发过程中要用到某些正则表达式的时候，都会打开谷歌或百度直接搜索然后拷贝粘贴。当下一次再遇到相同问题的时候，同样的场景又再来一遍。作为一门用途很广的技术，我相信深入理解正则表达式并能融会贯通是值得的。所以，希望这篇文章能帮助大家理清思路，搞懂正则表达式各种符号之间的内在联系，形成知识体系，当下次再遇到正则表达式的时候可以不借助搜索引擎，自己解决。</p>\n<h1 id=\"正则表达式到底是什么\"><a href=\"#正则表达式到底是什么\" class=\"headerlink\" title=\"正则表达式到底是什么\"></a>正则表达式到底是什么</h1><p>正则表达式(Regular Expression)其实就是一门工具，<strong>目的</strong>是为了字符串模式匹配，从而实现搜索和替换功能。它起源于上个20世纪50年代科学家在数学领域做的一些研究工作，后来才被引入到计算机领域中。从它的命名我们可以知道，它是一种<strong>用来描述规则的表达式</strong>。而它的底层原理也十分简单，就是使用状态机的思想进行模式匹配。大家可以利用<a href=\"https://link.juejin.cn/?target=https://regexper.com/\">regexper.com</a>这个工具很好地可视化自己写的正则表达式:</p>\n<p>如<code>/\\d\\w+/</code>这个正则生成的状态机图:</p>\n<p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/16/16abe9d9357f691c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"img\"></p>\n<p>对于具体的算法实现，大家如果感兴趣可以阅读《算法导论》。</p>\n<h1 id=\"从字符出发\"><a href=\"#从字符出发\" class=\"headerlink\" title=\"从字符出发\"></a>从字符出发</h1><p>我们学习一个系统化的知识，一定要从其基础构成来了解。正则表达式的基本<strong>组成元素</strong>可以分为：<strong>字符和元字符</strong>。字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。利用这些元字符，才能构造出强大的表达式模式(pattern)。接下来，我们就来从这些基本单位出发，来学习一下如何构建正则表达式。</p>\n<h2 id=\"单个字符\"><a href=\"#单个字符\" class=\"headerlink\" title=\"单个字符\"></a>单个字符</h2><p>最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在’apple’这个单词里找到‘a’这个字符，就直接用<code>/a/</code>这个正则就可以了。</p>\n<p>但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**<code>\\</code>**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子：</p>\n<p>我想匹配<code>*</code>这个符号，由于<code>*</code>这个符号本身是个特殊字符，所以我要利用转义元字符<code>\\</code>来让它失去其本来的含义：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">/\\*/</span><br></code></pre></td></tr></table></figure>\n\n<p>如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式：</p>\n<table>\n<thead>\n<tr>\n<th>特殊字符</th>\n<th>正则表达式</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>换行符</td>\n<td>\\n</td>\n<td><strong>n</strong>ew line</td>\n</tr>\n<tr>\n<td>换页符</td>\n<td>\\f</td>\n<td><strong>f</strong>orm feed</td>\n</tr>\n<tr>\n<td>回车符</td>\n<td>\\r</td>\n<td><strong>r</strong>eturn</td>\n</tr>\n<tr>\n<td>空白符</td>\n<td>\\s</td>\n<td><strong>s</strong>pace</td>\n</tr>\n<tr>\n<td>制表符</td>\n<td>\\t</td>\n<td><strong>t</strong>ab</td>\n</tr>\n<tr>\n<td>垂直制表符</td>\n<td>\\v</td>\n<td><strong>v</strong>ertical tab</td>\n</tr>\n<tr>\n<td>回退符</td>\n<td>[\\b]</td>\n<td><strong>b</strong>ackspace,之所以使用[]符号是避免和\\b重复</td>\n</tr>\n</tbody></table>\n<h2 id=\"多个字符\"><a href=\"#多个字符\" class=\"headerlink\" title=\"多个字符\"></a>多个字符</h2><p>单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。</p>\n<p>在正则表达式里，集合的定义方式是使用中括号<code>[</code>和<code>]</code>。如<code>/[123]/</code>这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符<code>-</code>就可以用来表示区间范围，利用<code>/[0-9]/</code>就能匹配所有的数字, <code>/[a-z]/</code>则可以匹配所有的英文小写字母。</p>\n<p>即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式:</p>\n<table>\n<thead>\n<tr>\n<th>匹配区间</th>\n<th>正则表达式</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>除了换行符之外的任何字符</td>\n<td>.</td>\n<td>句号,除了句子结束符</td>\n</tr>\n<tr>\n<td>单个数字, [0-9]</td>\n<td>\\d</td>\n<td><strong>d</strong>igit</td>\n</tr>\n<tr>\n<td>除了[0-9]</td>\n<td>\\D</td>\n<td><strong>not</strong> <strong>d</strong>igit</td>\n</tr>\n<tr>\n<td>包括下划线在内的单个字符，[A-Za-z0-9_]</td>\n<td>\\w</td>\n<td><strong>w</strong>ord</td>\n</tr>\n<tr>\n<td>非单字字符</td>\n<td>\\W</td>\n<td><strong>not</strong> <strong>w</strong>ord</td>\n</tr>\n<tr>\n<td>匹配空白字符,包括空格、制表符、换页符和换行符</td>\n<td>\\s</td>\n<td><strong>s</strong>pace</td>\n</tr>\n<tr>\n<td>匹配非空白字符</td>\n<td>\\S</td>\n<td><strong>not</strong> <strong>s</strong>pace</td>\n</tr>\n</tbody></table>\n<h1 id=\"循环与重复\"><a href=\"#循环与重复\" class=\"headerlink\" title=\"循环与重复\"></a>循环与重复</h1><p>一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。</p>\n<h2 id=\"0-1\"><a href=\"#0-1\" class=\"headerlink\" title=\"0 | 1\"></a>0 | 1</h2><p>元字符<code>?</code>代表了匹配一个字符或0个字符。设想一下，如果你要匹配<code>color</code>和<code>colour</code>这两个单词，就需要同时保证<code>u</code>这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：<code>/colou?r/</code>。</p>\n<h2 id=\"gt-x3D-0\"><a href=\"#gt-x3D-0\" class=\"headerlink\" title=\"&gt;&#x3D; 0\"></a>&gt;&#x3D; 0</h2><p>元字符<code>*</code>用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。</p>\n<h2 id=\"gt-x3D-1\"><a href=\"#gt-x3D-1\" class=\"headerlink\" title=\"&gt;&#x3D; 1\"></a>&gt;&#x3D; 1</h2><p>元字符<code>+</code>适用于要匹配同个字符出现1次或多次的情况。</p>\n<h2 id=\"特定次数\"><a href=\"#特定次数\" class=\"headerlink\" title=\"特定次数\"></a>特定次数</h2><p>在某些情况下，我们需要匹配特定的重复次数，元字符<code>&#123;</code>和<code>&#125;</code>用来给重复匹配设置精确的区间范围。如’a’我想匹配3次,那么我就使用<code>/a&#123;3&#125;/</code>这个正则，或者说’a’我想匹配至少两次就是用<code>/a&#123;2,&#125;/</code>这个正则。</p>\n<p>以下是完整的语法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">- &#123;x&#125;: x次<br><br>- &#123;min, max&#125;： 介于min次到max次之间<br><br>- &#123;min, &#125;: 至少min次<br><br>- &#123;<span class=\"hljs-number\">0</span>, max&#125;： 至多max次<br></code></pre></td></tr></table></figure>\n\n<p>由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。</p>\n<table>\n<thead>\n<tr>\n<th>匹配规则</th>\n<th>元字符</th>\n<th>联想方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0次或1次</td>\n<td>?</td>\n<td>且<strong>问</strong>,此事<strong>有</strong>还<strong>无</strong></td>\n</tr>\n<tr>\n<td>0次或无数次</td>\n<td>*</td>\n<td>宇宙洪荒,<strong>辰宿</strong>列张：宇宙伊始，从无到有，最后星宿布满星空</td>\n</tr>\n<tr>\n<td>1次或无数次</td>\n<td>+</td>\n<td><strong>一加</strong>, +1</td>\n</tr>\n<tr>\n<td>特定次数</td>\n<td>{x}, {min, max}</td>\n<td>可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界</td>\n</tr>\n</tbody></table>\n<h1 id=\"位置边界\"><a href=\"#位置边界\" class=\"headerlink\" title=\"位置边界\"></a>位置边界</h1><p>上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。</p>\n<h2 id=\"单词边界\"><a href=\"#单词边界\" class=\"headerlink\" title=\"单词边界\"></a>单词边界</h2><p>单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">The cat scattered his food <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">over</span> the room.<br></code></pre></td></tr></table></figure>\n\n<p>我想找到<code>cat</code>这个单词，但是如果只是使用<code>/cat/</code>这个正则，就会同时匹配到<code>cat</code>和<code>scattered</code>这两处文本。这时候我们就需要使用边界正则表达式<code>\\b</code>，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。</p>\n<p>上面的例子改写成<code>/\\bcat\\b/</code>这样就能匹配到<code>cat</code>这个单词了。</p>\n<h2 id=\"字符串边界\"><a href=\"#字符串边界\" class=\"headerlink\" title=\"字符串边界\"></a>字符串边界</h2><p>匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符<code>^</code>用来匹配字符串的开头。而元字符<code>$</code>用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配<code>I am scq000</code>这个句子：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">I</span> am scq000.<br><span class=\"hljs-selector-tag\">I</span> am scq000.<br><span class=\"hljs-selector-tag\">I</span> am scq000.<br></code></pre></td></tr></table></figure>\n\n<p>我们可以使用<code>/^I am scq000\\.$/m</code>这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。</p>\n<p>最后，总结一下：</p>\n<table>\n<thead>\n<tr>\n<th>边界和标志</th>\n<th>正则表达式</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单词边界</td>\n<td>\\b</td>\n<td><strong>b</strong>oundary</td>\n</tr>\n<tr>\n<td>非单词边界</td>\n<td>\\B</td>\n<td><strong>not</strong> <strong>b</strong>oundary</td>\n</tr>\n<tr>\n<td>字符串开头</td>\n<td>^</td>\n<td>小<strong>头尖尖</strong>那么大个</td>\n</tr>\n<tr>\n<td>字符串结尾</td>\n<td>$</td>\n<td><strong>终结</strong>者，美国科幻电影，美元符$</td>\n</tr>\n<tr>\n<td>多行模式</td>\n<td>m标志</td>\n<td><strong>m</strong>ultiple of lines</td>\n</tr>\n<tr>\n<td>忽略大小写</td>\n<td>i标志</td>\n<td><strong>i</strong>gnore case, case-<strong>i</strong>nsensitive</td>\n</tr>\n<tr>\n<td>全局模式</td>\n<td>g标志</td>\n<td><strong>g</strong>lobal</td>\n</tr>\n</tbody></table>\n<h1 id=\"子表达式\"><a href=\"#子表达式\" class=\"headerlink\" title=\"子表达式\"></a>子表达式</h1><p>字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。</p>\n<p>从简单到复杂的正则表达式演变通常要采用<strong>分组、回溯引用和逻辑处理</strong>的思想。利用这三种规则，可以推演出无限复杂的正则表达式。</p>\n<h2 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h2><p>其中分组体现在：所有以<code>(</code>和<code>)</code>元字符所包含的正则表达式被分为一组，每一个分组都是一个<strong>子表达式</strong>，它也是构成高级正则表达式的基础。如果只是使用简单的<code>(regex)</code>匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。</p>\n<h2 id=\"回溯引用\"><a href=\"#回溯引用\" class=\"headerlink\" title=\"回溯引用\"></a>回溯引用</h2><p>所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像<code>\\1</code>,<code>\\2</code>,….,其中<code>\\1</code>表示引用的第一个子表达式，<code>\\2</code>表示引用的第二个子表达式，以此类推。而<code>\\0</code>则表示整个表达式。</p>\n<p>假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\">Hello what what <span class=\"hljs-keyword\">is</span> the first thing, <span class=\"hljs-keyword\">and</span> I am am scq000.<br></code></pre></td></tr></table></figure>\n\n<p>利用回溯引用，我们可以很容易地写出<code>\\b(\\w+)\\s\\1</code>这样的正则。</p>\n<p>回溯引用在替换字符串中十分常用，语法上有些许区别，用<code>$1</code>,<code>$2</code>…来引用要被替换的字符串。下面以js代码作演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">&#x27;abc abc 123&#x27;</span>;<br>str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(ab)c/g</span>,<span class=\"hljs-string\">&#x27;$1g&#x27;</span>);<br><span class=\"hljs-comment\">// 得到结果 &#x27;abg abg 123&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果我们不想子表达式被引用，可以使用<strong>非捕获</strong>正则<code>(?:regex)</code>这样就可以避免浪费内存。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">&#x27;scq000&#x27;</span>.<br>str.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/(scq00)(?:0)/</span>, <span class=\"hljs-string\">&#x27;$1,$2&#x27;</span>)<br><span class=\"hljs-comment\">// 返回scq00,$2</span><br><span class=\"hljs-comment\">// 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2</span><br></code></pre></td></tr></table></figure>\n\n<p>有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。</p>\n<h3 id=\"前向查找\"><a href=\"#前向查找\" class=\"headerlink\" title=\"前向查找\"></a>前向查找</h3><p>前向查找(lookahead)是用来限制后缀的。凡是以<code>(?=regex)</code>包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如<code>happy happily</code>这两个单词，我想获得以<code>happ</code>开头的副词，那么就可以使用<code>happ(?=ily)</code>来匹配。如果我想过滤所有以<code>happ</code>开头的副词，那么也可以采用<strong>负前向查找</strong>的正则<code>happ(?!ily)</code>，就会匹配到<code>happy</code>单词的<code>happ</code>前缀。</p>\n<h3 id=\"后向查找\"><a href=\"#后向查找\" class=\"headerlink\" title=\"后向查找\"></a>后向查找</h3><p>介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： <code>apple</code>和<code>people</code>都包含<code>ple</code>这个后缀，那么如果我只想找到<code>apple</code>的<code>ple</code>，该怎么做呢？我们可以通过限制<code>app</code>这个前缀，就能唯一确定<code>ple</code>这个单词了。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">/(<span class=\"hljs-string\">?&lt;</span>=app)ple/<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>(?&lt;=regex)</code>的语法就是我们这里要介绍的后向查找。<code>regex</code>指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向<strong>后</strong>查找。另外一种限制匹配是利用<code>(?&lt;!regex)</code> 语法，这里称为<strong>负后向查找</strong>。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找<code>apple</code>的<code>ple</code>也可以这么写成<code>/(?&lt;!peo)ple</code>。</p>\n<p>需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">// 比如我想替换apple的ple为ply<br>var str = <span class=\"hljs-string\">&#x27;apple people&#x27;</span>;<br>str.<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-keyword\">reverse</span>().join(<span class=\"hljs-string\">&#x27;&#x27;</span>).replace(<span class=\"hljs-regexp\">/elp(?=pa)/</span>, <span class=\"hljs-string\">&#x27;ylp&#x27;</span>).<span class=\"hljs-keyword\">split</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>).<span class=\"hljs-keyword\">reverse</span>().join(<span class=\"hljs-string\">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>最后回顾一下这部分内容：</p>\n<table>\n<thead>\n<tr>\n<th>回溯查找</th>\n<th>正则</th>\n<th>记忆方式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>引用</td>\n<td>\\0,\\1,\\2 和 $0, $1, $2</td>\n<td>转义+数字</td>\n</tr>\n<tr>\n<td>非捕获组</td>\n<td>(?:)</td>\n<td>引用表达式(()), 本身不被消费(?),引用(:)</td>\n</tr>\n<tr>\n<td>前向查找</td>\n<td>(?&#x3D;)</td>\n<td>引用子表达式(())，本身不被消费(?), 正向的查找(&#x3D;)</td>\n</tr>\n<tr>\n<td>前向负查找</td>\n<td>(?!)</td>\n<td>引用子表达式(())，本身不被消费(?), 负向的查找(!)</td>\n</tr>\n<tr>\n<td>后向查找</td>\n<td>(?&lt;&#x3D;)</td>\n<td>引用子表达式(())，本身不被消费(?), 后向的(&lt;，开口往后)，正的查找(&#x3D;)</td>\n</tr>\n<tr>\n<td>后向负查找</td>\n<td>(?&lt;!)</td>\n<td>引用子表达式(())，本身不被消费(?), 后向的(&lt;，开口往后)，负的查找(!)</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑处理\"><a href=\"#逻辑处理\" class=\"headerlink\" title=\"逻辑处理\"></a>逻辑处理</h2><p>计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。</p>\n<p>在正则里面，默认的正则规则都是<strong>与</strong>的关系所以这里不讨论。</p>\n<p>而<strong>非</strong>关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用<code>^</code>这个元字符。在这里要着重记忆一下：<strong>只有在<code>[</code>和<code>]</code>内部使用的<code>^</code>才表示非的关系</strong>。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式<code>(?!regex)</code>或后向负查找子表达式<code>(?&lt;!regex)</code>。</p>\n<p>或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用<code>(a|b)</code>这样的子表达式。</p>\n<table>\n<thead>\n<tr>\n<th>逻辑关系</th>\n<th>正则元字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>与</td>\n<td>无</td>\n</tr>\n<tr>\n<td>非</td>\n<td>[^regex]和!</td>\n</tr>\n<tr>\n<td>或</td>\n<td>|</td>\n</tr>\n</tbody></table>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于正则来说，符号之抽象往往让很多程序员却步。针对不好记忆的特点，我通过分类和联想的方式努力让其变得有意义。我们先从一对一的单字符，再到多对多的子字符串介绍，然后通过分组、回溯引用和逻辑处理的方式来构建高级的正则表达式。</p>\n<p>转至 <a href=\"https://juejin.cn/post/6844903845227659271\">正则表达式不要背</a></p>\n"},{"title":"常用shell命令","date":"2022-05-02T11:07:48.000Z","_content":"\n# 常用shell命令\n## 1、ls：查看文件\n\n常用参数：\n\n-l 显示详细的文件信息\n\n-a 显示隐藏文件\n\n## 2、cd：切换工作目录\n\ncd ~ 切换到当前用户的home目录\n\ncd - 退回切换前的目录\n\ncd .. 返回上一级目录\n\ncd  不指定目录，切换到当前用户的home目录\n\n## 3、pwd：显示用户当前目录\n\n## 4、mkdir：创建目录\n\n常用参数：\n\n-p 若指定路径的父目录不存在则一并创建\n\n## 5、cp：复制\n\n常用参数：\n\n-r 递归复制，复制的数据会使用新的时间戳等信息\n\n-f 强制复制\n\n-a 递归复制，保留原文件属性的前提下复制文件\n\n## 6、rm：删除\n\n常用参数：\n\n-r删除目录及其子目录下的所有内容\n\n-f 强制删除\n\n-i 删除文件前先询问确认\n\n## 7、mv：移动\n\nmv 1.txt 2.txt  将1.txt重命名为2.txt\n\n## 8、du：显示目录所占用的磁盘空间\n\n常用参数：\n\n-s 只显示当前目录的大小,单位kb\n\n-h 以K M G为单位，提高可读性\n\n--max-depth=1 只查看当前目录下的子目录大小\n\n## 9、cat：查看文件内容\n\ncat file1 file2 > file3 将file1和file2的内容结合起来写到file3中，file3以前的内容被清空\n\ncat file1 file2 >> file3 将file1和file2的内容结合起来追加到file3中\n\n## 10、echo：输出字符串\n\n常用参数：\n\n-n 显示字符串时在最后自动换行\n\n-e 支持转义字符\n\n和cat一样可以用重定向符“>”和“>>”将输出的内容写到文件\n\n## 11、more,less：分页查看文件\n\n常用动作命令：\n\n回车键\n向下移动一行\n\ny  向上移动一行\n\n空格键\n向下滚动一屏\n\nb  向上滚动一屏\n\nd  向下滚动半屏\n\nu  向上滚动半屏\n\nq  退出\n\nless还可以用方向键控制往上或往下滚动文件，more不行\n\n## 12、grep：搜索文本\n\n常用参数：\n\n-i 忽略大小写\n\n-n 显示行号\n\n在shell脚本中使用时，搜索成功返回0，不成功返回1，搜索的文件不存在返回2\n\n## 13、find：搜索文件\n\n常用参数：\n\n-name 按照名字查找\n\n-type 按照文件类型查找（f一般文件  d目录  l 链接文件）\n\n-size 按照文件大小查找\n\n## 14、ln：创建链接\n\n常用参数：\n\n-s 创建软链接（创建链接的时候尽量用绝对路径）\n\nln -s  /home/nfs/C6DAI  /home/yangqing/C6DAI\n\n## 15、mount：挂载\n\nmount -t nfs -o nolock,tcp\n192.168.150.21:/home/yangqing/D53.5  \n/usr/local\n\nmount 不加任何参数是查看当前挂载状态\n\numount \n/usr/local 卸载\n\n## 16、chmod：权限设置\n\n常用参数：\n\n-R 递归修改权限\n\nu:所有者权限  g:所属组权限  o:其他用户权限   a:全部用户\n\nr: 读权限，数字表示为4   w:写权限，数字表示为2   x:执行权限，数字表示为1\n\nchmod 777 file  等同于 chmod a=rwx file  所有用户有可读可写可执行权限\n\n## 17、kill：删除执行中的程序\n\nkill -9 pid \n彻底杀死程序\n\nkillall * 杀死当前目录所有程序\n\n## 18、sed：编辑文本\n\n常用参数：\n\n-i 直接编辑源文件\n\n-e 执行多个命令   sed ‘/www/d;/fff/d’\n\n指令动作：\n\na 新增，当前行的后一行新增一行\n\ni 插入，当前行的前一行插入新的一行\n\nd 删除   sed ‘3,$d’ file  删除第3到最后一行\n\nc 替换，以行为单位替换   sed '2,5c No 2-5 number' file  第2-5行整体替换No 2-5\nnumber\n\ns 字符串替换  sed ‘s/home/root/g’ file    将文件中所有home替换为root\n\n## 19、tar：压缩\n\n常用参数：\n\n-c 建立压缩文件\n\n-x 解压\n\n-t 查看内容\n\n-v 显示所有过程\n\n-z 用gzip压缩解压\n\n-j 用bzip2压缩解压\n\n-f 使用文件名（必须有的参数且是最后一个参数）\n\n解压：\n\n*.tar      \n tar -xvf\n\n*.tar.gz      tar -xzf\n\n*tar.bz2    \ntar -xjf   \n\n## 20、vi：编辑器\n\n一般模式：\n\ni 切换到编辑模式\n\n：切换到底线命令模式\n\nPage Down/Page Up 向上/向下移动一页\n\nHome/End 移动到这行的最前面/最后面\n\nG 移动到这个文档的最后一行\n\ngg 移动到这个文档的第一行\n\n数字+Enter  光标向下移动n行\n\n/word 在文档内搜索word字符串\n\ndd  删除光标所在那一整行\n\nyy  复制光标所在的那一行\n\nu 复原前一个动作\n\nctrl + r 重做一次上一个动作\n\n## 21、shell脚本内if判断条件\n\n字符串比较：str1 = str2   str1 != str2\n\n数字比较： -eq 相等      -ne不相等    -gt 大于  \n\n-ge大于等于   -lt 小于      -le小于等于\n\n目录文件：-d 该目录存在  -f  该文件存在\n\n逻辑判断：-a 与      -o 或      ！非\n\n或者使用&& ||逻辑符，但是逻辑符写在中括号之间\n\n## 22、命令行快捷键\n\nctrl + u 删除光标前的所有字符\n\nctrl + k \n删除光标后的所有字符\n\nctrl + a 移动光标到行首\n\nctrl + e 移动光标到行尾\n\nctrl + insert 复制\n\nshift + insert 粘贴\n## 23. touch 命令\n\ntouch 命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。\n\ntouch test.txt 创建不存在的文件test.txt\n## 23. vi 命令\n\nvi是工作在字符终端环境下的全屏幕编辑器\n\n- 命令模式\n  - i 切换到输入模式，以输入字符。\n  - x 删除当前光标所在处的字符。\n  - : 切换到底线命令模式，以在最底一行输入命令。\n- 输入模式\n  - 字符按键以及Shift组合，输入字符\n  - ENTER，回车键，换行\n  - BACK SPACE，退格键，删除光标前一个字符\n  - DEL，删除键，删除光标后一个字符\n  - 方向键，在文本中移动光标\n  - HOME/END，移动光标到行首/行尾\n  - Page Up/Page Down，上/下翻页\n  - Insert，切换光标为输入/替换模式，光标将变成竖线/下划线\n  - ESC，退出输入模式，切换到命令模式\n- 末行模式\n  - q 退出程序\n  - q! 不保存并退出\n  - wq 保存文件并退出\n\n## 24. ssh-key\n生成ssh密钥\n\n```\nssh-keygen -t rsa -C \"你的邮箱\"\n```\n","source":"_posts/shellCommand.md","raw":"---\ntitle: 常用shell命令\ndate: 2022-05-02 19:07:48\ntags:\n---\n\n# 常用shell命令\n## 1、ls：查看文件\n\n常用参数：\n\n-l 显示详细的文件信息\n\n-a 显示隐藏文件\n\n## 2、cd：切换工作目录\n\ncd ~ 切换到当前用户的home目录\n\ncd - 退回切换前的目录\n\ncd .. 返回上一级目录\n\ncd  不指定目录，切换到当前用户的home目录\n\n## 3、pwd：显示用户当前目录\n\n## 4、mkdir：创建目录\n\n常用参数：\n\n-p 若指定路径的父目录不存在则一并创建\n\n## 5、cp：复制\n\n常用参数：\n\n-r 递归复制，复制的数据会使用新的时间戳等信息\n\n-f 强制复制\n\n-a 递归复制，保留原文件属性的前提下复制文件\n\n## 6、rm：删除\n\n常用参数：\n\n-r删除目录及其子目录下的所有内容\n\n-f 强制删除\n\n-i 删除文件前先询问确认\n\n## 7、mv：移动\n\nmv 1.txt 2.txt  将1.txt重命名为2.txt\n\n## 8、du：显示目录所占用的磁盘空间\n\n常用参数：\n\n-s 只显示当前目录的大小,单位kb\n\n-h 以K M G为单位，提高可读性\n\n--max-depth=1 只查看当前目录下的子目录大小\n\n## 9、cat：查看文件内容\n\ncat file1 file2 > file3 将file1和file2的内容结合起来写到file3中，file3以前的内容被清空\n\ncat file1 file2 >> file3 将file1和file2的内容结合起来追加到file3中\n\n## 10、echo：输出字符串\n\n常用参数：\n\n-n 显示字符串时在最后自动换行\n\n-e 支持转义字符\n\n和cat一样可以用重定向符“>”和“>>”将输出的内容写到文件\n\n## 11、more,less：分页查看文件\n\n常用动作命令：\n\n回车键\n向下移动一行\n\ny  向上移动一行\n\n空格键\n向下滚动一屏\n\nb  向上滚动一屏\n\nd  向下滚动半屏\n\nu  向上滚动半屏\n\nq  退出\n\nless还可以用方向键控制往上或往下滚动文件，more不行\n\n## 12、grep：搜索文本\n\n常用参数：\n\n-i 忽略大小写\n\n-n 显示行号\n\n在shell脚本中使用时，搜索成功返回0，不成功返回1，搜索的文件不存在返回2\n\n## 13、find：搜索文件\n\n常用参数：\n\n-name 按照名字查找\n\n-type 按照文件类型查找（f一般文件  d目录  l 链接文件）\n\n-size 按照文件大小查找\n\n## 14、ln：创建链接\n\n常用参数：\n\n-s 创建软链接（创建链接的时候尽量用绝对路径）\n\nln -s  /home/nfs/C6DAI  /home/yangqing/C6DAI\n\n## 15、mount：挂载\n\nmount -t nfs -o nolock,tcp\n192.168.150.21:/home/yangqing/D53.5  \n/usr/local\n\nmount 不加任何参数是查看当前挂载状态\n\numount \n/usr/local 卸载\n\n## 16、chmod：权限设置\n\n常用参数：\n\n-R 递归修改权限\n\nu:所有者权限  g:所属组权限  o:其他用户权限   a:全部用户\n\nr: 读权限，数字表示为4   w:写权限，数字表示为2   x:执行权限，数字表示为1\n\nchmod 777 file  等同于 chmod a=rwx file  所有用户有可读可写可执行权限\n\n## 17、kill：删除执行中的程序\n\nkill -9 pid \n彻底杀死程序\n\nkillall * 杀死当前目录所有程序\n\n## 18、sed：编辑文本\n\n常用参数：\n\n-i 直接编辑源文件\n\n-e 执行多个命令   sed ‘/www/d;/fff/d’\n\n指令动作：\n\na 新增，当前行的后一行新增一行\n\ni 插入，当前行的前一行插入新的一行\n\nd 删除   sed ‘3,$d’ file  删除第3到最后一行\n\nc 替换，以行为单位替换   sed '2,5c No 2-5 number' file  第2-5行整体替换No 2-5\nnumber\n\ns 字符串替换  sed ‘s/home/root/g’ file    将文件中所有home替换为root\n\n## 19、tar：压缩\n\n常用参数：\n\n-c 建立压缩文件\n\n-x 解压\n\n-t 查看内容\n\n-v 显示所有过程\n\n-z 用gzip压缩解压\n\n-j 用bzip2压缩解压\n\n-f 使用文件名（必须有的参数且是最后一个参数）\n\n解压：\n\n*.tar      \n tar -xvf\n\n*.tar.gz      tar -xzf\n\n*tar.bz2    \ntar -xjf   \n\n## 20、vi：编辑器\n\n一般模式：\n\ni 切换到编辑模式\n\n：切换到底线命令模式\n\nPage Down/Page Up 向上/向下移动一页\n\nHome/End 移动到这行的最前面/最后面\n\nG 移动到这个文档的最后一行\n\ngg 移动到这个文档的第一行\n\n数字+Enter  光标向下移动n行\n\n/word 在文档内搜索word字符串\n\ndd  删除光标所在那一整行\n\nyy  复制光标所在的那一行\n\nu 复原前一个动作\n\nctrl + r 重做一次上一个动作\n\n## 21、shell脚本内if判断条件\n\n字符串比较：str1 = str2   str1 != str2\n\n数字比较： -eq 相等      -ne不相等    -gt 大于  \n\n-ge大于等于   -lt 小于      -le小于等于\n\n目录文件：-d 该目录存在  -f  该文件存在\n\n逻辑判断：-a 与      -o 或      ！非\n\n或者使用&& ||逻辑符，但是逻辑符写在中括号之间\n\n## 22、命令行快捷键\n\nctrl + u 删除光标前的所有字符\n\nctrl + k \n删除光标后的所有字符\n\nctrl + a 移动光标到行首\n\nctrl + e 移动光标到行尾\n\nctrl + insert 复制\n\nshift + insert 粘贴\n## 23. touch 命令\n\ntouch 命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。\n\ntouch test.txt 创建不存在的文件test.txt\n## 23. vi 命令\n\nvi是工作在字符终端环境下的全屏幕编辑器\n\n- 命令模式\n  - i 切换到输入模式，以输入字符。\n  - x 删除当前光标所在处的字符。\n  - : 切换到底线命令模式，以在最底一行输入命令。\n- 输入模式\n  - 字符按键以及Shift组合，输入字符\n  - ENTER，回车键，换行\n  - BACK SPACE，退格键，删除光标前一个字符\n  - DEL，删除键，删除光标后一个字符\n  - 方向键，在文本中移动光标\n  - HOME/END，移动光标到行首/行尾\n  - Page Up/Page Down，上/下翻页\n  - Insert，切换光标为输入/替换模式，光标将变成竖线/下划线\n  - ESC，退出输入模式，切换到命令模式\n- 末行模式\n  - q 退出程序\n  - q! 不保存并退出\n  - wq 保存文件并退出\n\n## 24. ssh-key\n生成ssh密钥\n\n```\nssh-keygen -t rsa -C \"你的邮箱\"\n```\n","slug":"shellCommand","published":1,"updated":"2024-07-24T05:54:14.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2q10009lyxx7s0be30d","content":"<h1 id=\"常用shell命令\"><a href=\"#常用shell命令\" class=\"headerlink\" title=\"常用shell命令\"></a>常用shell命令</h1><h2 id=\"1、ls：查看文件\"><a href=\"#1、ls：查看文件\" class=\"headerlink\" title=\"1、ls：查看文件\"></a>1、ls：查看文件</h2><p>常用参数：</p>\n<p>-l 显示详细的文件信息</p>\n<p>-a 显示隐藏文件</p>\n<h2 id=\"2、cd：切换工作目录\"><a href=\"#2、cd：切换工作目录\" class=\"headerlink\" title=\"2、cd：切换工作目录\"></a>2、cd：切换工作目录</h2><p>cd ~ 切换到当前用户的home目录</p>\n<p>cd - 退回切换前的目录</p>\n<p>cd .. 返回上一级目录</p>\n<p>cd  不指定目录，切换到当前用户的home目录</p>\n<h2 id=\"3、pwd：显示用户当前目录\"><a href=\"#3、pwd：显示用户当前目录\" class=\"headerlink\" title=\"3、pwd：显示用户当前目录\"></a>3、pwd：显示用户当前目录</h2><h2 id=\"4、mkdir：创建目录\"><a href=\"#4、mkdir：创建目录\" class=\"headerlink\" title=\"4、mkdir：创建目录\"></a>4、mkdir：创建目录</h2><p>常用参数：</p>\n<p>-p 若指定路径的父目录不存在则一并创建</p>\n<h2 id=\"5、cp：复制\"><a href=\"#5、cp：复制\" class=\"headerlink\" title=\"5、cp：复制\"></a>5、cp：复制</h2><p>常用参数：</p>\n<p>-r 递归复制，复制的数据会使用新的时间戳等信息</p>\n<p>-f 强制复制</p>\n<p>-a 递归复制，保留原文件属性的前提下复制文件</p>\n<h2 id=\"6、rm：删除\"><a href=\"#6、rm：删除\" class=\"headerlink\" title=\"6、rm：删除\"></a>6、rm：删除</h2><p>常用参数：</p>\n<p>-r删除目录及其子目录下的所有内容</p>\n<p>-f 强制删除</p>\n<p>-i 删除文件前先询问确认</p>\n<h2 id=\"7、mv：移动\"><a href=\"#7、mv：移动\" class=\"headerlink\" title=\"7、mv：移动\"></a>7、mv：移动</h2><p>mv 1.txt 2.txt  将1.txt重命名为2.txt</p>\n<h2 id=\"8、du：显示目录所占用的磁盘空间\"><a href=\"#8、du：显示目录所占用的磁盘空间\" class=\"headerlink\" title=\"8、du：显示目录所占用的磁盘空间\"></a>8、du：显示目录所占用的磁盘空间</h2><p>常用参数：</p>\n<p>-s 只显示当前目录的大小,单位kb</p>\n<p>-h 以K M G为单位，提高可读性</p>\n<p>–max-depth&#x3D;1 只查看当前目录下的子目录大小</p>\n<h2 id=\"9、cat：查看文件内容\"><a href=\"#9、cat：查看文件内容\" class=\"headerlink\" title=\"9、cat：查看文件内容\"></a>9、cat：查看文件内容</h2><p>cat file1 file2 &gt; file3 将file1和file2的内容结合起来写到file3中，file3以前的内容被清空</p>\n<p>cat file1 file2 &gt;&gt; file3 将file1和file2的内容结合起来追加到file3中</p>\n<h2 id=\"10、echo：输出字符串\"><a href=\"#10、echo：输出字符串\" class=\"headerlink\" title=\"10、echo：输出字符串\"></a>10、echo：输出字符串</h2><p>常用参数：</p>\n<p>-n 显示字符串时在最后自动换行</p>\n<p>-e 支持转义字符</p>\n<p>和cat一样可以用重定向符“&gt;”和“&gt;&gt;”将输出的内容写到文件</p>\n<h2 id=\"11、more-less：分页查看文件\"><a href=\"#11、more-less：分页查看文件\" class=\"headerlink\" title=\"11、more,less：分页查看文件\"></a>11、more,less：分页查看文件</h2><p>常用动作命令：</p>\n<p>回车键<br>向下移动一行</p>\n<p>y  向上移动一行</p>\n<p>空格键<br>向下滚动一屏</p>\n<p>b  向上滚动一屏</p>\n<p>d  向下滚动半屏</p>\n<p>u  向上滚动半屏</p>\n<p>q  退出</p>\n<p>less还可以用方向键控制往上或往下滚动文件，more不行</p>\n<h2 id=\"12、grep：搜索文本\"><a href=\"#12、grep：搜索文本\" class=\"headerlink\" title=\"12、grep：搜索文本\"></a>12、grep：搜索文本</h2><p>常用参数：</p>\n<p>-i 忽略大小写</p>\n<p>-n 显示行号</p>\n<p>在shell脚本中使用时，搜索成功返回0，不成功返回1，搜索的文件不存在返回2</p>\n<h2 id=\"13、find：搜索文件\"><a href=\"#13、find：搜索文件\" class=\"headerlink\" title=\"13、find：搜索文件\"></a>13、find：搜索文件</h2><p>常用参数：</p>\n<p>-name 按照名字查找</p>\n<p>-type 按照文件类型查找（f一般文件  d目录  l 链接文件）</p>\n<p>-size 按照文件大小查找</p>\n<h2 id=\"14、ln：创建链接\"><a href=\"#14、ln：创建链接\" class=\"headerlink\" title=\"14、ln：创建链接\"></a>14、ln：创建链接</h2><p>常用参数：</p>\n<p>-s 创建软链接（创建链接的时候尽量用绝对路径）</p>\n<p>ln -s  &#x2F;home&#x2F;nfs&#x2F;C6DAI  &#x2F;home&#x2F;yangqing&#x2F;C6DAI</p>\n<h2 id=\"15、mount：挂载\"><a href=\"#15、mount：挂载\" class=\"headerlink\" title=\"15、mount：挂载\"></a>15、mount：挂载</h2><p>mount -t nfs -o nolock,tcp<br>192.168.150.21:&#x2F;home&#x2F;yangqing&#x2F;D53.5<br>&#x2F;usr&#x2F;local</p>\n<p>mount 不加任何参数是查看当前挂载状态</p>\n<p>umount<br>&#x2F;usr&#x2F;local 卸载</p>\n<h2 id=\"16、chmod：权限设置\"><a href=\"#16、chmod：权限设置\" class=\"headerlink\" title=\"16、chmod：权限设置\"></a>16、chmod：权限设置</h2><p>常用参数：</p>\n<p>-R 递归修改权限</p>\n<p>u:所有者权限  g:所属组权限  o:其他用户权限   a:全部用户</p>\n<p>r: 读权限，数字表示为4   w:写权限，数字表示为2   x:执行权限，数字表示为1</p>\n<p>chmod 777 file  等同于 chmod a&#x3D;rwx file  所有用户有可读可写可执行权限</p>\n<h2 id=\"17、kill：删除执行中的程序\"><a href=\"#17、kill：删除执行中的程序\" class=\"headerlink\" title=\"17、kill：删除执行中的程序\"></a>17、kill：删除执行中的程序</h2><p>kill -9 pid<br>彻底杀死程序</p>\n<p>killall * 杀死当前目录所有程序</p>\n<h2 id=\"18、sed：编辑文本\"><a href=\"#18、sed：编辑文本\" class=\"headerlink\" title=\"18、sed：编辑文本\"></a>18、sed：编辑文本</h2><p>常用参数：</p>\n<p>-i 直接编辑源文件</p>\n<p>-e 执行多个命令   sed ‘&#x2F;www&#x2F;d;&#x2F;fff&#x2F;d’</p>\n<p>指令动作：</p>\n<p>a 新增，当前行的后一行新增一行</p>\n<p>i 插入，当前行的前一行插入新的一行</p>\n<p>d 删除   sed ‘3,$d’ file  删除第3到最后一行</p>\n<p>c 替换，以行为单位替换   sed ‘2,5c No 2-5 number’ file  第2-5行整体替换No 2-5<br>number</p>\n<p>s 字符串替换  sed ‘s&#x2F;home&#x2F;root&#x2F;g’ file    将文件中所有home替换为root</p>\n<h2 id=\"19、tar：压缩\"><a href=\"#19、tar：压缩\" class=\"headerlink\" title=\"19、tar：压缩\"></a>19、tar：压缩</h2><p>常用参数：</p>\n<p>-c 建立压缩文件</p>\n<p>-x 解压</p>\n<p>-t 查看内容</p>\n<p>-v 显示所有过程</p>\n<p>-z 用gzip压缩解压</p>\n<p>-j 用bzip2压缩解压</p>\n<p>-f 使用文件名（必须有的参数且是最后一个参数）</p>\n<p>解压：</p>\n<p>*.tar<br> tar -xvf</p>\n<p>*.tar.gz      tar -xzf</p>\n<p>*tar.bz2<br>tar -xjf   </p>\n<h2 id=\"20、vi：编辑器\"><a href=\"#20、vi：编辑器\" class=\"headerlink\" title=\"20、vi：编辑器\"></a>20、vi：编辑器</h2><p>一般模式：</p>\n<p>i 切换到编辑模式</p>\n<p>：切换到底线命令模式</p>\n<p>Page Down&#x2F;Page Up 向上&#x2F;向下移动一页</p>\n<p>Home&#x2F;End 移动到这行的最前面&#x2F;最后面</p>\n<p>G 移动到这个文档的最后一行</p>\n<p>gg 移动到这个文档的第一行</p>\n<p>数字+Enter  光标向下移动n行</p>\n<p>&#x2F;word 在文档内搜索word字符串</p>\n<p>dd  删除光标所在那一整行</p>\n<p>yy  复制光标所在的那一行</p>\n<p>u 复原前一个动作</p>\n<p>ctrl + r 重做一次上一个动作</p>\n<h2 id=\"21、shell脚本内if判断条件\"><a href=\"#21、shell脚本内if判断条件\" class=\"headerlink\" title=\"21、shell脚本内if判断条件\"></a>21、shell脚本内if判断条件</h2><p>字符串比较：str1 &#x3D; str2   str1 !&#x3D; str2</p>\n<p>数字比较： -eq 相等      -ne不相等    -gt 大于  </p>\n<p>-ge大于等于   -lt 小于      -le小于等于</p>\n<p>目录文件：-d 该目录存在  -f  该文件存在</p>\n<p>逻辑判断：-a 与      -o 或      ！非</p>\n<p>或者使用&amp;&amp; ||逻辑符，但是逻辑符写在中括号之间</p>\n<h2 id=\"22、命令行快捷键\"><a href=\"#22、命令行快捷键\" class=\"headerlink\" title=\"22、命令行快捷键\"></a>22、命令行快捷键</h2><p>ctrl + u 删除光标前的所有字符</p>\n<p>ctrl + k<br>删除光标后的所有字符</p>\n<p>ctrl + a 移动光标到行首</p>\n<p>ctrl + e 移动光标到行尾</p>\n<p>ctrl + insert 复制</p>\n<p>shift + insert 粘贴</p>\n<h2 id=\"23-touch-命令\"><a href=\"#23-touch-命令\" class=\"headerlink\" title=\"23. touch 命令\"></a>23. touch 命令</h2><p>touch 命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。</p>\n<p>touch test.txt 创建不存在的文件test.txt</p>\n<h2 id=\"23-vi-命令\"><a href=\"#23-vi-命令\" class=\"headerlink\" title=\"23. vi 命令\"></a>23. vi 命令</h2><p>vi是工作在字符终端环境下的全屏幕编辑器</p>\n<ul>\n<li>命令模式<ul>\n<li>i 切换到输入模式，以输入字符。</li>\n<li>x 删除当前光标所在处的字符。</li>\n<li>: 切换到底线命令模式，以在最底一行输入命令。</li>\n</ul>\n</li>\n<li>输入模式<ul>\n<li>字符按键以及Shift组合，输入字符</li>\n<li>ENTER，回车键，换行</li>\n<li>BACK SPACE，退格键，删除光标前一个字符</li>\n<li>DEL，删除键，删除光标后一个字符</li>\n<li>方向键，在文本中移动光标</li>\n<li>HOME&#x2F;END，移动光标到行首&#x2F;行尾</li>\n<li>Page Up&#x2F;Page Down，上&#x2F;下翻页</li>\n<li>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>\n<li>ESC，退出输入模式，切换到命令模式</li>\n</ul>\n</li>\n<li>末行模式<ul>\n<li>q 退出程序</li>\n<li>q! 不保存并退出</li>\n<li>wq 保存文件并退出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"24-ssh-key\"><a href=\"#24-ssh-key\" class=\"headerlink\" title=\"24. ssh-key\"></a>24. ssh-key</h2><p>生成ssh密钥</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">ssh-keygen -<span class=\"hljs-built_in\">t</span> rsa -C <span class=\"hljs-string\">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2567,"excerpt":"","more":"<h1 id=\"常用shell命令\"><a href=\"#常用shell命令\" class=\"headerlink\" title=\"常用shell命令\"></a>常用shell命令</h1><h2 id=\"1、ls：查看文件\"><a href=\"#1、ls：查看文件\" class=\"headerlink\" title=\"1、ls：查看文件\"></a>1、ls：查看文件</h2><p>常用参数：</p>\n<p>-l 显示详细的文件信息</p>\n<p>-a 显示隐藏文件</p>\n<h2 id=\"2、cd：切换工作目录\"><a href=\"#2、cd：切换工作目录\" class=\"headerlink\" title=\"2、cd：切换工作目录\"></a>2、cd：切换工作目录</h2><p>cd ~ 切换到当前用户的home目录</p>\n<p>cd - 退回切换前的目录</p>\n<p>cd .. 返回上一级目录</p>\n<p>cd  不指定目录，切换到当前用户的home目录</p>\n<h2 id=\"3、pwd：显示用户当前目录\"><a href=\"#3、pwd：显示用户当前目录\" class=\"headerlink\" title=\"3、pwd：显示用户当前目录\"></a>3、pwd：显示用户当前目录</h2><h2 id=\"4、mkdir：创建目录\"><a href=\"#4、mkdir：创建目录\" class=\"headerlink\" title=\"4、mkdir：创建目录\"></a>4、mkdir：创建目录</h2><p>常用参数：</p>\n<p>-p 若指定路径的父目录不存在则一并创建</p>\n<h2 id=\"5、cp：复制\"><a href=\"#5、cp：复制\" class=\"headerlink\" title=\"5、cp：复制\"></a>5、cp：复制</h2><p>常用参数：</p>\n<p>-r 递归复制，复制的数据会使用新的时间戳等信息</p>\n<p>-f 强制复制</p>\n<p>-a 递归复制，保留原文件属性的前提下复制文件</p>\n<h2 id=\"6、rm：删除\"><a href=\"#6、rm：删除\" class=\"headerlink\" title=\"6、rm：删除\"></a>6、rm：删除</h2><p>常用参数：</p>\n<p>-r删除目录及其子目录下的所有内容</p>\n<p>-f 强制删除</p>\n<p>-i 删除文件前先询问确认</p>\n<h2 id=\"7、mv：移动\"><a href=\"#7、mv：移动\" class=\"headerlink\" title=\"7、mv：移动\"></a>7、mv：移动</h2><p>mv 1.txt 2.txt  将1.txt重命名为2.txt</p>\n<h2 id=\"8、du：显示目录所占用的磁盘空间\"><a href=\"#8、du：显示目录所占用的磁盘空间\" class=\"headerlink\" title=\"8、du：显示目录所占用的磁盘空间\"></a>8、du：显示目录所占用的磁盘空间</h2><p>常用参数：</p>\n<p>-s 只显示当前目录的大小,单位kb</p>\n<p>-h 以K M G为单位，提高可读性</p>\n<p>–max-depth&#x3D;1 只查看当前目录下的子目录大小</p>\n<h2 id=\"9、cat：查看文件内容\"><a href=\"#9、cat：查看文件内容\" class=\"headerlink\" title=\"9、cat：查看文件内容\"></a>9、cat：查看文件内容</h2><p>cat file1 file2 &gt; file3 将file1和file2的内容结合起来写到file3中，file3以前的内容被清空</p>\n<p>cat file1 file2 &gt;&gt; file3 将file1和file2的内容结合起来追加到file3中</p>\n<h2 id=\"10、echo：输出字符串\"><a href=\"#10、echo：输出字符串\" class=\"headerlink\" title=\"10、echo：输出字符串\"></a>10、echo：输出字符串</h2><p>常用参数：</p>\n<p>-n 显示字符串时在最后自动换行</p>\n<p>-e 支持转义字符</p>\n<p>和cat一样可以用重定向符“&gt;”和“&gt;&gt;”将输出的内容写到文件</p>\n<h2 id=\"11、more-less：分页查看文件\"><a href=\"#11、more-less：分页查看文件\" class=\"headerlink\" title=\"11、more,less：分页查看文件\"></a>11、more,less：分页查看文件</h2><p>常用动作命令：</p>\n<p>回车键<br>向下移动一行</p>\n<p>y  向上移动一行</p>\n<p>空格键<br>向下滚动一屏</p>\n<p>b  向上滚动一屏</p>\n<p>d  向下滚动半屏</p>\n<p>u  向上滚动半屏</p>\n<p>q  退出</p>\n<p>less还可以用方向键控制往上或往下滚动文件，more不行</p>\n<h2 id=\"12、grep：搜索文本\"><a href=\"#12、grep：搜索文本\" class=\"headerlink\" title=\"12、grep：搜索文本\"></a>12、grep：搜索文本</h2><p>常用参数：</p>\n<p>-i 忽略大小写</p>\n<p>-n 显示行号</p>\n<p>在shell脚本中使用时，搜索成功返回0，不成功返回1，搜索的文件不存在返回2</p>\n<h2 id=\"13、find：搜索文件\"><a href=\"#13、find：搜索文件\" class=\"headerlink\" title=\"13、find：搜索文件\"></a>13、find：搜索文件</h2><p>常用参数：</p>\n<p>-name 按照名字查找</p>\n<p>-type 按照文件类型查找（f一般文件  d目录  l 链接文件）</p>\n<p>-size 按照文件大小查找</p>\n<h2 id=\"14、ln：创建链接\"><a href=\"#14、ln：创建链接\" class=\"headerlink\" title=\"14、ln：创建链接\"></a>14、ln：创建链接</h2><p>常用参数：</p>\n<p>-s 创建软链接（创建链接的时候尽量用绝对路径）</p>\n<p>ln -s  &#x2F;home&#x2F;nfs&#x2F;C6DAI  &#x2F;home&#x2F;yangqing&#x2F;C6DAI</p>\n<h2 id=\"15、mount：挂载\"><a href=\"#15、mount：挂载\" class=\"headerlink\" title=\"15、mount：挂载\"></a>15、mount：挂载</h2><p>mount -t nfs -o nolock,tcp<br>192.168.150.21:&#x2F;home&#x2F;yangqing&#x2F;D53.5<br>&#x2F;usr&#x2F;local</p>\n<p>mount 不加任何参数是查看当前挂载状态</p>\n<p>umount<br>&#x2F;usr&#x2F;local 卸载</p>\n<h2 id=\"16、chmod：权限设置\"><a href=\"#16、chmod：权限设置\" class=\"headerlink\" title=\"16、chmod：权限设置\"></a>16、chmod：权限设置</h2><p>常用参数：</p>\n<p>-R 递归修改权限</p>\n<p>u:所有者权限  g:所属组权限  o:其他用户权限   a:全部用户</p>\n<p>r: 读权限，数字表示为4   w:写权限，数字表示为2   x:执行权限，数字表示为1</p>\n<p>chmod 777 file  等同于 chmod a&#x3D;rwx file  所有用户有可读可写可执行权限</p>\n<h2 id=\"17、kill：删除执行中的程序\"><a href=\"#17、kill：删除执行中的程序\" class=\"headerlink\" title=\"17、kill：删除执行中的程序\"></a>17、kill：删除执行中的程序</h2><p>kill -9 pid<br>彻底杀死程序</p>\n<p>killall * 杀死当前目录所有程序</p>\n<h2 id=\"18、sed：编辑文本\"><a href=\"#18、sed：编辑文本\" class=\"headerlink\" title=\"18、sed：编辑文本\"></a>18、sed：编辑文本</h2><p>常用参数：</p>\n<p>-i 直接编辑源文件</p>\n<p>-e 执行多个命令   sed ‘&#x2F;www&#x2F;d;&#x2F;fff&#x2F;d’</p>\n<p>指令动作：</p>\n<p>a 新增，当前行的后一行新增一行</p>\n<p>i 插入，当前行的前一行插入新的一行</p>\n<p>d 删除   sed ‘3,$d’ file  删除第3到最后一行</p>\n<p>c 替换，以行为单位替换   sed ‘2,5c No 2-5 number’ file  第2-5行整体替换No 2-5<br>number</p>\n<p>s 字符串替换  sed ‘s&#x2F;home&#x2F;root&#x2F;g’ file    将文件中所有home替换为root</p>\n<h2 id=\"19、tar：压缩\"><a href=\"#19、tar：压缩\" class=\"headerlink\" title=\"19、tar：压缩\"></a>19、tar：压缩</h2><p>常用参数：</p>\n<p>-c 建立压缩文件</p>\n<p>-x 解压</p>\n<p>-t 查看内容</p>\n<p>-v 显示所有过程</p>\n<p>-z 用gzip压缩解压</p>\n<p>-j 用bzip2压缩解压</p>\n<p>-f 使用文件名（必须有的参数且是最后一个参数）</p>\n<p>解压：</p>\n<p>*.tar<br> tar -xvf</p>\n<p>*.tar.gz      tar -xzf</p>\n<p>*tar.bz2<br>tar -xjf   </p>\n<h2 id=\"20、vi：编辑器\"><a href=\"#20、vi：编辑器\" class=\"headerlink\" title=\"20、vi：编辑器\"></a>20、vi：编辑器</h2><p>一般模式：</p>\n<p>i 切换到编辑模式</p>\n<p>：切换到底线命令模式</p>\n<p>Page Down&#x2F;Page Up 向上&#x2F;向下移动一页</p>\n<p>Home&#x2F;End 移动到这行的最前面&#x2F;最后面</p>\n<p>G 移动到这个文档的最后一行</p>\n<p>gg 移动到这个文档的第一行</p>\n<p>数字+Enter  光标向下移动n行</p>\n<p>&#x2F;word 在文档内搜索word字符串</p>\n<p>dd  删除光标所在那一整行</p>\n<p>yy  复制光标所在的那一行</p>\n<p>u 复原前一个动作</p>\n<p>ctrl + r 重做一次上一个动作</p>\n<h2 id=\"21、shell脚本内if判断条件\"><a href=\"#21、shell脚本内if判断条件\" class=\"headerlink\" title=\"21、shell脚本内if判断条件\"></a>21、shell脚本内if判断条件</h2><p>字符串比较：str1 &#x3D; str2   str1 !&#x3D; str2</p>\n<p>数字比较： -eq 相等      -ne不相等    -gt 大于  </p>\n<p>-ge大于等于   -lt 小于      -le小于等于</p>\n<p>目录文件：-d 该目录存在  -f  该文件存在</p>\n<p>逻辑判断：-a 与      -o 或      ！非</p>\n<p>或者使用&amp;&amp; ||逻辑符，但是逻辑符写在中括号之间</p>\n<h2 id=\"22、命令行快捷键\"><a href=\"#22、命令行快捷键\" class=\"headerlink\" title=\"22、命令行快捷键\"></a>22、命令行快捷键</h2><p>ctrl + u 删除光标前的所有字符</p>\n<p>ctrl + k<br>删除光标后的所有字符</p>\n<p>ctrl + a 移动光标到行首</p>\n<p>ctrl + e 移动光标到行尾</p>\n<p>ctrl + insert 复制</p>\n<p>shift + insert 粘贴</p>\n<h2 id=\"23-touch-命令\"><a href=\"#23-touch-命令\" class=\"headerlink\" title=\"23. touch 命令\"></a>23. touch 命令</h2><p>touch 命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。</p>\n<p>touch test.txt 创建不存在的文件test.txt</p>\n<h2 id=\"23-vi-命令\"><a href=\"#23-vi-命令\" class=\"headerlink\" title=\"23. vi 命令\"></a>23. vi 命令</h2><p>vi是工作在字符终端环境下的全屏幕编辑器</p>\n<ul>\n<li>命令模式<ul>\n<li>i 切换到输入模式，以输入字符。</li>\n<li>x 删除当前光标所在处的字符。</li>\n<li>: 切换到底线命令模式，以在最底一行输入命令。</li>\n</ul>\n</li>\n<li>输入模式<ul>\n<li>字符按键以及Shift组合，输入字符</li>\n<li>ENTER，回车键，换行</li>\n<li>BACK SPACE，退格键，删除光标前一个字符</li>\n<li>DEL，删除键，删除光标后一个字符</li>\n<li>方向键，在文本中移动光标</li>\n<li>HOME&#x2F;END，移动光标到行首&#x2F;行尾</li>\n<li>Page Up&#x2F;Page Down，上&#x2F;下翻页</li>\n<li>Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线</li>\n<li>ESC，退出输入模式，切换到命令模式</li>\n</ul>\n</li>\n<li>末行模式<ul>\n<li>q 退出程序</li>\n<li>q! 不保存并退出</li>\n<li>wq 保存文件并退出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"24-ssh-key\"><a href=\"#24-ssh-key\" class=\"headerlink\" title=\"24. ssh-key\"></a>24. ssh-key</h2><p>生成ssh密钥</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">ssh-keygen -<span class=\"hljs-built_in\">t</span> rsa -C <span class=\"hljs-string\">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"服务端消息推送方式","date":"2022-08-14T06:17:54.000Z","_content":"\n## 服务端向web前端推送消息常用方式\n\n### 问题出现场景\n+ 面试官向你提问，说说如何实现服务端向web前端推送数据？😂\n+ 实际开发中当前端页面在挂起状态，这时候服务端推送了一条消息需要前端展示（单向推送）\n+ web页面实时聊天功能（双向推送）\n  \n### 解决方案\n主要写了5种方案，分别介绍下实现以及运用场景\n> 1. 轮询（短轮询）\n这是最简单直观的方法，就是每隔一段时间发起一个请求到后端询问是否有新信息。至于为什么又叫短轮询，其是相对于后续要说的长轮询来对比的。\n\n前端写法只要设置一个setTimeout来定时请求就行\n```javascript\n// 缓存前端已经获取的最新id\nlet id = 0;\nfunction poll() {\n  $.ajax({\n    url: '/api/polling',\n    data: { id },\n  }).done(res => {\n    id += res.length;\n  }).always(() => {\n    // 10s后再次请求\n    setTimeout(poll, 10000);\n  });\n}\npoll();\n```\n后端写法，根据前端给到的id，看看有没有新消息，有就返回，没有就返回空\n```javascript\nconst id = parseInt(query.id || '0', 10) || 0;\nres.writeHead(200, { 'Content-Type': 'application/json;' });\nres.end(JSON.stringify(datas.slice(id)));\n```\n这种方式不需要后端实现消息推送改造，只需要前端定时请求后端接口其实时性与请求频率成正相关，但是当请求频率上来了，性能浪费也就越高，毕竟可能大部分请求都是无意义的。\n\n> 2. 长轮询\n这里的长轮询相对前面的轮询来说，算是一种优化。具体就是前端发起请求到后端，后端不直接返回，而是等待有新信息时再返回。所以这样发起的一个请求，可能需要很长的时间才能等到返回，故而叫做长轮询。\n\n其前端代码基本和短轮询一致，只不过把请求的超时时间设置较长（比如1分钟），然后无论请求成功或失败，马上再次发起请求即可。\n```javascript\nlet id = 0\nfunction poll() {\n  $.ajax({\n    url: '/api/long-polling',\n    data: { id },\n    timeout: 60000, // 请求的超时时间设置较长\n  }).done((res) => {\n    id += res.length\n  }).always(() => {\n    setTimeout(poll, 1000)\n  })\n}\npoll()\n```\n后端写法\n```javascript\nconst id = parseInt(query.id || '0', 10) || 0;\nconst cbk = 'long-polling';\ndelete callbacks[cbk];\nconst data = datas.slice(id);\nres.writeHead(200, { 'Content-Type': 'application/json' });\n// 发起请求时，正好有新消息就返回\nif (data.length) {\n return res.end(JSON.stringify(data));\n}\n// 注册新消息回调\ncallbacks[cbk] = (d) => {\n res.end(d);\n};\n```\n这样，相对于短轮询，少了很多无意义的请求，而且消息的实时性也非常好。缺点就是当服务端有异常时，会导致长轮询短时间内不断发起请求，可能让服务端承受更大的压力，所以两次长轮询之间最好有一定间隔，或者异常检测机制。\n\n> 3. SSE（Server-sent events）\n前面提到的轮询、长轮询都是一问一答式的，一次请求，无法推送多次消息到前端。而SSE就厉害了，一次请求，N次推送。\n其原理可以理解为下载一个巨大的文件，文件的内容分块传给前端，每块就是一次消息推送。\n\n前端写法，有专门的EventSource来接收，使用起来很方便\n```javascript\nlet id = 0\nconst es = new EventSource('/api/sse')\nes.onmessage = (e) => {\n  try {\n    const res = JSON.parse(e.data)\n  } catch (e) {\n    console.log(e)\n  }\n}\nes.onopen = () => {\n  pushStatus(s, '等待消息中', 'success')\n}\nes.onerror = () => {\n  pushStatus(s, '连接错误', 'danger')\n}\n```\n后端写法，核心在于Content-Type: text/event-stream，这要让前端知道这是SSE，还有就是传输信息的格式比较特别一点，详细的可以看 MDN（ https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events ）\n```javascript\nres.writeHead(200, {\n  // 这个是核心\n  'Content-Type': 'text/event-stream',\n  'Connection': 'keep-alive',\n});\n// 把缓存的信息推送给前端\nres.write(`data: ${JSON.stringify(datas)}\\n\\n`);\n// 注册新消息回调\ncallbacks[cbk] = (d) => {\n  res.write(`data: ${d}\\n\\n`);\n};\n```\nSSE还支持自动重连！服务器短时间异常，恢复之后，无需额外代码，SSE就自动重连上了。\n\n> 4. WebSocket\nWebSocket可以一次连接，双向推送，而SSE只能从服务端推送到前端。从这个角度来看，用WebSocket来单做服务端推送，有点大材小用了。\n\n前端写法与SSE类似，十分简单，只不过请求链接为ws://或者wss://开头（相当于http://和https://）\n```javascript\nconst ws = new WebSocket('ws://localhost:3000/ws');\nws.onmessage = e => {\n  try {\n    const c = JSON.parse(e.data);\n  } catch (err) {\n    console.log(err);\n  }\n};\n```\n如果要用原生Node.js来写WebSocket服务，就会麻烦一些了，一般情况都会使用类似socket.io之类的三方库来降低实现成本。这边也就在网上摘抄了一段代码来简单实现一下\n后端写法\n```javascript\nserver.on('upgrade', (req, socket) => {\n  const acceptKey = req.headers['sec-websocket-key'];\n  const hash = generateAcceptValue(acceptKey);\n  // 生成响应头信息\n  const responseHeaders = [ 'HTTP/1.1 101 Web Socket Protocol Handshake', 'Upgrade: WebSocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${hash}` ];\n  // 告知前端这是WebSocket协议\n  socket.write(responseHeaders.join('\\r\\n') + '\\r\\n\\r\\n');\n  // 发送数据\n  socket.write(constructReply(datas));\n  callbacks[cbk] = (d) => {\n    socket.write(constructReply(d));\n  }\n});\n```\nWebsocket没有像SSE一样有自动重连，这块需要自行实现。一般网页实时聊天之类需要双向推送的，都会使用WebSocket来实现。\n\n> 5. iFrame\n原理类似使用iFrame加载一个巨大的网页，利用浏览器会一边加载一边解析执行返回的HTML，通过分次返回Script标签来实现消息推送。其实现类似SSE\n\n前端代码很简单，要注册一个回调给iframe使用\n```javascript\n// 注册给iframe使用的方法\nwindow.change = function(data) {};\n$('body').append('<iframe src=\"/api/iframe\"></iframe>');\n```\n后端也很简单，有消息的时候返回script标签即可\n```javascript\n// 有推送消息返回缓存信息\nres.write(`<script>window.parent.change(${JSON.stringify(datas)});</script>`);\n// 注册消息回调\ncallbacks[cbk] = (d) => {\n  res.write(`<script>window.parent.change(${d});</script>`);\n};\n```\niFrame这种方式缺点没有判断加载异常的情况\n\n### 总结\n| 方案 | 实时性 | 单次连接 | 自动重连\t| 断线检测 | 双向推送\t| \n| ---- | :---: | :---: |:---: | :---: |:---: |\n| 短轮询 |  ❌  | ❌ | ➖ |  ✅   | ❌ |\n| 长轮询 |  ✅  | ❌ | ➖ |  ✅   | ❌ |\n| SSE |  ✅  | ✅ | ✅ |  ✅   | ❌ |\n| WebSocket |  ✅  | ✅ | ❌ |  ✅   | ✅ |\n| iFrame |  ✅  | ✅ | ❌ |  ❌   | ❌ |\n","source":"_posts/webServerPush.md","raw":"---\ntitle: 服务端消息推送方式\ndate: 2022-08-14 14:17:54\ntags: web\n---\n\n## 服务端向web前端推送消息常用方式\n\n### 问题出现场景\n+ 面试官向你提问，说说如何实现服务端向web前端推送数据？😂\n+ 实际开发中当前端页面在挂起状态，这时候服务端推送了一条消息需要前端展示（单向推送）\n+ web页面实时聊天功能（双向推送）\n  \n### 解决方案\n主要写了5种方案，分别介绍下实现以及运用场景\n> 1. 轮询（短轮询）\n这是最简单直观的方法，就是每隔一段时间发起一个请求到后端询问是否有新信息。至于为什么又叫短轮询，其是相对于后续要说的长轮询来对比的。\n\n前端写法只要设置一个setTimeout来定时请求就行\n```javascript\n// 缓存前端已经获取的最新id\nlet id = 0;\nfunction poll() {\n  $.ajax({\n    url: '/api/polling',\n    data: { id },\n  }).done(res => {\n    id += res.length;\n  }).always(() => {\n    // 10s后再次请求\n    setTimeout(poll, 10000);\n  });\n}\npoll();\n```\n后端写法，根据前端给到的id，看看有没有新消息，有就返回，没有就返回空\n```javascript\nconst id = parseInt(query.id || '0', 10) || 0;\nres.writeHead(200, { 'Content-Type': 'application/json;' });\nres.end(JSON.stringify(datas.slice(id)));\n```\n这种方式不需要后端实现消息推送改造，只需要前端定时请求后端接口其实时性与请求频率成正相关，但是当请求频率上来了，性能浪费也就越高，毕竟可能大部分请求都是无意义的。\n\n> 2. 长轮询\n这里的长轮询相对前面的轮询来说，算是一种优化。具体就是前端发起请求到后端，后端不直接返回，而是等待有新信息时再返回。所以这样发起的一个请求，可能需要很长的时间才能等到返回，故而叫做长轮询。\n\n其前端代码基本和短轮询一致，只不过把请求的超时时间设置较长（比如1分钟），然后无论请求成功或失败，马上再次发起请求即可。\n```javascript\nlet id = 0\nfunction poll() {\n  $.ajax({\n    url: '/api/long-polling',\n    data: { id },\n    timeout: 60000, // 请求的超时时间设置较长\n  }).done((res) => {\n    id += res.length\n  }).always(() => {\n    setTimeout(poll, 1000)\n  })\n}\npoll()\n```\n后端写法\n```javascript\nconst id = parseInt(query.id || '0', 10) || 0;\nconst cbk = 'long-polling';\ndelete callbacks[cbk];\nconst data = datas.slice(id);\nres.writeHead(200, { 'Content-Type': 'application/json' });\n// 发起请求时，正好有新消息就返回\nif (data.length) {\n return res.end(JSON.stringify(data));\n}\n// 注册新消息回调\ncallbacks[cbk] = (d) => {\n res.end(d);\n};\n```\n这样，相对于短轮询，少了很多无意义的请求，而且消息的实时性也非常好。缺点就是当服务端有异常时，会导致长轮询短时间内不断发起请求，可能让服务端承受更大的压力，所以两次长轮询之间最好有一定间隔，或者异常检测机制。\n\n> 3. SSE（Server-sent events）\n前面提到的轮询、长轮询都是一问一答式的，一次请求，无法推送多次消息到前端。而SSE就厉害了，一次请求，N次推送。\n其原理可以理解为下载一个巨大的文件，文件的内容分块传给前端，每块就是一次消息推送。\n\n前端写法，有专门的EventSource来接收，使用起来很方便\n```javascript\nlet id = 0\nconst es = new EventSource('/api/sse')\nes.onmessage = (e) => {\n  try {\n    const res = JSON.parse(e.data)\n  } catch (e) {\n    console.log(e)\n  }\n}\nes.onopen = () => {\n  pushStatus(s, '等待消息中', 'success')\n}\nes.onerror = () => {\n  pushStatus(s, '连接错误', 'danger')\n}\n```\n后端写法，核心在于Content-Type: text/event-stream，这要让前端知道这是SSE，还有就是传输信息的格式比较特别一点，详细的可以看 MDN（ https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events ）\n```javascript\nres.writeHead(200, {\n  // 这个是核心\n  'Content-Type': 'text/event-stream',\n  'Connection': 'keep-alive',\n});\n// 把缓存的信息推送给前端\nres.write(`data: ${JSON.stringify(datas)}\\n\\n`);\n// 注册新消息回调\ncallbacks[cbk] = (d) => {\n  res.write(`data: ${d}\\n\\n`);\n};\n```\nSSE还支持自动重连！服务器短时间异常，恢复之后，无需额外代码，SSE就自动重连上了。\n\n> 4. WebSocket\nWebSocket可以一次连接，双向推送，而SSE只能从服务端推送到前端。从这个角度来看，用WebSocket来单做服务端推送，有点大材小用了。\n\n前端写法与SSE类似，十分简单，只不过请求链接为ws://或者wss://开头（相当于http://和https://）\n```javascript\nconst ws = new WebSocket('ws://localhost:3000/ws');\nws.onmessage = e => {\n  try {\n    const c = JSON.parse(e.data);\n  } catch (err) {\n    console.log(err);\n  }\n};\n```\n如果要用原生Node.js来写WebSocket服务，就会麻烦一些了，一般情况都会使用类似socket.io之类的三方库来降低实现成本。这边也就在网上摘抄了一段代码来简单实现一下\n后端写法\n```javascript\nserver.on('upgrade', (req, socket) => {\n  const acceptKey = req.headers['sec-websocket-key'];\n  const hash = generateAcceptValue(acceptKey);\n  // 生成响应头信息\n  const responseHeaders = [ 'HTTP/1.1 101 Web Socket Protocol Handshake', 'Upgrade: WebSocket', 'Connection: Upgrade', `Sec-WebSocket-Accept: ${hash}` ];\n  // 告知前端这是WebSocket协议\n  socket.write(responseHeaders.join('\\r\\n') + '\\r\\n\\r\\n');\n  // 发送数据\n  socket.write(constructReply(datas));\n  callbacks[cbk] = (d) => {\n    socket.write(constructReply(d));\n  }\n});\n```\nWebsocket没有像SSE一样有自动重连，这块需要自行实现。一般网页实时聊天之类需要双向推送的，都会使用WebSocket来实现。\n\n> 5. iFrame\n原理类似使用iFrame加载一个巨大的网页，利用浏览器会一边加载一边解析执行返回的HTML，通过分次返回Script标签来实现消息推送。其实现类似SSE\n\n前端代码很简单，要注册一个回调给iframe使用\n```javascript\n// 注册给iframe使用的方法\nwindow.change = function(data) {};\n$('body').append('<iframe src=\"/api/iframe\"></iframe>');\n```\n后端也很简单，有消息的时候返回script标签即可\n```javascript\n// 有推送消息返回缓存信息\nres.write(`<script>window.parent.change(${JSON.stringify(datas)});</script>`);\n// 注册消息回调\ncallbacks[cbk] = (d) => {\n  res.write(`<script>window.parent.change(${d});</script>`);\n};\n```\niFrame这种方式缺点没有判断加载异常的情况\n\n### 总结\n| 方案 | 实时性 | 单次连接 | 自动重连\t| 断线检测 | 双向推送\t| \n| ---- | :---: | :---: |:---: | :---: |:---: |\n| 短轮询 |  ❌  | ❌ | ➖ |  ✅   | ❌ |\n| 长轮询 |  ✅  | ❌ | ➖ |  ✅   | ❌ |\n| SSE |  ✅  | ✅ | ✅ |  ✅   | ❌ |\n| WebSocket |  ✅  | ✅ | ❌ |  ✅   | ✅ |\n| iFrame |  ✅  | ✅ | ❌ |  ❌   | ❌ |\n","slug":"webServerPush","published":1,"updated":"2024-07-24T05:54:14.625Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clyzfl2q3000alyxxa53e9fdg","content":"<h2 id=\"服务端向web前端推送消息常用方式\"><a href=\"#服务端向web前端推送消息常用方式\" class=\"headerlink\" title=\"服务端向web前端推送消息常用方式\"></a>服务端向web前端推送消息常用方式</h2><h3 id=\"问题出现场景\"><a href=\"#问题出现场景\" class=\"headerlink\" title=\"问题出现场景\"></a>问题出现场景</h3><ul>\n<li>面试官向你提问，说说如何实现服务端向web前端推送数据？😂</li>\n<li>实际开发中当前端页面在挂起状态，这时候服务端推送了一条消息需要前端展示（单向推送）</li>\n<li>web页面实时聊天功能（双向推送）</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>主要写了5种方案，分别介绍下实现以及运用场景</p>\n<blockquote>\n<ol>\n<li>轮询（短轮询）<br>这是最简单直观的方法，就是每隔一段时间发起一个请求到后端询问是否有新信息。至于为什么又叫短轮询，其是相对于后续要说的长轮询来对比的。</li>\n</ol>\n</blockquote>\n<p>前端写法只要设置一个setTimeout来定时请求就行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 缓存前端已经获取的最新id</span><br><span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">poll</span>(<span class=\"hljs-params\"></span>) &#123;<br>  $.<span class=\"hljs-title function_\">ajax</span>(&#123;<br>    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;/api/polling&#x27;</span>,<br>    <span class=\"hljs-attr\">data</span>: &#123; id &#125;,<br>  &#125;).<span class=\"hljs-title function_\">done</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>    id += res.<span class=\"hljs-property\">length</span>;<br>  &#125;).<span class=\"hljs-title function_\">always</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">// 10s后再次请求</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(poll, <span class=\"hljs-number\">10000</span>);<br>  &#125;);<br>&#125;<br><span class=\"hljs-title function_\">poll</span>();<br></code></pre></td></tr></table></figure>\n<p>后端写法，根据前端给到的id，看看有没有新消息，有就返回，没有就返回空</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">parseInt</span>(query.<span class=\"hljs-property\">id</span> || <span class=\"hljs-string\">&#x27;0&#x27;</span>, <span class=\"hljs-number\">10</span>) || <span class=\"hljs-number\">0</span>;<br>res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123; <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json;&#x27;</span> &#125;);<br>res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(datas.<span class=\"hljs-title function_\">slice</span>(id)));<br></code></pre></td></tr></table></figure>\n<p>这种方式不需要后端实现消息推送改造，只需要前端定时请求后端接口其实时性与请求频率成正相关，但是当请求频率上来了，性能浪费也就越高，毕竟可能大部分请求都是无意义的。</p>\n<blockquote>\n<ol start=\"2\">\n<li>长轮询<br>这里的长轮询相对前面的轮询来说，算是一种优化。具体就是前端发起请求到后端，后端不直接返回，而是等待有新信息时再返回。所以这样发起的一个请求，可能需要很长的时间才能等到返回，故而叫做长轮询。</li>\n</ol>\n</blockquote>\n<p>其前端代码基本和短轮询一致，只不过把请求的超时时间设置较长（比如1分钟），然后无论请求成功或失败，马上再次发起请求即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">poll</span>(<span class=\"hljs-params\"></span>) &#123;<br>  $.<span class=\"hljs-title function_\">ajax</span>(&#123;<br>    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;/api/long-polling&#x27;</span>,<br>    <span class=\"hljs-attr\">data</span>: &#123; id &#125;,<br>    <span class=\"hljs-attr\">timeout</span>: <span class=\"hljs-number\">60000</span>, <span class=\"hljs-comment\">// 请求的超时时间设置较长</span><br>  &#125;).<span class=\"hljs-title function_\">done</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    id += res.<span class=\"hljs-property\">length</span><br>  &#125;).<span class=\"hljs-title function_\">always</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(poll, <span class=\"hljs-number\">1000</span>)<br>  &#125;)<br>&#125;<br><span class=\"hljs-title function_\">poll</span>()<br></code></pre></td></tr></table></figure>\n<p>后端写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">parseInt</span>(query.<span class=\"hljs-property\">id</span> || <span class=\"hljs-string\">&#x27;0&#x27;</span>, <span class=\"hljs-number\">10</span>) || <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">const</span> cbk = <span class=\"hljs-string\">&#x27;long-polling&#x27;</span>;<br><span class=\"hljs-keyword\">delete</span> callbacks[cbk];<br><span class=\"hljs-keyword\">const</span> data = datas.<span class=\"hljs-title function_\">slice</span>(id);<br>res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123; <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span> &#125;);<br><span class=\"hljs-comment\">// 发起请求时，正好有新消息就返回</span><br><span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">length</span>) &#123;<br> <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data));<br>&#125;<br><span class=\"hljs-comment\">// 注册新消息回调</span><br>callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br> res.<span class=\"hljs-title function_\">end</span>(d);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>这样，相对于短轮询，少了很多无意义的请求，而且消息的实时性也非常好。缺点就是当服务端有异常时，会导致长轮询短时间内不断发起请求，可能让服务端承受更大的压力，所以两次长轮询之间最好有一定间隔，或者异常检测机制。</p>\n<blockquote>\n<ol start=\"3\">\n<li>SSE（Server-sent events）<br>前面提到的轮询、长轮询都是一问一答式的，一次请求，无法推送多次消息到前端。而SSE就厉害了，一次请求，N次推送。<br>其原理可以理解为下载一个巨大的文件，文件的内容分块传给前端，每块就是一次消息推送。</li>\n</ol>\n</blockquote>\n<p>前端写法，有专门的EventSource来接收，使用起来很方便</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">const</span> es = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventSource</span>(<span class=\"hljs-string\">&#x27;/api/sse&#x27;</span>)<br>es.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(e.<span class=\"hljs-property\">data</span>)<br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e)<br>  &#125;<br>&#125;<br>es.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">pushStatus</span>(s, <span class=\"hljs-string\">&#x27;等待消息中&#x27;</span>, <span class=\"hljs-string\">&#x27;success&#x27;</span>)<br>&#125;<br>es.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">pushStatus</span>(s, <span class=\"hljs-string\">&#x27;连接错误&#x27;</span>, <span class=\"hljs-string\">&#x27;danger&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>后端写法，核心在于Content-Type: text&#x2F;event-stream，这要让前端知道这是SSE，还有就是传输信息的格式比较特别一点，详细的可以看 MDN（ <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events\">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events</a> ）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-comment\">// 这个是核心</span><br>  <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;text/event-stream&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;Connection&#x27;</span>: <span class=\"hljs-string\">&#x27;keep-alive&#x27;</span>,<br>&#125;);<br><span class=\"hljs-comment\">// 把缓存的信息推送给前端</span><br>res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`data: <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(datas)&#125;</span>\\n\\n`</span>);<br><span class=\"hljs-comment\">// 注册新消息回调</span><br>callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br>  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`data: <span class=\"hljs-subst\">$&#123;d&#125;</span>\\n\\n`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>SSE还支持自动重连！服务器短时间异常，恢复之后，无需额外代码，SSE就自动重连上了。</p>\n<blockquote>\n<ol start=\"4\">\n<li>WebSocket<br>WebSocket可以一次连接，双向推送，而SSE只能从服务端推送到前端。从这个角度来看，用WebSocket来单做服务端推送，有点大材小用了。</li>\n</ol>\n</blockquote>\n<p>前端写法与SSE类似，十分简单，只不过请求链接为ws:&#x2F;&#x2F;或者wss:&#x2F;&#x2F;开头（相当于http:&#x2F;&#x2F;和https:&#x2F;&#x2F;）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:3000/ws&#x27;</span>);<br>ws.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(e.<span class=\"hljs-property\">data</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>如果要用原生Node.js来写WebSocket服务，就会麻烦一些了，一般情况都会使用类似socket.io之类的三方库来降低实现成本。这边也就在网上摘抄了一段代码来简单实现一下<br>后端写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">server.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;upgrade&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, socket</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> acceptKey = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&#x27;sec-websocket-key&#x27;</span>];<br>  <span class=\"hljs-keyword\">const</span> hash = <span class=\"hljs-title function_\">generateAcceptValue</span>(acceptKey);<br>  <span class=\"hljs-comment\">// 生成响应头信息</span><br>  <span class=\"hljs-keyword\">const</span> responseHeaders = [ <span class=\"hljs-string\">&#x27;HTTP/1.1 101 Web Socket Protocol Handshake&#x27;</span>, <span class=\"hljs-string\">&#x27;Upgrade: WebSocket&#x27;</span>, <span class=\"hljs-string\">&#x27;Connection: Upgrade&#x27;</span>, <span class=\"hljs-string\">`Sec-WebSocket-Accept: <span class=\"hljs-subst\">$&#123;hash&#125;</span>`</span> ];<br>  <span class=\"hljs-comment\">// 告知前端这是WebSocket协议</span><br>  socket.<span class=\"hljs-title function_\">write</span>(responseHeaders.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;\\r\\n&#x27;</span>) + <span class=\"hljs-string\">&#x27;\\r\\n\\r\\n&#x27;</span>);<br>  <span class=\"hljs-comment\">// 发送数据</span><br>  socket.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-title function_\">constructReply</span>(datas));<br>  callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br>    socket.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-title function_\">constructReply</span>(d));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>Websocket没有像SSE一样有自动重连，这块需要自行实现。一般网页实时聊天之类需要双向推送的，都会使用WebSocket来实现。</p>\n<blockquote>\n<ol start=\"5\">\n<li>iFrame<br>原理类似使用iFrame加载一个巨大的网页，利用浏览器会一边加载一边解析执行返回的HTML，通过分次返回Script标签来实现消息推送。其实现类似SSE</li>\n</ol>\n</blockquote>\n<p>前端代码很简单，要注册一个回调给iframe使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 注册给iframe使用的方法</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">change</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) &#123;&#125;;<br>$(<span class=\"hljs-string\">&#x27;body&#x27;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;&lt;iframe src=&quot;/api/iframe&quot;&gt;&lt;/iframe&gt;&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>后端也很简单，有消息的时候返回script标签即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 有推送消息返回缓存信息</span><br>res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`&lt;script&gt;window.parent.change(<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(datas)&#125;</span>);&lt;/script&gt;`</span>);<br><span class=\"hljs-comment\">// 注册消息回调</span><br>callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br>  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`&lt;script&gt;window.parent.change(<span class=\"hljs-subst\">$&#123;d&#125;</span>);&lt;/script&gt;`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>iFrame这种方式缺点没有判断加载异常的情况</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>方案</th>\n<th align=\"center\">实时性</th>\n<th align=\"center\">单次连接</th>\n<th align=\"center\">自动重连</th>\n<th align=\"center\">断线检测</th>\n<th align=\"center\">双向推送</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>短轮询</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">➖</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td>长轮询</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">➖</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td>SSE</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n</tr>\n<tr>\n<td>iFrame</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"wordcount":4384,"excerpt":"","more":"<h2 id=\"服务端向web前端推送消息常用方式\"><a href=\"#服务端向web前端推送消息常用方式\" class=\"headerlink\" title=\"服务端向web前端推送消息常用方式\"></a>服务端向web前端推送消息常用方式</h2><h3 id=\"问题出现场景\"><a href=\"#问题出现场景\" class=\"headerlink\" title=\"问题出现场景\"></a>问题出现场景</h3><ul>\n<li>面试官向你提问，说说如何实现服务端向web前端推送数据？😂</li>\n<li>实际开发中当前端页面在挂起状态，这时候服务端推送了一条消息需要前端展示（单向推送）</li>\n<li>web页面实时聊天功能（双向推送）</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>主要写了5种方案，分别介绍下实现以及运用场景</p>\n<blockquote>\n<ol>\n<li>轮询（短轮询）<br>这是最简单直观的方法，就是每隔一段时间发起一个请求到后端询问是否有新信息。至于为什么又叫短轮询，其是相对于后续要说的长轮询来对比的。</li>\n</ol>\n</blockquote>\n<p>前端写法只要设置一个setTimeout来定时请求就行</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 缓存前端已经获取的最新id</span><br><span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">poll</span>(<span class=\"hljs-params\"></span>) &#123;<br>  $.<span class=\"hljs-title function_\">ajax</span>(&#123;<br>    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;/api/polling&#x27;</span>,<br>    <span class=\"hljs-attr\">data</span>: &#123; id &#125;,<br>  &#125;).<span class=\"hljs-title function_\">done</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>    id += res.<span class=\"hljs-property\">length</span>;<br>  &#125;).<span class=\"hljs-title function_\">always</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-comment\">// 10s后再次请求</span><br>    <span class=\"hljs-built_in\">setTimeout</span>(poll, <span class=\"hljs-number\">10000</span>);<br>  &#125;);<br>&#125;<br><span class=\"hljs-title function_\">poll</span>();<br></code></pre></td></tr></table></figure>\n<p>后端写法，根据前端给到的id，看看有没有新消息，有就返回，没有就返回空</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">parseInt</span>(query.<span class=\"hljs-property\">id</span> || <span class=\"hljs-string\">&#x27;0&#x27;</span>, <span class=\"hljs-number\">10</span>) || <span class=\"hljs-number\">0</span>;<br>res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123; <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json;&#x27;</span> &#125;);<br>res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(datas.<span class=\"hljs-title function_\">slice</span>(id)));<br></code></pre></td></tr></table></figure>\n<p>这种方式不需要后端实现消息推送改造，只需要前端定时请求后端接口其实时性与请求频率成正相关，但是当请求频率上来了，性能浪费也就越高，毕竟可能大部分请求都是无意义的。</p>\n<blockquote>\n<ol start=\"2\">\n<li>长轮询<br>这里的长轮询相对前面的轮询来说，算是一种优化。具体就是前端发起请求到后端，后端不直接返回，而是等待有新信息时再返回。所以这样发起的一个请求，可能需要很长的时间才能等到返回，故而叫做长轮询。</li>\n</ol>\n</blockquote>\n<p>其前端代码基本和短轮询一致，只不过把请求的超时时间设置较长（比如1分钟），然后无论请求成功或失败，马上再次发起请求即可。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">poll</span>(<span class=\"hljs-params\"></span>) &#123;<br>  $.<span class=\"hljs-title function_\">ajax</span>(&#123;<br>    <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;/api/long-polling&#x27;</span>,<br>    <span class=\"hljs-attr\">data</span>: &#123; id &#125;,<br>    <span class=\"hljs-attr\">timeout</span>: <span class=\"hljs-number\">60000</span>, <span class=\"hljs-comment\">// 请求的超时时间设置较长</span><br>  &#125;).<span class=\"hljs-title function_\">done</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>    id += res.<span class=\"hljs-property\">length</span><br>  &#125;).<span class=\"hljs-title function_\">always</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(poll, <span class=\"hljs-number\">1000</span>)<br>  &#125;)<br>&#125;<br><span class=\"hljs-title function_\">poll</span>()<br></code></pre></td></tr></table></figure>\n<p>后端写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-built_in\">parseInt</span>(query.<span class=\"hljs-property\">id</span> || <span class=\"hljs-string\">&#x27;0&#x27;</span>, <span class=\"hljs-number\">10</span>) || <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">const</span> cbk = <span class=\"hljs-string\">&#x27;long-polling&#x27;</span>;<br><span class=\"hljs-keyword\">delete</span> callbacks[cbk];<br><span class=\"hljs-keyword\">const</span> data = datas.<span class=\"hljs-title function_\">slice</span>(id);<br>res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123; <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span> &#125;);<br><span class=\"hljs-comment\">// 发起请求时，正好有新消息就返回</span><br><span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">length</span>) &#123;<br> <span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data));<br>&#125;<br><span class=\"hljs-comment\">// 注册新消息回调</span><br>callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br> res.<span class=\"hljs-title function_\">end</span>(d);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>这样，相对于短轮询，少了很多无意义的请求，而且消息的实时性也非常好。缺点就是当服务端有异常时，会导致长轮询短时间内不断发起请求，可能让服务端承受更大的压力，所以两次长轮询之间最好有一定间隔，或者异常检测机制。</p>\n<blockquote>\n<ol start=\"3\">\n<li>SSE（Server-sent events）<br>前面提到的轮询、长轮询都是一问一答式的，一次请求，无法推送多次消息到前端。而SSE就厉害了，一次请求，N次推送。<br>其原理可以理解为下载一个巨大的文件，文件的内容分块传给前端，每块就是一次消息推送。</li>\n</ol>\n</blockquote>\n<p>前端写法，有专门的EventSource来接收，使用起来很方便</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> id = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">const</span> es = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventSource</span>(<span class=\"hljs-string\">&#x27;/api/sse&#x27;</span>)<br>es.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(e.<span class=\"hljs-property\">data</span>)<br>  &#125; <span class=\"hljs-keyword\">catch</span> (e) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e)<br>  &#125;<br>&#125;<br>es.<span class=\"hljs-property\">onopen</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">pushStatus</span>(s, <span class=\"hljs-string\">&#x27;等待消息中&#x27;</span>, <span class=\"hljs-string\">&#x27;success&#x27;</span>)<br>&#125;<br>es.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">pushStatus</span>(s, <span class=\"hljs-string\">&#x27;连接错误&#x27;</span>, <span class=\"hljs-string\">&#x27;danger&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>后端写法，核心在于Content-Type: text&#x2F;event-stream，这要让前端知道这是SSE，还有就是传输信息的格式比较特别一点，详细的可以看 MDN（ <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events\">https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events</a> ）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">res.<span class=\"hljs-title function_\">writeHead</span>(<span class=\"hljs-number\">200</span>, &#123;<br>  <span class=\"hljs-comment\">// 这个是核心</span><br>  <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;text/event-stream&#x27;</span>,<br>  <span class=\"hljs-string\">&#x27;Connection&#x27;</span>: <span class=\"hljs-string\">&#x27;keep-alive&#x27;</span>,<br>&#125;);<br><span class=\"hljs-comment\">// 把缓存的信息推送给前端</span><br>res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`data: <span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(datas)&#125;</span>\\n\\n`</span>);<br><span class=\"hljs-comment\">// 注册新消息回调</span><br>callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br>  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`data: <span class=\"hljs-subst\">$&#123;d&#125;</span>\\n\\n`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>SSE还支持自动重连！服务器短时间异常，恢复之后，无需额外代码，SSE就自动重连上了。</p>\n<blockquote>\n<ol start=\"4\">\n<li>WebSocket<br>WebSocket可以一次连接，双向推送，而SSE只能从服务端推送到前端。从这个角度来看，用WebSocket来单做服务端推送，有点大材小用了。</li>\n</ol>\n</blockquote>\n<p>前端写法与SSE类似，十分简单，只不过请求链接为ws:&#x2F;&#x2F;或者wss:&#x2F;&#x2F;开头（相当于http:&#x2F;&#x2F;和https:&#x2F;&#x2F;）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">WebSocket</span>(<span class=\"hljs-string\">&#x27;ws://localhost:3000/ws&#x27;</span>);<br>ws.<span class=\"hljs-property\">onmessage</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> c = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(e.<span class=\"hljs-property\">data</span>);<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>如果要用原生Node.js来写WebSocket服务，就会麻烦一些了，一般情况都会使用类似socket.io之类的三方库来降低实现成本。这边也就在网上摘抄了一段代码来简单实现一下<br>后端写法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">server.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;upgrade&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">req, socket</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> acceptKey = req.<span class=\"hljs-property\">headers</span>[<span class=\"hljs-string\">&#x27;sec-websocket-key&#x27;</span>];<br>  <span class=\"hljs-keyword\">const</span> hash = <span class=\"hljs-title function_\">generateAcceptValue</span>(acceptKey);<br>  <span class=\"hljs-comment\">// 生成响应头信息</span><br>  <span class=\"hljs-keyword\">const</span> responseHeaders = [ <span class=\"hljs-string\">&#x27;HTTP/1.1 101 Web Socket Protocol Handshake&#x27;</span>, <span class=\"hljs-string\">&#x27;Upgrade: WebSocket&#x27;</span>, <span class=\"hljs-string\">&#x27;Connection: Upgrade&#x27;</span>, <span class=\"hljs-string\">`Sec-WebSocket-Accept: <span class=\"hljs-subst\">$&#123;hash&#125;</span>`</span> ];<br>  <span class=\"hljs-comment\">// 告知前端这是WebSocket协议</span><br>  socket.<span class=\"hljs-title function_\">write</span>(responseHeaders.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;\\r\\n&#x27;</span>) + <span class=\"hljs-string\">&#x27;\\r\\n\\r\\n&#x27;</span>);<br>  <span class=\"hljs-comment\">// 发送数据</span><br>  socket.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-title function_\">constructReply</span>(datas));<br>  callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br>    socket.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-title function_\">constructReply</span>(d));<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>Websocket没有像SSE一样有自动重连，这块需要自行实现。一般网页实时聊天之类需要双向推送的，都会使用WebSocket来实现。</p>\n<blockquote>\n<ol start=\"5\">\n<li>iFrame<br>原理类似使用iFrame加载一个巨大的网页，利用浏览器会一边加载一边解析执行返回的HTML，通过分次返回Script标签来实现消息推送。其实现类似SSE</li>\n</ol>\n</blockquote>\n<p>前端代码很简单，要注册一个回调给iframe使用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 注册给iframe使用的方法</span><br><span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">change</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">data</span>) &#123;&#125;;<br>$(<span class=\"hljs-string\">&#x27;body&#x27;</span>).<span class=\"hljs-title function_\">append</span>(<span class=\"hljs-string\">&#x27;&lt;iframe src=&quot;/api/iframe&quot;&gt;&lt;/iframe&gt;&#x27;</span>);<br></code></pre></td></tr></table></figure>\n<p>后端也很简单，有消息的时候返回script标签即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 有推送消息返回缓存信息</span><br>res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`&lt;script&gt;window.parent.change(<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(datas)&#125;</span>);&lt;/script&gt;`</span>);<br><span class=\"hljs-comment\">// 注册消息回调</span><br>callbacks[cbk] = <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> &#123;<br>  res.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">`&lt;script&gt;window.parent.change(<span class=\"hljs-subst\">$&#123;d&#125;</span>);&lt;/script&gt;`</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>iFrame这种方式缺点没有判断加载异常的情况</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><table>\n<thead>\n<tr>\n<th>方案</th>\n<th align=\"center\">实时性</th>\n<th align=\"center\">单次连接</th>\n<th align=\"center\">自动重连</th>\n<th align=\"center\">断线检测</th>\n<th align=\"center\">双向推送</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>短轮询</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">➖</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td>长轮询</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">➖</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td>SSE</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td>WebSocket</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n</tr>\n<tr>\n<td>iFrame</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">✅</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n</tr>\n</tbody></table>\n"},{"title":"hooks简介","date":"2024-07-24T05:58:30.000Z","_content":"\n# [React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020) Hooks\n\n## Hooks简介\n\n> 介绍Hooks之前，首先要说一下React的组件创建方式，一种是类组件，一种是纯函数组件，并且React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。也就是说组件的最佳写法应该是函数，而不是类。\n\n但是，在以往开发中类组件和纯函数组件的区别是很大的，纯函数组件有着类组件不具备的多种特点：\n\n- 纯函数组件没有状态\n- 纯函数组件没有生命周期\n- 纯函数组件没有this\n\n这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，不得不用类组件或者redux，但类组件也是有缺点的，比如，遇到简单的页面，代码会显得很重，并且每创建一个类组件，都要去继承一个React实例\n\n**React Hooks：** 就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。\n\n这时候认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。\n\n**使用Hooks的优点：**\n\n- 告别难以理解的Class( this 和 生命周期 的痛点)\n- 解决业务逻辑难以拆分的问题\n- 使状态逻辑复用变得简单可行\n- 函数组件从设计思想上来看更加契合React的理念\n\n**Hooks并非万能：**\n\n- Hooks暂时还不能完全的为函数组件补齐类组件地能力（如生命周期的getSnapshotBeforeUpdate、componentDidCatch方法暂时还未实现）\n- 将类组件的复杂变成函数组件的轻量，可能使用者并不能很好地消化这种复杂\n- Hooks在使用层面有着严格地规则约束\n\n**例如：类组件实现计数器：**\n\n```javascript\nimport React, {Component} from \"react\";\nclass AddCount extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            count : 0\n        }\n    }\n    addcount = () => {\n        let newCount = this.state.count;\n        this.setState({\n            count: newCount += 1\n        })\n    }\n    render() {\n        return (\n            <>\n                <p>{ this.state.count }</p>\n                <button onClick={ this.addcount }>count++</button>\n            </>\n        )\n    }\n}\nexport default AddCount;\n```\n\n可以看出来，上面的代码确实很重。因此React队设计了React Hooks。React Hooks就是加强版的函数组件，可以完全不使用 class，就能写出一个全功能的组件\n\nReact Hooks 使得组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码\"钩\"进来。而React Hooks 就是所说的“钩子”。\n\n那么Hooks要怎么用呢？“你需要写什么功能，就用什么钩子”。对于常见的功能，React为我们提供了一些常用的钩子，当然有特殊需要，我们也可以写自己的钩子。下面是React Hooks为我们提供的默认的四种最常用钩子：\n\n- useState()\n- useContext()\n- useEffect()\n- useReducer()\n\n不同的钩子为函数引入不同的外部功能，上面四种钩子都带有use前缀，React Hooks约定，钩子一律使用use前缀命名。所以，自己定义的钩子都要命名为useXXX。\n\n## Hook函数（9种）\n\n---\n\n**1、State Hook**\n\nuseState()：状态钩子。纯函数组件没有状态，**用于为函数组件引入state状态, 并进行状态数据的读写操作**\n\n**语法、参数及返回值说明:：**\n\n```javascript\nconst [xxx, setXxx] = React.useState(initValue) \n```\n\n- **参数:** 第一次初始化指定的值在内部作缓存\n- **返回值:** 包含2个元素的数组，第1个为内部当前状态值，第2个为更新状态值的函数\n\n**setXxx()2种写法:**\n\n- **setXxx(newValue)**: 参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值\n- **setXxx(value => newValue)**: 参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值\n\n**例如：React Hooks 实现计数器：**\n\n```javascript\nimport React,{ useState } from \"react\";\n\nconst NewCount = ()=> {\n    const [ count,setCount ] = useState(0)\n    addCount = ()=> {\n        let newCount = count;\n        setCount(newCount +=1)\n    }\n   return (\n       <>\n           <p> { count }</p>\n           <button onClick={ addCount }>Count++</button>\n       </>\n   )\n}\nexport default NewCount;\n```\n\n代码看起来更加的轻便简洁，没有了继承，没有了渲染逻辑，没有了[生命周期](https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020)等\n\n---\n\n**2、Context Hook**\n\nuseContext()：共享状态钩子。**作用就是可以做状态的分发**，在React16.X以后支持，避免了react逐层通过Props传递数据。\n\n> Context：一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信\n\n**使用语法和说明：**\n\n1. 创建Context容器对象：\n    \n    ```javascript\n    const XxxContext = React.createContext()  \n    ```\n    \n2. 渲染子组件时，外面包裹xxxContext.Provider， 通过value属性给后代组件传递数据：\n    \n    ```javascript\n    <xxxContext.Provider value={数据}>\n    \t<子组件/>\n    </xxxContext.Provider>\n    ```\n    \n3. 后代组件读取数据：\n    \n    ```javascript\n    const {} = useContext(XxxContext)\n    ```\n    \n\n**例如：A组件和B组件需要共享一个状态:**\n\n```javascript\nimport React, { useContext } from \"react\";\nconst HookTest = ()=> {\n    const AppContext = React.createContext();\n    const A = ()=> {\n        const { name } = useContext(AppContext)\n        return (\n            <p>\n                我是A组件,我的名字是：{ name }；\n                <span>我是A的子标签：{ name }</span>\n            </p>\n        )\n    }\n    const B= ()=> {\n        const { name } = useContext(AppContext);\n        return (\n            <p>我是B组件,名字是： { name }</p>\n        )\n    }\n    return (\n        <AppContext.Provider value={{ name: '张三'}}>\n            <A />\n            <B />\n        </AppContext.Provider>\n    )\n}\nexport default HookTest;\n```\n\n---\n\n**3、Effect Hook**\n\nuseEffect()：副作用钩子。**用来更好的执行副作用操作**(用于模拟类组件中的生命周期钩子)，如异步请求等，在类组件中会把请求放在componentDidMount里面，在函数组件中可以使用useEffect()\n\n**语法和说明:**\n\n```javascript\nuseEffect(() => { \n      // 在此可以执行任何带副作用操作\n      return () => { // 在组件卸载前执行\n        // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n      }\n}, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n```\n\n**参数、返回值说明：**\n\n- useEffect()接受两个参数，**第一个参数是要进行的异步操作**，**第二个参数是一个数组**，用来给出Effect的**依赖项**，只要这个数组发生变化，useEffect()就会执行。\n- 当第二项省略不填时。useEffect()会在每次组件渲染时都会执行useEffect，只要更新就会执行。\n- 当第二项传 **空数组\\[ \\]** 时，只会在组件挂载后运行一次。\n- useEffect()返回值可以是一个函数，在组件销毁的时候会被调用。清理这些副作用可以进行如取消订阅、清除定时器操作，类似于componentWillUnmount。\n\n**React中的副作用操作:**\n\n- 发ajax请求数据获取\n- 设置订阅 / 启动定时器\n- 手动更改真实DOM\n\n**useEffect两个注意点：**\n\n- React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前要用两个生命周期函数分别表示 **首次渲染(componentDidMonut)** 和**更新导致的重新渲染(componentDidUpdate)**\n- useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。\n\n**总结：** 可以把 useEffect Hook 看做如下三个函数的组合 ：**componentDidMount()、componentDidUpdate()、componentWillUnmount()**\n\n1、类似于componentDidMount的useEffect\n\n```javascript\nimport { useEffect } from 'react'\n\nconst Demo = () => {\n  useEffcet(() => {\n\tconsole.log('类似于componentDidMount，通常在此处调用api获取数据')\n  }, [])\n}\n\nexport default Demo\n```\n\n2、类似于componentWillUnmount的useEffect\n\n```javascript\nimport { useEffect } from 'react'\n\nconst Demo = () => {\n  useEffcet(() => {\n\treturn () => {\n\t  console.log('类似于componentWillUnmount，通常用于清除副作用');\n\t}\n  }, [])\n}\n\nexport default Demo\n```\n\n3、类似于componentDidUpdate的useEffect\n\n```javascript\nimport { useState,useEffect } from 'react'\n\nconst Demo = () => {\n  const [count,setCount] = React.useState(0)\n\t\n  useEffcet(() => {\n\tconsole.log('当count发生改变时，执行当前区域的代码')\n  }, [count])\n}\n```\n\n---\n\n**4、Reducer Hook**\n\nuseReducer()：Action钩子。在使用React的过程中，如遇到状态管理，一般会用到Redux。而React本身是不提供状态管理的。而useReducer() **提供了状态管理**。\n\n首先，关于redux我们都知道，其原理是**通过用户在页面中发起action，从而通过reducer方法来改变state，从而实现页面和状态的通信。**\n\n而Reducer的形式是(state, action) => newstate。hooks的形式如下：\n\n**语法格式：**\n\n```javascript\nconst [state, dispatch] = useReducer(reducer, initialState)\n```\n\n**参数、返回值说明：**\n\n它接受 **reducer函数** 和 **状态的初始值** 作为参数，返回一个**数组**，其中第一项为**当前的状态值**，第二项为**发送action的dispatch函数**。\n\n**例如：使用useReducer()实现一个计数器**\n\n```javascript\nimport  { useReducer } from \"react\";\nconst HookReducer = ()=> {\n    const reducer = (state,action)=> {\n        if (action.type === 'add') {\n            return {\n                ...state,\n                count: state.count + 1\n            }\n        }else {\n            return state\n        }\n    }\n    const addCount = ()=> {\n        dispatch({\n            type: 'add'\n        })\n    }\n    const [state,dispatch ] = useReducer(reducer,{count: 0})\n    return (\n        <>\n            <p>{state.count}</p>\n            <button onClick={ addCount }>useReducer</button>\n        </>\n    )\n}\nexport default HookReducer;\n```\n\n通过代码可以看到，使用useReducer()代替了Redux的功能，但useReducer无法提供中间件等功能，假如有这些需求，还是需要用到redux。\n\n---\n\n**5、Ref Hook**\n\nuserRefef()：Ref Hook可以**在函数组件中存储、查找组件内的标签或任意其它数据**\n\n**语法和参数说明：**\n\n```javascript\nconst refContainer = useRef()\n```\n\nuseRef返回一个可变的ref对象，useRef接受一个参数绑定在返回的ref对象的current属性上，返回的ref对象在整个生命周期中保持不变。\n\n作用：保存标签对象，功能与React.createRef()一样\n\n**例子：input上绑定一个ref，使得input在渲染后自动焦点聚焦**\n\n```javascript\nimport{ useRef,useEffect} from \"react\";\nconst RefComponent = () => {\n    let inputRef = useRef(null);\n    useEffect(() => {\n        inputRef.current.focus();\n    })\n    return (\n        <input type=\"text\" ref={inputRef}/>\n    ) \n}\n```\n\n---\n\n**6、Memo Hook**\n\nuseMemo()： 主要**用来解决使用React hooks产生的无用渲染的性能问题**。\n\n**语法和参数说明：**\n\n```javascript\nconst cacheSomething = useMemo(create,deps)\n```\n\n- `create`：第一个参数为一个函数，函数的返回值作为缓存值\n- `deps`： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。\n- `cacheSomething`：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存\n\n使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说没有办法通过组件更新前条件来决定组件是否更新。\n\n而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。\n\n**useMemo原理：**\n\nuseMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。\n\n**useMemo应用场景：**\n\n- 可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。\n- 如果组件中不期望每次 render 都重新计算一些值，可以利用 useMemo 把它缓存起来。\n- 可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用\n\n---\n\n**7、Callback Hook**\n\nuseCallback()： 主要**是为了性能的优化**\n\n**useCallback(fn, deps) 相当于 useMemo(() => fn, deps)**\n\n可以认为是对依赖项的监听，接受一个**回调函数**和**依赖项数组**。\n\n- useCallback会返回一个函数的memoized(记忆的)值。\n- 该回调函数仅在某个依赖项改变时才会\n- 在依赖不变的情况下，多次定义的时候，返回的值是相同的\n\n```javascript\nimport {useState,useCallback} from \"react\";\n\nconst CallbackComponent = () => {\n    let [count, setCount] = useState(1);\n    let [num, setNum] = useState(1);\n\n    const memoized = useCallback(() => {\n        return num;\n    }, [count])\n    console.log(\"记忆：\", memoized());\n    console.log(\"原始：\", num);\n   return (\n        <>\n            <button onClick={() => {setCount(count + 1)}}> count+</button>\n            <button onClick={() => {setNum(num + 1)}}> num+</button>\n        </>\n    )\n}\nexport default CallbackComponent\n```\n\n如果没有传入依赖项数组，那么记忆函数在每次渲染的时候都会更新。\n\n---\n\n**8、LayoutEffect Hook**\n\nuseLayoutEffect() ：和useEffect相同，**都是用来执行副作用，但是它会在所有的DOM变更之后同步调用effect**。useLayoutEffect和useEffect最大的区别就是一个是同步，一个是异步。\n\n从这个Hook的名字上也可以看出，它主要用来读取DOM布局并触发同步渲染，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。\n\n官网建议还是尽可能的是使用标准的useEffec以避免阻塞视觉更新。\n\n---\n\n**9、ImperativeHandle Hook**\n\nuseImperativeHandle()： 可以**在使用 ref 时自定义暴露给父组件的实例值。**\n\n就是说：当使用父组件把ref传递给子组件的时候，这个Hook允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。\n\n**使用方式：**\n\n```javascript\nimport {useEffect,useRef,useImperativeHandle} from \"react\";\nimport {forwardRef} from \"react\";\n\nfunction FancyInput(props, ref) {\n    const inputRef = useRef();\n    useImperativeHandle(ref, () => ({\n        focus: () => {\n            inputRef.current.value=\"Hello\";\n        }\n    }));\n    return <input ref={inputRef} />;\n}\nFancyInput = forwardRef(FancyInput);\n\nconst ImperativeHandleTest=() => {\n    let ref = useRef(null);\n    useEffect(() => {\n        console.log(ref);\n        ref.current.focus();\n    })\n    return (\n        <>\n            <FancyInput ref={ref}/>\n        </>\n    )\n}\nexport default ImperativeHandleTest\n```\n\n## 自定义Hooks\n\n> 有时候我们需要创建自己想要的Hooks，来满足更便捷的开发，就是根据业务场景对其它Hooks进行组装，从而得到满足自己需求的钩子。\n\n**自定义 Hooks：是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook**\n\n**自定义Hooks：可以封装状态，能够更好的实现状态共享**\n\n自定义hooks可以说成是一种约定而不是功能。当一个函数以use开头并且在函数内部调用其他hooks，那么这个函数就可以成为自定义hooks\n\n**例如：**\n\n```javascript\nimport { useState,useEffect } from \"react\";\nconst usePerson = ({name}) => {\n    const [loading, setLoading] = useState(true)\n    const [person, setPerson] = useState({})\n\n    useEffect(() => {\n        setLoading(true)\n        setTimeout(()=> {\n            setLoading(false)\n            setPerson({name})\n        },2000)\n    },[name])\n    return [loading,person]\n}\nconst AsyncPage = (name)=> {\n    const [loading,person] = usePerson(name)\n    return (\n        <>\n            {loading?<p>Loading...</p>:<p>{ person.name }</p>}\n        </>\n    )\n}\n\nconst PersonPage = ()=> {\n    const [state,setState] = useState('')\n    const changeName = (name)=> {\n        setState(name)\n    }\n    return (\n        <>\n            <AsyncPage name={ state } />\n            <button onClick={ ()=> { changeName('郭靖')}}>郭靖</button>\n            <button onClick={ ()=> { changeName('黄蓉')}}>黄蓉</button>\n        </>\n    )\n}\nexport default PersonPage;\n\n```\n\n上面代码中，封装成了自己的Hooks，便于共享。其中，usePerson()为自定义Hooks它接受一个字符串，返回一个数组，数组中包括两个数据的状态，之后在使用usePerson()时，会根据传入的参数不同而返回不同的状态，然后很简便的应用于我们的页面中。\n\n这是一种非常简单的自定义Hook。如果项目大的话使用自定义Hook会抽离可以抽离公共代码，极大的减少我们的代码量，提高开发效率。","source":"_posts/hooks.md","raw":"---\ntitle: hooks简介\ndate: 2024-07-24 13:58:30\ntags: js\n---\n\n# [React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020) Hooks\n\n## Hooks简介\n\n> 介绍Hooks之前，首先要说一下React的组件创建方式，一种是类组件，一种是纯函数组件，并且React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。也就是说组件的最佳写法应该是函数，而不是类。\n\n但是，在以往开发中类组件和纯函数组件的区别是很大的，纯函数组件有着类组件不具备的多种特点：\n\n- 纯函数组件没有状态\n- 纯函数组件没有生命周期\n- 纯函数组件没有this\n\n这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，不得不用类组件或者redux，但类组件也是有缺点的，比如，遇到简单的页面，代码会显得很重，并且每创建一个类组件，都要去继承一个React实例\n\n**React Hooks：** 就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。\n\n这时候认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。\n\n**使用Hooks的优点：**\n\n- 告别难以理解的Class( this 和 生命周期 的痛点)\n- 解决业务逻辑难以拆分的问题\n- 使状态逻辑复用变得简单可行\n- 函数组件从设计思想上来看更加契合React的理念\n\n**Hooks并非万能：**\n\n- Hooks暂时还不能完全的为函数组件补齐类组件地能力（如生命周期的getSnapshotBeforeUpdate、componentDidCatch方法暂时还未实现）\n- 将类组件的复杂变成函数组件的轻量，可能使用者并不能很好地消化这种复杂\n- Hooks在使用层面有着严格地规则约束\n\n**例如：类组件实现计数器：**\n\n```javascript\nimport React, {Component} from \"react\";\nclass AddCount extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            count : 0\n        }\n    }\n    addcount = () => {\n        let newCount = this.state.count;\n        this.setState({\n            count: newCount += 1\n        })\n    }\n    render() {\n        return (\n            <>\n                <p>{ this.state.count }</p>\n                <button onClick={ this.addcount }>count++</button>\n            </>\n        )\n    }\n}\nexport default AddCount;\n```\n\n可以看出来，上面的代码确实很重。因此React队设计了React Hooks。React Hooks就是加强版的函数组件，可以完全不使用 class，就能写出一个全功能的组件\n\nReact Hooks 使得组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码\"钩\"进来。而React Hooks 就是所说的“钩子”。\n\n那么Hooks要怎么用呢？“你需要写什么功能，就用什么钩子”。对于常见的功能，React为我们提供了一些常用的钩子，当然有特殊需要，我们也可以写自己的钩子。下面是React Hooks为我们提供的默认的四种最常用钩子：\n\n- useState()\n- useContext()\n- useEffect()\n- useReducer()\n\n不同的钩子为函数引入不同的外部功能，上面四种钩子都带有use前缀，React Hooks约定，钩子一律使用use前缀命名。所以，自己定义的钩子都要命名为useXXX。\n\n## Hook函数（9种）\n\n---\n\n**1、State Hook**\n\nuseState()：状态钩子。纯函数组件没有状态，**用于为函数组件引入state状态, 并进行状态数据的读写操作**\n\n**语法、参数及返回值说明:：**\n\n```javascript\nconst [xxx, setXxx] = React.useState(initValue) \n```\n\n- **参数:** 第一次初始化指定的值在内部作缓存\n- **返回值:** 包含2个元素的数组，第1个为内部当前状态值，第2个为更新状态值的函数\n\n**setXxx()2种写法:**\n\n- **setXxx(newValue)**: 参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值\n- **setXxx(value => newValue)**: 参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值\n\n**例如：React Hooks 实现计数器：**\n\n```javascript\nimport React,{ useState } from \"react\";\n\nconst NewCount = ()=> {\n    const [ count,setCount ] = useState(0)\n    addCount = ()=> {\n        let newCount = count;\n        setCount(newCount +=1)\n    }\n   return (\n       <>\n           <p> { count }</p>\n           <button onClick={ addCount }>Count++</button>\n       </>\n   )\n}\nexport default NewCount;\n```\n\n代码看起来更加的轻便简洁，没有了继承，没有了渲染逻辑，没有了[生命周期](https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020)等\n\n---\n\n**2、Context Hook**\n\nuseContext()：共享状态钩子。**作用就是可以做状态的分发**，在React16.X以后支持，避免了react逐层通过Props传递数据。\n\n> Context：一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信\n\n**使用语法和说明：**\n\n1. 创建Context容器对象：\n    \n    ```javascript\n    const XxxContext = React.createContext()  \n    ```\n    \n2. 渲染子组件时，外面包裹xxxContext.Provider， 通过value属性给后代组件传递数据：\n    \n    ```javascript\n    <xxxContext.Provider value={数据}>\n    \t<子组件/>\n    </xxxContext.Provider>\n    ```\n    \n3. 后代组件读取数据：\n    \n    ```javascript\n    const {} = useContext(XxxContext)\n    ```\n    \n\n**例如：A组件和B组件需要共享一个状态:**\n\n```javascript\nimport React, { useContext } from \"react\";\nconst HookTest = ()=> {\n    const AppContext = React.createContext();\n    const A = ()=> {\n        const { name } = useContext(AppContext)\n        return (\n            <p>\n                我是A组件,我的名字是：{ name }；\n                <span>我是A的子标签：{ name }</span>\n            </p>\n        )\n    }\n    const B= ()=> {\n        const { name } = useContext(AppContext);\n        return (\n            <p>我是B组件,名字是： { name }</p>\n        )\n    }\n    return (\n        <AppContext.Provider value={{ name: '张三'}}>\n            <A />\n            <B />\n        </AppContext.Provider>\n    )\n}\nexport default HookTest;\n```\n\n---\n\n**3、Effect Hook**\n\nuseEffect()：副作用钩子。**用来更好的执行副作用操作**(用于模拟类组件中的生命周期钩子)，如异步请求等，在类组件中会把请求放在componentDidMount里面，在函数组件中可以使用useEffect()\n\n**语法和说明:**\n\n```javascript\nuseEffect(() => { \n      // 在此可以执行任何带副作用操作\n      return () => { // 在组件卸载前执行\n        // 在此做一些收尾工作, 比如清除定时器/取消订阅等\n      }\n}, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行\n```\n\n**参数、返回值说明：**\n\n- useEffect()接受两个参数，**第一个参数是要进行的异步操作**，**第二个参数是一个数组**，用来给出Effect的**依赖项**，只要这个数组发生变化，useEffect()就会执行。\n- 当第二项省略不填时。useEffect()会在每次组件渲染时都会执行useEffect，只要更新就会执行。\n- 当第二项传 **空数组\\[ \\]** 时，只会在组件挂载后运行一次。\n- useEffect()返回值可以是一个函数，在组件销毁的时候会被调用。清理这些副作用可以进行如取消订阅、清除定时器操作，类似于componentWillUnmount。\n\n**React中的副作用操作:**\n\n- 发ajax请求数据获取\n- 设置订阅 / 启动定时器\n- 手动更改真实DOM\n\n**useEffect两个注意点：**\n\n- React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前要用两个生命周期函数分别表示 **首次渲染(componentDidMonut)** 和**更新导致的重新渲染(componentDidUpdate)**\n- useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。\n\n**总结：** 可以把 useEffect Hook 看做如下三个函数的组合 ：**componentDidMount()、componentDidUpdate()、componentWillUnmount()**\n\n1、类似于componentDidMount的useEffect\n\n```javascript\nimport { useEffect } from 'react'\n\nconst Demo = () => {\n  useEffcet(() => {\n\tconsole.log('类似于componentDidMount，通常在此处调用api获取数据')\n  }, [])\n}\n\nexport default Demo\n```\n\n2、类似于componentWillUnmount的useEffect\n\n```javascript\nimport { useEffect } from 'react'\n\nconst Demo = () => {\n  useEffcet(() => {\n\treturn () => {\n\t  console.log('类似于componentWillUnmount，通常用于清除副作用');\n\t}\n  }, [])\n}\n\nexport default Demo\n```\n\n3、类似于componentDidUpdate的useEffect\n\n```javascript\nimport { useState,useEffect } from 'react'\n\nconst Demo = () => {\n  const [count,setCount] = React.useState(0)\n\t\n  useEffcet(() => {\n\tconsole.log('当count发生改变时，执行当前区域的代码')\n  }, [count])\n}\n```\n\n---\n\n**4、Reducer Hook**\n\nuseReducer()：Action钩子。在使用React的过程中，如遇到状态管理，一般会用到Redux。而React本身是不提供状态管理的。而useReducer() **提供了状态管理**。\n\n首先，关于redux我们都知道，其原理是**通过用户在页面中发起action，从而通过reducer方法来改变state，从而实现页面和状态的通信。**\n\n而Reducer的形式是(state, action) => newstate。hooks的形式如下：\n\n**语法格式：**\n\n```javascript\nconst [state, dispatch] = useReducer(reducer, initialState)\n```\n\n**参数、返回值说明：**\n\n它接受 **reducer函数** 和 **状态的初始值** 作为参数，返回一个**数组**，其中第一项为**当前的状态值**，第二项为**发送action的dispatch函数**。\n\n**例如：使用useReducer()实现一个计数器**\n\n```javascript\nimport  { useReducer } from \"react\";\nconst HookReducer = ()=> {\n    const reducer = (state,action)=> {\n        if (action.type === 'add') {\n            return {\n                ...state,\n                count: state.count + 1\n            }\n        }else {\n            return state\n        }\n    }\n    const addCount = ()=> {\n        dispatch({\n            type: 'add'\n        })\n    }\n    const [state,dispatch ] = useReducer(reducer,{count: 0})\n    return (\n        <>\n            <p>{state.count}</p>\n            <button onClick={ addCount }>useReducer</button>\n        </>\n    )\n}\nexport default HookReducer;\n```\n\n通过代码可以看到，使用useReducer()代替了Redux的功能，但useReducer无法提供中间件等功能，假如有这些需求，还是需要用到redux。\n\n---\n\n**5、Ref Hook**\n\nuserRefef()：Ref Hook可以**在函数组件中存储、查找组件内的标签或任意其它数据**\n\n**语法和参数说明：**\n\n```javascript\nconst refContainer = useRef()\n```\n\nuseRef返回一个可变的ref对象，useRef接受一个参数绑定在返回的ref对象的current属性上，返回的ref对象在整个生命周期中保持不变。\n\n作用：保存标签对象，功能与React.createRef()一样\n\n**例子：input上绑定一个ref，使得input在渲染后自动焦点聚焦**\n\n```javascript\nimport{ useRef,useEffect} from \"react\";\nconst RefComponent = () => {\n    let inputRef = useRef(null);\n    useEffect(() => {\n        inputRef.current.focus();\n    })\n    return (\n        <input type=\"text\" ref={inputRef}/>\n    ) \n}\n```\n\n---\n\n**6、Memo Hook**\n\nuseMemo()： 主要**用来解决使用React hooks产生的无用渲染的性能问题**。\n\n**语法和参数说明：**\n\n```javascript\nconst cacheSomething = useMemo(create,deps)\n```\n\n- `create`：第一个参数为一个函数，函数的返回值作为缓存值\n- `deps`： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。\n- `cacheSomething`：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存\n\n使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说没有办法通过组件更新前条件来决定组件是否更新。\n\n而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。\n\n**useMemo原理：**\n\nuseMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。\n\n**useMemo应用场景：**\n\n- 可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。\n- 如果组件中不期望每次 render 都重新计算一些值，可以利用 useMemo 把它缓存起来。\n- 可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用\n\n---\n\n**7、Callback Hook**\n\nuseCallback()： 主要**是为了性能的优化**\n\n**useCallback(fn, deps) 相当于 useMemo(() => fn, deps)**\n\n可以认为是对依赖项的监听，接受一个**回调函数**和**依赖项数组**。\n\n- useCallback会返回一个函数的memoized(记忆的)值。\n- 该回调函数仅在某个依赖项改变时才会\n- 在依赖不变的情况下，多次定义的时候，返回的值是相同的\n\n```javascript\nimport {useState,useCallback} from \"react\";\n\nconst CallbackComponent = () => {\n    let [count, setCount] = useState(1);\n    let [num, setNum] = useState(1);\n\n    const memoized = useCallback(() => {\n        return num;\n    }, [count])\n    console.log(\"记忆：\", memoized());\n    console.log(\"原始：\", num);\n   return (\n        <>\n            <button onClick={() => {setCount(count + 1)}}> count+</button>\n            <button onClick={() => {setNum(num + 1)}}> num+</button>\n        </>\n    )\n}\nexport default CallbackComponent\n```\n\n如果没有传入依赖项数组，那么记忆函数在每次渲染的时候都会更新。\n\n---\n\n**8、LayoutEffect Hook**\n\nuseLayoutEffect() ：和useEffect相同，**都是用来执行副作用，但是它会在所有的DOM变更之后同步调用effect**。useLayoutEffect和useEffect最大的区别就是一个是同步，一个是异步。\n\n从这个Hook的名字上也可以看出，它主要用来读取DOM布局并触发同步渲染，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。\n\n官网建议还是尽可能的是使用标准的useEffec以避免阻塞视觉更新。\n\n---\n\n**9、ImperativeHandle Hook**\n\nuseImperativeHandle()： 可以**在使用 ref 时自定义暴露给父组件的实例值。**\n\n就是说：当使用父组件把ref传递给子组件的时候，这个Hook允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。\n\n**使用方式：**\n\n```javascript\nimport {useEffect,useRef,useImperativeHandle} from \"react\";\nimport {forwardRef} from \"react\";\n\nfunction FancyInput(props, ref) {\n    const inputRef = useRef();\n    useImperativeHandle(ref, () => ({\n        focus: () => {\n            inputRef.current.value=\"Hello\";\n        }\n    }));\n    return <input ref={inputRef} />;\n}\nFancyInput = forwardRef(FancyInput);\n\nconst ImperativeHandleTest=() => {\n    let ref = useRef(null);\n    useEffect(() => {\n        console.log(ref);\n        ref.current.focus();\n    })\n    return (\n        <>\n            <FancyInput ref={ref}/>\n        </>\n    )\n}\nexport default ImperativeHandleTest\n```\n\n## 自定义Hooks\n\n> 有时候我们需要创建自己想要的Hooks，来满足更便捷的开发，就是根据业务场景对其它Hooks进行组装，从而得到满足自己需求的钩子。\n\n**自定义 Hooks：是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook**\n\n**自定义Hooks：可以封装状态，能够更好的实现状态共享**\n\n自定义hooks可以说成是一种约定而不是功能。当一个函数以use开头并且在函数内部调用其他hooks，那么这个函数就可以成为自定义hooks\n\n**例如：**\n\n```javascript\nimport { useState,useEffect } from \"react\";\nconst usePerson = ({name}) => {\n    const [loading, setLoading] = useState(true)\n    const [person, setPerson] = useState({})\n\n    useEffect(() => {\n        setLoading(true)\n        setTimeout(()=> {\n            setLoading(false)\n            setPerson({name})\n        },2000)\n    },[name])\n    return [loading,person]\n}\nconst AsyncPage = (name)=> {\n    const [loading,person] = usePerson(name)\n    return (\n        <>\n            {loading?<p>Loading...</p>:<p>{ person.name }</p>}\n        </>\n    )\n}\n\nconst PersonPage = ()=> {\n    const [state,setState] = useState('')\n    const changeName = (name)=> {\n        setState(name)\n    }\n    return (\n        <>\n            <AsyncPage name={ state } />\n            <button onClick={ ()=> { changeName('郭靖')}}>郭靖</button>\n            <button onClick={ ()=> { changeName('黄蓉')}}>黄蓉</button>\n        </>\n    )\n}\nexport default PersonPage;\n\n```\n\n上面代码中，封装成了自己的Hooks，便于共享。其中，usePerson()为自定义Hooks它接受一个字符串，返回一个数组，数组中包括两个数据的状态，之后在使用usePerson()时，会根据传入的参数不同而返回不同的状态，然后很简便的应用于我们的页面中。\n\n这是一种非常简单的自定义Hook。如果项目大的话使用自定义Hook会抽离可以抽离公共代码，极大的减少我们的代码量，提高开发效率。","slug":"hooks","published":1,"updated":"2024-07-24T05:59:58.739Z","_id":"clyzfor9f000glyxx8q9oeyf5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"React-Hooks\"><a href=\"#React-Hooks\" class=\"headerlink\" title=\"React Hooks\"></a><a href=\"https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020\">React</a> Hooks</h1><h2 id=\"Hooks简介\"><a href=\"#Hooks简介\" class=\"headerlink\" title=\"Hooks简介\"></a>Hooks简介</h2><blockquote>\n<p>介绍Hooks之前，首先要说一下React的组件创建方式，一种是类组件，一种是纯函数组件，并且React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。也就是说组件的最佳写法应该是函数，而不是类。</p>\n</blockquote>\n<p>但是，在以往开发中类组件和纯函数组件的区别是很大的，纯函数组件有着类组件不具备的多种特点：</p>\n<ul>\n<li>纯函数组件没有状态</li>\n<li>纯函数组件没有生命周期</li>\n<li>纯函数组件没有this</li>\n</ul>\n<p>这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，不得不用类组件或者redux，但类组件也是有缺点的，比如，遇到简单的页面，代码会显得很重，并且每创建一个类组件，都要去继承一个React实例</p>\n<p><strong>React Hooks：</strong> 就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。</p>\n<p>这时候认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。</p>\n<p><strong>使用Hooks的优点：</strong></p>\n<ul>\n<li>告别难以理解的Class( this 和 生命周期 的痛点)</li>\n<li>解决业务逻辑难以拆分的问题</li>\n<li>使状态逻辑复用变得简单可行</li>\n<li>函数组件从设计思想上来看更加契合React的理念</li>\n</ul>\n<p><strong>Hooks并非万能：</strong></p>\n<ul>\n<li>Hooks暂时还不能完全的为函数组件补齐类组件地能力（如生命周期的getSnapshotBeforeUpdate、componentDidCatch方法暂时还未实现）</li>\n<li>将类组件的复杂变成函数组件的轻量，可能使用者并不能很好地消化这种复杂</li>\n<li>Hooks在使用层面有着严格地规则约束</li>\n</ul>\n<p><strong>例如：类组件实现计数器：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123;<span class=\"hljs-title class_\">Component</span>&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AddCount</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Component</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props</span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>(props);<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = &#123;<br>            count : <span class=\"hljs-number\">0</span><br>        &#125;<br>    &#125;<br>    addcount = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> newCount = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">count</span>;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setState</span>(&#123;<br>            <span class=\"hljs-attr\">count</span>: newCount += <span class=\"hljs-number\">1</span><br>        &#125;)<br>    &#125;<br>    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123; this.state.count &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">this.addcount</span> &#125;&gt;</span>count++<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">AddCount</span>;<br></code></pre></td></tr></table></figure>\n\n<p>可以看出来，上面的代码确实很重。因此React队设计了React Hooks。React Hooks就是加强版的函数组件，可以完全不使用 class，就能写出一个全功能的组件</p>\n<p>React Hooks 使得组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。而React Hooks 就是所说的“钩子”。</p>\n<p>那么Hooks要怎么用呢？“你需要写什么功能，就用什么钩子”。对于常见的功能，React为我们提供了一些常用的钩子，当然有特殊需要，我们也可以写自己的钩子。下面是React Hooks为我们提供的默认的四种最常用钩子：</p>\n<ul>\n<li>useState()</li>\n<li>useContext()</li>\n<li>useEffect()</li>\n<li>useReducer()</li>\n</ul>\n<p>不同的钩子为函数引入不同的外部功能，上面四种钩子都带有use前缀，React Hooks约定，钩子一律使用use前缀命名。所以，自己定义的钩子都要命名为useXXX。</p>\n<h2 id=\"Hook函数（9种）\"><a href=\"#Hook函数（9种）\" class=\"headerlink\" title=\"Hook函数（9种）\"></a>Hook函数（9种）</h2><hr>\n<p><strong>1、State Hook</strong></p>\n<p>useState()：状态钩子。纯函数组件没有状态，<strong>用于为函数组件引入state状态, 并进行状态数据的读写操作</strong></p>\n<p><strong>语法、参数及返回值说明:：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [xxx, setXxx] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(initValue) <br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>参数:</strong> 第一次初始化指定的值在内部作缓存</li>\n<li><strong>返回值:</strong> 包含2个元素的数组，第1个为内部当前状态值，第2个为更新状态值的函数</li>\n</ul>\n<p><strong>setXxx()2种写法:</strong></p>\n<ul>\n<li><strong>setXxx(newValue)</strong>: 参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值</li>\n<li><strong>setXxx(value &#x3D;&gt; newValue)</strong>: 参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值</li>\n</ul>\n<p><strong>例如：React Hooks 实现计数器：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>,&#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">NewCount</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [ count,setCount ] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)<br>    addCount = <span class=\"hljs-function\">()=&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> newCount = count;<br>        <span class=\"hljs-title function_\">setCount</span>(newCount +=<span class=\"hljs-number\">1</span>)<br>    &#125;<br>   <span class=\"hljs-keyword\">return</span> (<br>       <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> &#123; count &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">addCount</span> &#125;&gt;</span>Count++<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">       <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>   )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">NewCount</span>;<br></code></pre></td></tr></table></figure>\n\n<p>代码看起来更加的轻便简洁，没有了继承，没有了渲染逻辑，没有了<a href=\"https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020\">生命周期</a>等</p>\n<hr>\n<p><strong>2、Context Hook</strong></p>\n<p>useContext()：共享状态钩子。<strong>作用就是可以做状态的分发</strong>，在React16.X以后支持，避免了react逐层通过Props传递数据。</p>\n<blockquote>\n<p>Context：一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>\n</blockquote>\n<p><strong>使用语法和说明：</strong></p>\n<ol>\n<li><p>创建Context容器对象：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">XxxContext</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>()  <br></code></pre></td></tr></table></figure>\n</li>\n<li><p>渲染子组件时，外面包裹xxxContext.Provider， 通过value属性给后代组件传递数据：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;xxxContext.<span class=\"hljs-property\">Provider</span> value=&#123;数据&#125;&gt;<br>\t&lt;子组件/&gt;<br>&lt;/xxxContext.<span class=\"hljs-property\">Provider</span>&gt;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>后代组件读取数据：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123;&#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">XxxContext</span>)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>例如：A组件和B组件需要共享一个状态:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useContext &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">HookTest</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">AppContext</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>();<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">A</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>        <span class=\"hljs-keyword\">const</span> &#123; name &#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">AppContext</span>)<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">                我是A组件,我的名字是：&#123; name &#125;；</span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>我是A的子标签：&#123; name &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br>        )<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">B</span>= (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>        <span class=\"hljs-keyword\">const</span> &#123; name &#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">AppContext</span>);<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>我是B组件,名字是： &#123; name &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br>        )<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">name:</span> &#x27;张三&#x27;&#125;&#125;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">A</span> /&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">B</span> /&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">AppContext.Provider</span>&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">HookTest</span>;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>3、Effect Hook</strong></p>\n<p>useEffect()：副作用钩子。<strong>用来更好的执行副作用操作</strong>(用于模拟类组件中的生命周期钩子)，如异步请求等，在类组件中会把请求放在componentDidMount里面，在函数组件中可以使用useEffect()</p>\n<p><strong>语法和说明:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <br>      <span class=\"hljs-comment\">// 在此可以执行任何带副作用操作</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-comment\">// 在组件卸载前执行</span><br>        <span class=\"hljs-comment\">// 在此做一些收尾工作, 比如清除定时器/取消订阅等</span><br>      &#125;<br>&#125;, [stateValue]) <span class=\"hljs-comment\">// 如果指定的是[], 回调函数只会在第一次render()后执行</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>参数、返回值说明：</strong></p>\n<ul>\n<li>useEffect()接受两个参数，<strong>第一个参数是要进行的异步操作</strong>，<strong>第二个参数是一个数组</strong>，用来给出Effect的<strong>依赖项</strong>，只要这个数组发生变化，useEffect()就会执行。</li>\n<li>当第二项省略不填时。useEffect()会在每次组件渲染时都会执行useEffect，只要更新就会执行。</li>\n<li>当第二项传 <strong>空数组[ ]</strong> 时，只会在组件挂载后运行一次。</li>\n<li>useEffect()返回值可以是一个函数，在组件销毁的时候会被调用。清理这些副作用可以进行如取消订阅、清除定时器操作，类似于componentWillUnmount。</li>\n</ul>\n<p><strong>React中的副作用操作:</strong></p>\n<ul>\n<li>发ajax请求数据获取</li>\n<li>设置订阅 &#x2F; 启动定时器</li>\n<li>手动更改真实DOM</li>\n</ul>\n<p><strong>useEffect两个注意点：</strong></p>\n<ul>\n<li>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前要用两个生命周期函数分别表示 <strong>首次渲染(componentDidMonut)</strong> 和<strong>更新导致的重新渲染(componentDidUpdate)</strong></li>\n<li>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。</li>\n</ul>\n<p><strong>总结：</strong> 可以把 useEffect Hook 看做如下三个函数的组合 ：<strong>componentDidMount()、componentDidUpdate()、componentWillUnmount()</strong></p>\n<p>1、类似于componentDidMount的useEffect</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Demo</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-title function_\">useEffcet</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;类似于componentDidMount，通常在此处调用api获取数据&#x27;</span>)<br>  &#125;, [])<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Demo</span><br></code></pre></td></tr></table></figure>\n\n<p>2、类似于componentWillUnmount的useEffect</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Demo</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-title function_\">useEffcet</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;类似于componentWillUnmount，通常用于清除副作用&#x27;</span>);<br>\t&#125;<br>  &#125;, [])<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Demo</span><br></code></pre></td></tr></table></figure>\n\n<p>3、类似于componentDidUpdate的useEffect</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useState,useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Demo</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count,setCount] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)<br>\t<br>  <span class=\"hljs-title function_\">useEffcet</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当count发生改变时，执行当前区域的代码&#x27;</span>)<br>  &#125;, [count])<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>4、Reducer Hook</strong></p>\n<p>useReducer()：Action钩子。在使用React的过程中，如遇到状态管理，一般会用到Redux。而React本身是不提供状态管理的。而useReducer() <strong>提供了状态管理</strong>。</p>\n<p>首先，关于redux我们都知道，其原理是<strong>通过用户在页面中发起action，从而通过reducer方法来改变state，从而实现页面和状态的通信。</strong></p>\n<p>而Reducer的形式是(state, action) &#x3D;&gt; newstate。hooks的形式如下：</p>\n<p><strong>语法格式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [state, dispatch] = <span class=\"hljs-title function_\">useReducer</span>(reducer, initialState)<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数、返回值说明：</strong></p>\n<p>它接受 <strong>reducer函数</strong> 和 <strong>状态的初始值</strong> 作为参数，返回一个<strong>数组</strong>，其中第一项为<strong>当前的状态值</strong>，第二项为<strong>发送action的dispatch函数</strong>。</p>\n<p><strong>例如：使用useReducer()实现一个计数器</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>  &#123; useReducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">HookReducer</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reducer</span> = (<span class=\"hljs-params\">state,action</span>)=&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span> (action.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;add&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> &#123;<br>                ...state,<br>                <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> + <span class=\"hljs-number\">1</span><br>            &#125;<br>        &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> state<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">addCount</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>        <span class=\"hljs-title function_\">dispatch</span>(&#123;<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;add&#x27;</span><br>        &#125;)<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> [state,dispatch ] = <span class=\"hljs-title function_\">useReducer</span>(reducer,&#123;<span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>&#125;)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;state.count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">addCount</span> &#125;&gt;</span>useReducer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">HookReducer</span>;<br></code></pre></td></tr></table></figure>\n\n<p>通过代码可以看到，使用useReducer()代替了Redux的功能，但useReducer无法提供中间件等功能，假如有这些需求，还是需要用到redux。</p>\n<hr>\n<p><strong>5、Ref Hook</strong></p>\n<p>userRefef()：Ref Hook可以<strong>在函数组件中存储、查找组件内的标签或任意其它数据</strong></p>\n<p><strong>语法和参数说明：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> refContainer = <span class=\"hljs-title function_\">useRef</span>()<br></code></pre></td></tr></table></figure>\n\n<p>useRef返回一个可变的ref对象，useRef接受一个参数绑定在返回的ref对象的current属性上，返回的ref对象在整个生命周期中保持不变。</p>\n<p>作用：保存标签对象，功能与React.createRef()一样</p>\n<p><strong>例子：input上绑定一个ref，使得input在渲染后自动焦点聚焦</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>&#123; useRef,useEffect&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">RefComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">let</span> inputRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        inputRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">focus</span>();<br>    &#125;)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;inputRef&#125;/</span>&gt;</span></span><br>    ) <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>6、Memo Hook</strong></p>\n<p>useMemo()： 主要<strong>用来解决使用React hooks产生的无用渲染的性能问题</strong>。</p>\n<p><strong>语法和参数说明：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> cacheSomething = <span class=\"hljs-title function_\">useMemo</span>(create,deps)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>create</code>：第一个参数为一个函数，函数的返回值作为缓存值</li>\n<li><code>deps</code>： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</li>\n<li><code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存</li>\n</ul>\n<p>使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说没有办法通过组件更新前条件来决定组件是否更新。</p>\n<p>而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。</p>\n<p><strong>useMemo原理：</strong></p>\n<p>useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。</p>\n<p><strong>useMemo应用场景：</strong></p>\n<ul>\n<li>可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。</li>\n<li>如果组件中不期望每次 render 都重新计算一些值，可以利用 useMemo 把它缓存起来。</li>\n<li>可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用</li>\n</ul>\n<hr>\n<p><strong>7、Callback Hook</strong></p>\n<p>useCallback()： 主要<strong>是为了性能的优化</strong></p>\n<p><strong>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</strong></p>\n<p>可以认为是对依赖项的监听，接受一个<strong>回调函数</strong>和<strong>依赖项数组</strong>。</p>\n<ul>\n<li>useCallback会返回一个函数的memoized(记忆的)值。</li>\n<li>该回调函数仅在某个依赖项改变时才会</li>\n<li>在依赖不变的情况下，多次定义的时候，返回的值是相同的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123;useState,useCallback&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">CallbackComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">let</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">let</span> [num, setNum] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);<br><br>    <span class=\"hljs-keyword\">const</span> memoized = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;, [count])<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;记忆：&quot;</span>, <span class=\"hljs-title function_\">memoized</span>());<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;原始：&quot;</span>, num);<br>   <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;setCount(count + 1)&#125;&#125;&gt; count+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;setNum(num + 1)&#125;&#125;&gt; num+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">CallbackComponent</span><br></code></pre></td></tr></table></figure>\n\n<p>如果没有传入依赖项数组，那么记忆函数在每次渲染的时候都会更新。</p>\n<hr>\n<p><strong>8、LayoutEffect Hook</strong></p>\n<p>useLayoutEffect() ：和useEffect相同，<strong>都是用来执行副作用，但是它会在所有的DOM变更之后同步调用effect</strong>。useLayoutEffect和useEffect最大的区别就是一个是同步，一个是异步。</p>\n<p>从这个Hook的名字上也可以看出，它主要用来读取DOM布局并触发同步渲染，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>\n<p>官网建议还是尽可能的是使用标准的useEffec以避免阻塞视觉更新。</p>\n<hr>\n<p><strong>9、ImperativeHandle Hook</strong></p>\n<p>useImperativeHandle()： 可以<strong>在使用 ref 时自定义暴露给父组件的实例值。</strong></p>\n<p>就是说：当使用父组件把ref传递给子组件的时候，这个Hook允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。</p>\n<p><strong>使用方式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123;useEffect,useRef,useImperativeHandle&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123;forwardRef&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">FancyInput</span>(<span class=\"hljs-params\">props, ref</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> inputRef = <span class=\"hljs-title function_\">useRef</span>();<br>    <span class=\"hljs-title function_\">useImperativeHandle</span>(ref, <span class=\"hljs-function\">() =&gt;</span> (&#123;<br>        <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-function\">() =&gt;</span> &#123;<br>            inputRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">value</span>=<span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>        &#125;<br>    &#125;));<br>    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br><span class=\"hljs-title class_\">FancyInput</span> = <span class=\"hljs-title function_\">forwardRef</span>(<span class=\"hljs-title class_\">FancyInput</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ImperativeHandleTest</span>=(<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">let</span> ref = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ref);<br>        ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">focus</span>();<br>    &#125;)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FancyInput</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;ref&#125;/</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ImperativeHandleTest</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自定义Hooks\"><a href=\"#自定义Hooks\" class=\"headerlink\" title=\"自定义Hooks\"></a>自定义Hooks</h2><blockquote>\n<p>有时候我们需要创建自己想要的Hooks，来满足更便捷的开发，就是根据业务场景对其它Hooks进行组装，从而得到满足自己需求的钩子。</p>\n</blockquote>\n<p><strong>自定义 Hooks：是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook</strong></p>\n<p><strong>自定义Hooks：可以封装状态，能够更好的实现状态共享</strong></p>\n<p>自定义hooks可以说成是一种约定而不是功能。当一个函数以use开头并且在函数内部调用其他hooks，那么这个函数就可以成为自定义hooks</p>\n<p><strong>例如：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useState,useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">usePerson</span> = (<span class=\"hljs-params\">&#123;name&#125;</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [loading, setLoading] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">true</span>)<br>    <span class=\"hljs-keyword\">const</span> [person, setPerson] = <span class=\"hljs-title function_\">useState</span>(&#123;&#125;)<br><br>    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">true</span>)<br>        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">false</span>)<br>            <span class=\"hljs-title function_\">setPerson</span>(&#123;name&#125;)<br>        &#125;,<span class=\"hljs-number\">2000</span>)<br>    &#125;,[name])<br>    <span class=\"hljs-keyword\">return</span> [loading,person]<br>&#125;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">AsyncPage</span> = (<span class=\"hljs-params\">name</span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [loading,person] = <span class=\"hljs-title function_\">usePerson</span>(name)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            &#123;loading?<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123; person.name &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;</span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">PersonPage</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [state,setState] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">changeName</span> = (<span class=\"hljs-params\">name</span>)=&gt; &#123;<br>        <span class=\"hljs-title function_\">setState</span>(name)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AsyncPage</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">state</span> &#125; /&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> ()=&gt;</span> &#123; changeName(&#x27;郭靖&#x27;)&#125;&#125;&gt;郭靖<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> ()=&gt;</span> &#123; changeName(&#x27;黄蓉&#x27;)&#125;&#125;&gt;黄蓉<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">PersonPage</span>;<br><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，封装成了自己的Hooks，便于共享。其中，usePerson()为自定义Hooks它接受一个字符串，返回一个数组，数组中包括两个数据的状态，之后在使用usePerson()时，会根据传入的参数不同而返回不同的状态，然后很简便的应用于我们的页面中。</p>\n<p>这是一种非常简单的自定义Hook。如果项目大的话使用自定义Hook会抽离可以抽离公共代码，极大的减少我们的代码量，提高开发效率。</p>\n","site":{"data":{}},"wordcount":10465,"excerpt":"","more":"<h1 id=\"React-Hooks\"><a href=\"#React-Hooks\" class=\"headerlink\" title=\"React Hooks\"></a><a href=\"https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020\">React</a> Hooks</h1><h2 id=\"Hooks简介\"><a href=\"#Hooks简介\" class=\"headerlink\" title=\"Hooks简介\"></a>Hooks简介</h2><blockquote>\n<p>介绍Hooks之前，首先要说一下React的组件创建方式，一种是类组件，一种是纯函数组件，并且React团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。也就是说组件的最佳写法应该是函数，而不是类。</p>\n</blockquote>\n<p>但是，在以往开发中类组件和纯函数组件的区别是很大的，纯函数组件有着类组件不具备的多种特点：</p>\n<ul>\n<li>纯函数组件没有状态</li>\n<li>纯函数组件没有生命周期</li>\n<li>纯函数组件没有this</li>\n</ul>\n<p>这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，不得不用类组件或者redux，但类组件也是有缺点的，比如，遇到简单的页面，代码会显得很重，并且每创建一个类组件，都要去继承一个React实例</p>\n<p><strong>React Hooks：</strong> 就是用函数的形式代替原来的继承类的形式，并且使用预函数的形式管理state，有Hooks可以不再使用类的形式定义组件了。</p>\n<p>这时候认知也要发生变化了，原来把组件分为有状态组件和无状态组件，有状态组件用类的形式声明，无状态组件用函数的形式声明。那现在所有的组件都可以用函数来声明了。</p>\n<p><strong>使用Hooks的优点：</strong></p>\n<ul>\n<li>告别难以理解的Class( this 和 生命周期 的痛点)</li>\n<li>解决业务逻辑难以拆分的问题</li>\n<li>使状态逻辑复用变得简单可行</li>\n<li>函数组件从设计思想上来看更加契合React的理念</li>\n</ul>\n<p><strong>Hooks并非万能：</strong></p>\n<ul>\n<li>Hooks暂时还不能完全的为函数组件补齐类组件地能力（如生命周期的getSnapshotBeforeUpdate、componentDidCatch方法暂时还未实现）</li>\n<li>将类组件的复杂变成函数组件的轻量，可能使用者并不能很好地消化这种复杂</li>\n<li>Hooks在使用层面有着严格地规则约束</li>\n</ul>\n<p><strong>例如：类组件实现计数器：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123;<span class=\"hljs-title class_\">Component</span>&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AddCount</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Component</span> &#123;<br>    <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">props</span>) &#123;<br>        <span class=\"hljs-variable language_\">super</span>(props);<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span> = &#123;<br>            count : <span class=\"hljs-number\">0</span><br>        &#125;<br>    &#125;<br>    addcount = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> newCount = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">state</span>.<span class=\"hljs-property\">count</span>;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">setState</span>(&#123;<br>            <span class=\"hljs-attr\">count</span>: newCount += <span class=\"hljs-number\">1</span><br>        &#125;)<br>    &#125;<br>    <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123; this.state.count &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">this.addcount</span> &#125;&gt;</span>count++<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>        )<br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">AddCount</span>;<br></code></pre></td></tr></table></figure>\n\n<p>可以看出来，上面的代码确实很重。因此React队设计了React Hooks。React Hooks就是加强版的函数组件，可以完全不使用 class，就能写出一个全功能的组件</p>\n<p>React Hooks 使得组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。而React Hooks 就是所说的“钩子”。</p>\n<p>那么Hooks要怎么用呢？“你需要写什么功能，就用什么钩子”。对于常见的功能，React为我们提供了一些常用的钩子，当然有特殊需要，我们也可以写自己的钩子。下面是React Hooks为我们提供的默认的四种最常用钩子：</p>\n<ul>\n<li>useState()</li>\n<li>useContext()</li>\n<li>useEffect()</li>\n<li>useReducer()</li>\n</ul>\n<p>不同的钩子为函数引入不同的外部功能，上面四种钩子都带有use前缀，React Hooks约定，钩子一律使用use前缀命名。所以，自己定义的钩子都要命名为useXXX。</p>\n<h2 id=\"Hook函数（9种）\"><a href=\"#Hook函数（9种）\" class=\"headerlink\" title=\"Hook函数（9种）\"></a>Hook函数（9种）</h2><hr>\n<p><strong>1、State Hook</strong></p>\n<p>useState()：状态钩子。纯函数组件没有状态，<strong>用于为函数组件引入state状态, 并进行状态数据的读写操作</strong></p>\n<p><strong>语法、参数及返回值说明:：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [xxx, setXxx] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(initValue) <br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>参数:</strong> 第一次初始化指定的值在内部作缓存</li>\n<li><strong>返回值:</strong> 包含2个元素的数组，第1个为内部当前状态值，第2个为更新状态值的函数</li>\n</ul>\n<p><strong>setXxx()2种写法:</strong></p>\n<ul>\n<li><strong>setXxx(newValue)</strong>: 参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值</li>\n<li><strong>setXxx(value &#x3D;&gt; newValue)</strong>: 参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态值</li>\n</ul>\n<p><strong>例如：React Hooks 实现计数器：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>,&#123; useState &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">NewCount</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [ count,setCount ] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)<br>    addCount = <span class=\"hljs-function\">()=&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">let</span> newCount = count;<br>        <span class=\"hljs-title function_\">setCount</span>(newCount +=<span class=\"hljs-number\">1</span>)<br>    &#125;<br>   <span class=\"hljs-keyword\">return</span> (<br>       <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> &#123; count &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">addCount</span> &#125;&gt;</span>Count++<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">       <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>   )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">NewCount</span>;<br></code></pre></td></tr></table></figure>\n\n<p>代码看起来更加的轻便简洁，没有了继承，没有了渲染逻辑，没有了<a href=\"https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020\">生命周期</a>等</p>\n<hr>\n<p><strong>2、Context Hook</strong></p>\n<p>useContext()：共享状态钩子。<strong>作用就是可以做状态的分发</strong>，在React16.X以后支持，避免了react逐层通过Props传递数据。</p>\n<blockquote>\n<p>Context：一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信</p>\n</blockquote>\n<p><strong>使用语法和说明：</strong></p>\n<ol>\n<li><p>创建Context容器对象：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">XxxContext</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>()  <br></code></pre></td></tr></table></figure>\n</li>\n<li><p>渲染子组件时，外面包裹xxxContext.Provider， 通过value属性给后代组件传递数据：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;xxxContext.<span class=\"hljs-property\">Provider</span> value=&#123;数据&#125;&gt;<br>\t&lt;子组件/&gt;<br>&lt;/xxxContext.<span class=\"hljs-property\">Provider</span>&gt;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>后代组件读取数据：</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123;&#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">XxxContext</span>)<br></code></pre></td></tr></table></figure></li>\n</ol>\n<p><strong>例如：A组件和B组件需要共享一个状态:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span>, &#123; useContext &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">HookTest</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">AppContext</span> = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">createContext</span>();<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">A</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>        <span class=\"hljs-keyword\">const</span> &#123; name &#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">AppContext</span>)<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">                我是A组件,我的名字是：&#123; name &#125;；</span><br><span class=\"language-xml\">                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>我是A的子标签：&#123; name &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br>        )<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">B</span>= (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>        <span class=\"hljs-keyword\">const</span> &#123; name &#125; = <span class=\"hljs-title function_\">useContext</span>(<span class=\"hljs-title class_\">AppContext</span>);<br>        <span class=\"hljs-keyword\">return</span> (<br>            <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>我是B组件,名字是： &#123; name &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br>        )<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppContext.Provider</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&#123;&#123;</span> <span class=\"hljs-attr\">name:</span> &#x27;张三&#x27;&#125;&#125;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">A</span> /&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">B</span> /&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">AppContext.Provider</span>&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">HookTest</span>;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>3、Effect Hook</strong></p>\n<p>useEffect()：副作用钩子。<strong>用来更好的执行副作用操作</strong>(用于模拟类组件中的生命周期钩子)，如异步请求等，在类组件中会把请求放在componentDidMount里面，在函数组件中可以使用useEffect()</p>\n<p><strong>语法和说明:</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <br>      <span class=\"hljs-comment\">// 在此可以执行任何带副作用操作</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-comment\">// 在组件卸载前执行</span><br>        <span class=\"hljs-comment\">// 在此做一些收尾工作, 比如清除定时器/取消订阅等</span><br>      &#125;<br>&#125;, [stateValue]) <span class=\"hljs-comment\">// 如果指定的是[], 回调函数只会在第一次render()后执行</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>参数、返回值说明：</strong></p>\n<ul>\n<li>useEffect()接受两个参数，<strong>第一个参数是要进行的异步操作</strong>，<strong>第二个参数是一个数组</strong>，用来给出Effect的<strong>依赖项</strong>，只要这个数组发生变化，useEffect()就会执行。</li>\n<li>当第二项省略不填时。useEffect()会在每次组件渲染时都会执行useEffect，只要更新就会执行。</li>\n<li>当第二项传 <strong>空数组[ ]</strong> 时，只会在组件挂载后运行一次。</li>\n<li>useEffect()返回值可以是一个函数，在组件销毁的时候会被调用。清理这些副作用可以进行如取消订阅、清除定时器操作，类似于componentWillUnmount。</li>\n</ul>\n<p><strong>React中的副作用操作:</strong></p>\n<ul>\n<li>发ajax请求数据获取</li>\n<li>设置订阅 &#x2F; 启动定时器</li>\n<li>手动更改真实DOM</li>\n</ul>\n<p><strong>useEffect两个注意点：</strong></p>\n<ul>\n<li>React首次渲染和之后的每次渲染都会调用一遍useEffect函数，而之前要用两个生命周期函数分别表示 <strong>首次渲染(componentDidMonut)</strong> 和<strong>更新导致的重新渲染(componentDidUpdate)</strong></li>\n<li>useEffect中定义的函数的执行不会阻碍浏览器更新视图，也就是说这些函数时异步执行的，而componentDidMonut和componentDidUpdate中的代码都是同步执行的。</li>\n</ul>\n<p><strong>总结：</strong> 可以把 useEffect Hook 看做如下三个函数的组合 ：<strong>componentDidMount()、componentDidUpdate()、componentWillUnmount()</strong></p>\n<p>1、类似于componentDidMount的useEffect</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Demo</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-title function_\">useEffcet</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;类似于componentDidMount，通常在此处调用api获取数据&#x27;</span>)<br>  &#125;, [])<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Demo</span><br></code></pre></td></tr></table></figure>\n\n<p>2、类似于componentWillUnmount的useEffect</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Demo</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-title function_\">useEffcet</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;类似于componentWillUnmount，通常用于清除副作用&#x27;</span>);<br>\t&#125;<br>  &#125;, [])<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Demo</span><br></code></pre></td></tr></table></figure>\n\n<p>3、类似于componentDidUpdate的useEffect</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useState,useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react&#x27;</span><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">Demo</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> [count,setCount] = <span class=\"hljs-title class_\">React</span>.<span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">0</span>)<br>\t<br>  <span class=\"hljs-title function_\">useEffcet</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>\t<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;当count发生改变时，执行当前区域的代码&#x27;</span>)<br>  &#125;, [count])<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>4、Reducer Hook</strong></p>\n<p>useReducer()：Action钩子。在使用React的过程中，如遇到状态管理，一般会用到Redux。而React本身是不提供状态管理的。而useReducer() <strong>提供了状态管理</strong>。</p>\n<p>首先，关于redux我们都知道，其原理是<strong>通过用户在页面中发起action，从而通过reducer方法来改变state，从而实现页面和状态的通信。</strong></p>\n<p>而Reducer的形式是(state, action) &#x3D;&gt; newstate。hooks的形式如下：</p>\n<p><strong>语法格式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [state, dispatch] = <span class=\"hljs-title function_\">useReducer</span>(reducer, initialState)<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数、返回值说明：</strong></p>\n<p>它接受 <strong>reducer函数</strong> 和 <strong>状态的初始值</strong> 作为参数，返回一个<strong>数组</strong>，其中第一项为<strong>当前的状态值</strong>，第二项为<strong>发送action的dispatch函数</strong>。</p>\n<p><strong>例如：使用useReducer()实现一个计数器</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>  &#123; useReducer &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">HookReducer</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">reducer</span> = (<span class=\"hljs-params\">state,action</span>)=&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span> (action.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">&#x27;add&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> &#123;<br>                ...state,<br>                <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">count</span> + <span class=\"hljs-number\">1</span><br>            &#125;<br>        &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">return</span> state<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">addCount</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>        <span class=\"hljs-title function_\">dispatch</span>(&#123;<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;add&#x27;</span><br>        &#125;)<br>    &#125;<br>    <span class=\"hljs-keyword\">const</span> [state,dispatch ] = <span class=\"hljs-title function_\">useReducer</span>(reducer,&#123;<span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>&#125;)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;state.count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">addCount</span> &#125;&gt;</span>useReducer<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">HookReducer</span>;<br></code></pre></td></tr></table></figure>\n\n<p>通过代码可以看到，使用useReducer()代替了Redux的功能，但useReducer无法提供中间件等功能，假如有这些需求，还是需要用到redux。</p>\n<hr>\n<p><strong>5、Ref Hook</strong></p>\n<p>userRefef()：Ref Hook可以<strong>在函数组件中存储、查找组件内的标签或任意其它数据</strong></p>\n<p><strong>语法和参数说明：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> refContainer = <span class=\"hljs-title function_\">useRef</span>()<br></code></pre></td></tr></table></figure>\n\n<p>useRef返回一个可变的ref对象，useRef接受一个参数绑定在返回的ref对象的current属性上，返回的ref对象在整个生命周期中保持不变。</p>\n<p>作用：保存标签对象，功能与React.createRef()一样</p>\n<p><strong>例子：input上绑定一个ref，使得input在渲染后自动焦点聚焦</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span>&#123; useRef,useEffect&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">RefComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">let</span> inputRef = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        inputRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">focus</span>();<br>    &#125;)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;inputRef&#125;/</span>&gt;</span></span><br>    ) <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>6、Memo Hook</strong></p>\n<p>useMemo()： 主要<strong>用来解决使用React hooks产生的无用渲染的性能问题</strong>。</p>\n<p><strong>语法和参数说明：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> cacheSomething = <span class=\"hljs-title function_\">useMemo</span>(create,deps)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>create</code>：第一个参数为一个函数，函数的返回值作为缓存值</li>\n<li><code>deps</code>： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</li>\n<li><code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存</li>\n</ul>\n<p>使用function的形式来声明组件，失去了shouldCompnentUpdate（在组件更新之前）这个生命周期，也就是说没有办法通过组件更新前条件来决定组件是否更新。</p>\n<p>而且在函数组件中，也不再区分mount和update两个状态，这意味着函数组件的每一次调用都会执行内部的所有逻辑，就带来了非常大的性能损耗。</p>\n<p><strong>useMemo原理：</strong></p>\n<p>useMemo 会记录上一次执行 create 的返回值，并把它绑定在函数组件对应的 fiber 对象上，只要组件不销毁，缓存值就一直存在，但是 deps 中如果有一项改变，就会重新执行 create ，返回值作为新的值记录到 fiber 对象上。</p>\n<p><strong>useMemo应用场景：</strong></p>\n<ul>\n<li>可以缓存 element 对象，从而达到按条件渲染组件，优化性能的作用。</li>\n<li>如果组件中不期望每次 render 都重新计算一些值，可以利用 useMemo 把它缓存起来。</li>\n<li>可以把函数和属性缓存起来，作为 PureComponent 的绑定方法，或者配合其他Hooks一起使用</li>\n</ul>\n<hr>\n<p><strong>7、Callback Hook</strong></p>\n<p>useCallback()： 主要<strong>是为了性能的优化</strong></p>\n<p><strong>useCallback(fn, deps) 相当于 useMemo(() &#x3D;&gt; fn, deps)</strong></p>\n<p>可以认为是对依赖项的监听，接受一个<strong>回调函数</strong>和<strong>依赖项数组</strong>。</p>\n<ul>\n<li>useCallback会返回一个函数的memoized(记忆的)值。</li>\n<li>该回调函数仅在某个依赖项改变时才会</li>\n<li>在依赖不变的情况下，多次定义的时候，返回的值是相同的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123;useState,useCallback&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">CallbackComponent</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">let</span> [count, setCount] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">let</span> [num, setNum] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-number\">1</span>);<br><br>    <span class=\"hljs-keyword\">const</span> memoized = <span class=\"hljs-title function_\">useCallback</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;, [count])<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;记忆：&quot;</span>, <span class=\"hljs-title function_\">memoized</span>());<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;原始：&quot;</span>, num);<br>   <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;setCount(count + 1)&#125;&#125;&gt; count+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;()</span> =&gt;</span> &#123;setNum(num + 1)&#125;&#125;&gt; num+<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">CallbackComponent</span><br></code></pre></td></tr></table></figure>\n\n<p>如果没有传入依赖项数组，那么记忆函数在每次渲染的时候都会更新。</p>\n<hr>\n<p><strong>8、LayoutEffect Hook</strong></p>\n<p>useLayoutEffect() ：和useEffect相同，<strong>都是用来执行副作用，但是它会在所有的DOM变更之后同步调用effect</strong>。useLayoutEffect和useEffect最大的区别就是一个是同步，一个是异步。</p>\n<p>从这个Hook的名字上也可以看出，它主要用来读取DOM布局并触发同步渲染，在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。</p>\n<p>官网建议还是尽可能的是使用标准的useEffec以避免阻塞视觉更新。</p>\n<hr>\n<p><strong>9、ImperativeHandle Hook</strong></p>\n<p>useImperativeHandle()： 可以<strong>在使用 ref 时自定义暴露给父组件的实例值。</strong></p>\n<p>就是说：当使用父组件把ref传递给子组件的时候，这个Hook允许在子组件中把自定义实例附加到父组件传过来的ref上，有利于父组件控制子组件。</p>\n<p><strong>使用方式：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123;useEffect,useRef,useImperativeHandle&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123;forwardRef&#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">FancyInput</span>(<span class=\"hljs-params\">props, ref</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> inputRef = <span class=\"hljs-title function_\">useRef</span>();<br>    <span class=\"hljs-title function_\">useImperativeHandle</span>(ref, <span class=\"hljs-function\">() =&gt;</span> (&#123;<br>        <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-function\">() =&gt;</span> &#123;<br>            inputRef.<span class=\"hljs-property\">current</span>.<span class=\"hljs-property\">value</span>=<span class=\"hljs-string\">&quot;Hello&quot;</span>;<br>        &#125;<br>    &#125;));<br>    <span class=\"hljs-keyword\">return</span> <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;inputRef&#125;</span> /&gt;</span></span>;<br>&#125;<br><span class=\"hljs-title class_\">FancyInput</span> = <span class=\"hljs-title function_\">forwardRef</span>(<span class=\"hljs-title class_\">FancyInput</span>);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">ImperativeHandleTest</span>=(<span class=\"hljs-params\"></span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">let</span> ref = <span class=\"hljs-title function_\">useRef</span>(<span class=\"hljs-literal\">null</span>);<br>    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(ref);<br>        ref.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">focus</span>();<br>    &#125;)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">FancyInput</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">&#123;ref&#125;/</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">ImperativeHandleTest</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自定义Hooks\"><a href=\"#自定义Hooks\" class=\"headerlink\" title=\"自定义Hooks\"></a>自定义Hooks</h2><blockquote>\n<p>有时候我们需要创建自己想要的Hooks，来满足更便捷的开发，就是根据业务场景对其它Hooks进行组装，从而得到满足自己需求的钩子。</p>\n</blockquote>\n<p><strong>自定义 Hooks：是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook</strong></p>\n<p><strong>自定义Hooks：可以封装状态，能够更好的实现状态共享</strong></p>\n<p>自定义hooks可以说成是一种约定而不是功能。当一个函数以use开头并且在函数内部调用其他hooks，那么这个函数就可以成为自定义hooks</p>\n<p><strong>例如：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; useState,useEffect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">usePerson</span> = (<span class=\"hljs-params\">&#123;name&#125;</span>) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [loading, setLoading] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-literal\">true</span>)<br>    <span class=\"hljs-keyword\">const</span> [person, setPerson] = <span class=\"hljs-title function_\">useState</span>(&#123;&#125;)<br><br>    <span class=\"hljs-title function_\">useEffect</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">true</span>)<br>        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span> &#123;<br>            <span class=\"hljs-title function_\">setLoading</span>(<span class=\"hljs-literal\">false</span>)<br>            <span class=\"hljs-title function_\">setPerson</span>(&#123;name&#125;)<br>        &#125;,<span class=\"hljs-number\">2000</span>)<br>    &#125;,[name])<br>    <span class=\"hljs-keyword\">return</span> [loading,person]<br>&#125;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">AsyncPage</span> = (<span class=\"hljs-params\">name</span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [loading,person] = <span class=\"hljs-title function_\">usePerson</span>(name)<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            &#123;loading?<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123; person.name &#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>&#125;</span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">PersonPage</span> = (<span class=\"hljs-params\"></span>)=&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [state,setState] = <span class=\"hljs-title function_\">useState</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">changeName</span> = (<span class=\"hljs-params\">name</span>)=&gt; &#123;<br>        <span class=\"hljs-title function_\">setState</span>(name)<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> (<br>        <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AsyncPage</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&#123;</span> <span class=\"hljs-attr\">state</span> &#125; /&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> ()=&gt;</span> &#123; changeName(&#x27;郭靖&#x27;)&#125;&#125;&gt;郭靖<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;</span> ()=&gt;</span> &#123; changeName(&#x27;黄蓉&#x27;)&#125;&#125;&gt;黄蓉<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">PersonPage</span>;<br><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，封装成了自己的Hooks，便于共享。其中，usePerson()为自定义Hooks它接受一个字符串，返回一个数组，数组中包括两个数据的状态，之后在使用usePerson()时，会根据传入的参数不同而返回不同的状态，然后很简便的应用于我们的页面中。</p>\n<p>这是一种非常简单的自定义Hook。如果项目大的话使用自定义Hook会抽离可以抽离公共代码，极大的减少我们的代码量，提高开发效率。</p>\n"},{"title":"2024前端高频面试题之-- JS篇","date":"2024-07-24T06:07:58.000Z","_content":"\n# 2024 前端高频面试题之-- JS 篇\n\n【前端面试复习系列文章】\n\n[2024 前端高频面试题-- html 篇](https://juejin.cn/post/7316349850855211046 'https://juejin.cn/post/7316349850855211046')\n\n[2024 前端高频面试题-- CSS 篇](https://juejin.cn/post/6844904013620592654 'https://juejin.cn/post/6844904013620592654')\n\n[2024 前端高频面试题-- VUE 篇](https://juejin.cn/post/7343484473184698405 'https://juejin.cn/post/7343484473184698405')\n\n[2024 前端高频面试题-- react 篇](https://juejin.cn/post/7349971654590857216 'https://juejin.cn/post/7349971654590857216')\n\n[2024 前端高频面试题-- 前端工程化篇](https://juejin.cn/post/7350535815132659749 'https://juejin.cn/post/7350535815132659749')\n\n[2024 前端高频面试题-- HTTP 和浏览器篇](https://juejin.cn/post/7351301328206331939 'https://juejin.cn/post/7351301328206331939')\n\n[2024 前端高频面试题-- 手写代码篇](https://juejin.cn/post/7353456468094599205 'https://juejin.cn/post/7353456468094599205')\n\n[2024 前端高频面试题-- 数据结构与算法篇](https://juejin.cn/post/7356060104565997605 'https://juejin.cn/post/7356060104565997605')\n\n【导读】最近在面试，把一些前端高频面试题或知识点做一个总结，一方面自己做一个梳理和总结，另外一方面也分享给正在面试或有需要的朋友。\n\n下图为思维导图：\n\n![JS.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831963d7ed524c3796b1889037da72f9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1260&h=4032&s=669131&e=jpg&b=313131)\n\n### 1.js 基本数据类型有哪些及它们的区别\n\nJavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。\n\n其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：\n\n- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\n- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。\n\n这些数据可以分为原始数据类型和引用数据类型：\n\n- 栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）\n- 堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别在于**存储位置的不同：**\n\n- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n\n- 在数据结构中，栈中数据的存取方式为先进后出。\n- 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\n\n在操作系统中，内存被分为栈区和堆区：\n\n- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n- 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。\n\n### 2\\. 数据类型检测的方式有哪些\n\n**（1）typeof**\n\n```javascript\nconsole.log(typeof 2) // number\nconsole.log(typeof true) // boolean\nconsole.log(typeof 'str') // string\nconsole.log(typeof []) // object\nconsole.log(typeof function () {}) // function\nconsole.log(typeof {}) // object\nconsole.log(typeof undefined) // undefined\nconsole.log(typeof null) // object`\n```\n\n其中数组、对象、null 都会被判断为 object，其他判断都正确。\n\n**（2）instanceof**\n\n`instanceof`可以正确判断对象的类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。\n\n```javascript\nconsole.log(2 instanceof Number) // false\nconsole.log(true instanceof Boolean) // false\nconsole.log('str' instanceof String) // false\nconsole.log([] instanceof Array) // true\nconsole.log(function () {} instanceof Function) // true\nconsole.log({} instanceof Object) // true\n```\n\n可以看到，`instanceof`**只能正确判断引用数据类型**，而不能判断基本数据类型。`instanceof` 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。\n\n**（3） constructor**\n\njavascript\n\n```javascript\nconsole.log((2).constructor === Number) // true\nconsole.log(true.constructor === Boolean) // true\nconsole.log('str'.constructor === String) // true\nconsole.log([].constructor === Array) // true\nconsole.log(function () {}.constructor === Function) // true\nconsole.log({}.constructor === Object) // true\n```\n\n`constructor`有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了：\n\nini\n\n```javascript\nfunction Fn() {}\nFn.prototype = new Array()\nvar f = new Fn()\nconsole.log(f.constructor === Fn) // false\nconsole.log(f.constructor === Array) // true\n```\n\n**（4）Object.prototype.toString.call()**\n\n`Object.prototype.toString.call()` 使用 Object 对象的原型方法 toString 来判断数据类型：\n\nvbscript\n\n```javascript\nvar a = Object.prototype.toString\nconsole.log(a.call(2))\nconsole.log(a.call(true))\nconsole.log(a.call('str'))\nconsole.log(a.call([]))\nconsole.log(a.call(function () {}))\nconsole.log(a.call({}))\nconsole.log(a.call(undefined))\nconsole.log(a.call(null))\n```\n\n同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？\n\n这是因为 toString 是 Object 的原型方法，而 Array、function 等**类型作为 Object 的实例，都重写了 toString 方法**。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。\n\n### 3\\. 判断数组的方式有哪些\n\n- 通过 Object.prototype.toString.call()做判断\n\njavascript\n\n```javascript\nObject.prototype.toString.call(obj).slice(8, -1) === 'Array'\n```\n\n- 通过原型链做判断\n\nini\n\n```javascript\nobj.__proto__ === Array.prototype\n```\n\n- 通过 ES6 的 Array.isArray()做判断\n\nini\n\n```javascript\nArray.isArrray(obj)\n```\n\n- 通过 instanceof 做判断\n\njavascript\n\n```javascript\nobj instanceof Array\n```\n\n- 通过 Array.prototype.isPrototypeOf\n\njavascript\n\n```javascript\nArray.prototype.isPrototypeOf(obj)\n```\n\n### 4.请简述 JavaScript 中的 this\n\nthis 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n\n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\n\n3.箭头函数与普通函数有什么区别\n\n**（1）箭头函数比普通函数更加简洁**\n\n- 如果没有参数，就直接写一个空括号即可\n- 如果只有一个参数，可以省去参数的括号\n- 如果有多个参数，用逗号分割\n- 如果函数体的返回值只有一句，可以省略大括号\n- 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个 void 关键字。最常见的就是调用一个函数：\n\ncsharp\n\n```javascript\nlet fn = () => void doesNotReturn()\n```\n\n**（2）箭头函数没有自己的 this**\n\n箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。\n\n**（3）箭头函数继承来的 this 指向永远不会改变**\n\njavascript\n\n```javascript\nvar id = 'GLOBAL'\nvar obj = {\n  id: 'OBJ',\n  a: function () {\n    console.log(this.id)\n  },\n  b: () => {\n    console.log(this.id)\n  },\n}\nobj.a() // 'OBJ' obj.b();    // 'GLOBAL' new obj.a()  // undefined new obj.b()  // Uncaught TypeError: obj.b is not a constructor\n```\n\n对象 obj 的方法 b 是使用箭头函数定义的，这个函数中的 this 就永远指向它定义时所处的全局执行环境中的 this，即便这个函数是作为对象 obj 的方法调用，this 依旧指向 Window 对象。需要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n\n**（4）call()、apply()、bind()等方法不能改变箭头函数中 this 的指向**\n\nbash\n\n```javascript\nvar id = 'Global'\nlet fun1 = () => {\n  console.log(this.id)\n}\nfun1() // 'Global' fun1.call({id: 'Obj'});     // 'Global' fun1.apply({id: 'Obj'});    // 'Global' fun1.bind({id: 'Obj'})();   // 'Global'\n```\n\n**（5）箭头函数不能作为构造函数使用**\n\n构造函数在 new 的步骤在上面已经说过了，实际上第二步就是将函数中的 this 指向该对象。 但是由于箭头函数时没有自己的 this 的，且 this 指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n\n**（6）箭头函数没有自己的 arguments**\n\n箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是它外层函数的 arguments 值。\n\n**（7）箭头函数没有 prototype**\n\n**（8）箭头函数不能用作 Generator 函数，不能使用 yeild 关键字**\n\n### 5.AMD 和 CommonJS 的区别\n\n它们都是实现模块体系的方式，直到 `ES2015` 出现之前，`JavaScript` 一直没有模块体系。`CommonJS` 是同步的，而 `AMD（Asynchronous Module Definition）` 从全称中可以明显看出是异步的。`CommonJS` 的设计是为服务器端开发考虑的，而 `AMD` 支持异步加载模块，更适合浏览器。\n\n我发现 `AMD` 的语法非常冗长，`CommonJS` 更接近其他语言 `import` 声明语句的用法习惯。大多数情况下，我认为 `AMD` 没有使用的必要，因为如果把所有 `JavaScript` 都捆绑进一个文件中，将无法得到异步加载的好处。此外，`CommonJS` 语法上更接近 `Node` 编写模块的风格，在前后端都使用 `JavaScript` 开发之间进行切换时，语境的切换开销较小。\n\n我很高兴看到 `ES2015` 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 `Node` 中完全推出，但是我们可以使用代码转换工具进行转换。\n\n### 6.**ES6**模块与**CommonJS**模块有什么异同？\n\nES6 Module 和 CommonJS 模块的区别：\n\n- CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const；\n- import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。\n\nES6 Module 和 CommonJS 模块的共同点：\n\n- CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n\n### 7\\. let、const、var 的区别\n\n**（1）块级作用域：** 块作用域由 `{ }`包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：\n\n- 内层变量可能覆盖外层变量\n- 用来计数的循环变量泄露为全局变量\n\n**（2）变量提升：** var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n\n**（3）给全局添加属性：** 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。\n\n**（4）重复声明：** var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。\n\n**（5）暂时性死区：** 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用 var 声明的变量不存在暂时性死区。\n\n**（6）初始值设置：** 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。\n\n**（7）指针指向：** let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。\n\n| **区别**           | **var** | **let** | **const** |\n| ------------------ | ------- | ------- | --------- |\n| 是否有块级作用域   | ×       | ✔️      | ✔️        |\n| 是否存在变量提升   | ✔️      | ×       | ×         |\n| 是否添加全局属性   | ✔️      | ×       | ×         |\n| 能否重复声明变量   | ✔️      | ×       | ×         |\n| 是否存在暂时性死区 | ×       | ✔️      | ✔️        |\n| 是否必须设置初始值 | ×       | ×       | ✔️        |\n| 能否改变指针指向   | ✔️      | ✔️      | ×         |\n\n### 8.new 操作符的实现原理\n\n**new 操作符的执行过程：**\n\n（1）首先创建了一个新的空对象\n\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\n具体实现：\n\njavascript\n\n```javascript\nobjectFactory() {   let newObject = null;   let constructor = Array.prototype.shift.call(arguments);   let result = null;   // 判断参数是否是一个函数\n  if (typeof constructor !== \"function\") {     console.error(\"type error\");     return;   }   // 新建一个空对象，对象的原型为构造函数的 prototype 对象   \n newObject = Object.create(constructor.prototype);   // 将 this 指向新建对象，并执行函数   \n result = constructor.apply(newObject, arguments);   // 判断返回对象   \n let flag = result && (typeof result === \"object\" || typeof result === \"function\");   // 判断返回结果   \n return flag ? result : newObject;\n } // 使用方法\n objectFactory(构造函数, 初始化参数);\n```\n\n### 9.数组有哪些原生方法？\n\n数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n\n数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n\n数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n\n数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n\n数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n\n数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\n\n数组归并方法 reduce() 和 reduceRight() 方法\n\n### 10.for in 和 for of 的区别\n\nfor…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构（数组、对象等）并且返回各项的值，和 ES3 中的 for…in 的区别如下\n\n- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；\n- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\n- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；\n\n**总结：** for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\n\n### 11.数组的遍历方法有哪些？\n\n| **方法**                  | **是否改变原数组** | **特点**                                                                                                                                                                                    |\n| ------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| forEach()                 | 否                 | 数组方法，值是基本类型, 改变不了;如果是引用类型分两种情况：1、没有修改形参元素的地址值, 只是修改形参元素内部的某些属性，会改变原数组；2、直接修改整个元素对象时，无法改变原数组，没有返回值 |\n| map()                     | 否                 | 数组方法，不改变原数组，有返回值，可链式调用                                                                                                                                                |\n| filter()                  | 否                 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用                                                                                                                                |\n| for...of                  | 否                 | for...of 遍历具有 Iterator 迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的 obj 对象，将异步循环变成同步循环                                                            |\n| every() 和 some()         | 否                 | 数组方法，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false.                                                                                                 |\n| find() 和 findIndex()     | 否                 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值                                                                                                   |\n| reduce() 和 reduceRight() | 否                 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作                                                                                                                               |\n\n### 12.forEach 和 map 的区别\n\n这方法都是用来遍历数组的，两者区别如下：\n\n- forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\n- map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；\n\n### 13.原型和原型链\n\n#### 1\\. 对原型、原型链的理解\n\n在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 **proto** 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n\n**特点：** JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。\n\n#### 2\\. 原型修改、重写\n\njavascript\n\n```javascript\nfunction Person(name) {     this.name = name } // 修改原型\nPerson.prototype.getName = function() {}\nvar p = new Person('hello') console.log(p.__proto__ === Person.prototype) // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n// 重写原型\nPerson.prototype = {     getName: function() {} } var p = new Person('hello') console.log(p.__proto__ === Person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // false\n```\n\n可以看到修改原型的时候 p 的构造函数不是指向 Person 了，因为直接给 Person 的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数 Object，所以这时候`p.constructor === Object` ，而不是`p.constructor === Person`。要想成立，就要用 constructor 指回来：\n\nini\n\n```javascript\nPerson.prototype = {     getName: function() {} } var p = new Person('hello') p.constructor = Person console.log(p.__proto__ === Person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n```\n\n#### 3\\. 原型链指向\n\njavascript\n\n```javascript\np.__proto__ // Person.prototype\nPerson.prototype.__proto__ // Object.prototype\np.__proto__.__proto__ //Object.prototype\np.__proto__.constructor.prototype.__proto__ // Object.prototype\nPerson.prototype.constructor.prototype.__proto__ // Object.prototype\np1.__proto__.constructor // Person\nPerson.prototype.constructor // Person\n```\n\n#### 4\\. 原型链的终点是什么？如何打印出原型链的终点？\n\n由于`Object`是构造函数，原型链终点是`Object.prototype.__proto__`，而`Object.prototype.__proto__=== null // true`，所以，原型链的终点是`null`。原型链上的所有原型都是对象，所有的对象最终都是由`Object`构造的，而`Object.prototype`的下一级是`Object.prototype.__proto__`。\n\n#### 5\\. 如何获得对象非原型链上的属性？\n\n使用后`hasOwnProperty()`方法来判断属性是否属于原型链的属性：\n\nscss\n\n```javascript\nfunction iterate(obj) {\n  var res = []\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) res.push(key + ': ' + obj[key])\n  }\n  return res\n}\n```\n\n### 14\\. 对执行上下文,作用域(链),闭包的理解\n\n#### 1\\. 对闭包的理解\n\n**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n\n闭包有两个常用的用途；\n\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\n\njavascript\n\n```javascript\nfunction A() {   let a = 1   window.B = function () {       console.log(a)   } } A() B() // 1\n```\n\n在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\n\ncss\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n```\n\n首先因为 `setTimeout` 是个异步函数，所以会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。解决办法有三种：\n\n- 第一种是使用闭包的方式\n\njavascript\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n  ;(function (j) {\n    setTimeout(function timer() {\n      console.log(j)\n    }, j * 1000)\n  })(i)\n}\n```\n\n在上述代码中，首先使用了立即执行函数将 `i` 传入函数内部，这个时候值就被固定在了参数 `j` 上面不会改变，当下次执行 `timer` 这个闭包的时候，就可以使用外部函数的变量 `j`，从而达到目的。\n\n- 第二种就是使用 `setTimeout` 的第三个参数，这个参数会被当成 `timer` 函数的参数传入。\n\ncss\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n```\n\n- 第三种就是使用 `let` 定义 `i` 了来解决问题了，这个也是最为推荐的方式\n\ncss\n\n```javascript\nfor (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n```\n\n#### 2\\. 对作用域、作用域链的理解\n\n##### 1）全局作用域和函数作用域\n\n（1）全局作用域\n\n- 最外层函数和最外层函数外面定义的变量拥有全局作用域\n- 所有未定义直接赋值的变量自动声明为全局作用域\n- 所有 window 对象的属性拥有全局作用域\n- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n（2）函数作用域\n\n- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到\n- 作用域是分层的，内层作用域可以访问外层作用域，反之不行\n\n##### 2）块级作用域\n\n- 使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）\n- let 和 const 声明的变量不会有变量提升，也不可以重复声明\n- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n**作用域链：** 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。\n\n作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**\n\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。\n\n#### 3\\. 对执行上下文的理解\n\n##### 1\\. 执行上下文类型\n\n**（1）全局执行上下文**\n\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的 window 对象，并且设置 this 的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n\n**（2）函数执行上下文**\n\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n\n**（3）** `eval`**函数执行上下文**\n\n执行在 eval 函数中的代码会有属于他自己的执行上下文，不过 eval 函数不常使用，不做介绍。\n\n##### 2\\. 执行上下文栈\n\n- JavaScript 引擎使用执行上下文栈来管理执行上下文\n- 当 JavaScript 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\n\nsql\n\n```javascript\nlet a = 'Hello World!'\nfunction first() {\n  console.log('Inside first function')\n  second()\n  console.log('Again inside first function')\n}\nfunction second() {\n  console.log('Inside second function')\n}\nfirst() //执行顺序 //先执行second(),在执行first()\n```\n\n##### 3\\. 创建执行上下文\n\n创建执行上下文有两个阶段：**创建阶段**和**执行阶段**\n\n**1）创建阶段**\n\n（1）this 绑定\n\n- 在全局执行上下文中，this 指向全局对象（window 对象）\n- 在函数执行上下文中，this 指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n\n（2）创建词法环境组件\n\n- 词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\n- 词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域\n\n（3）创建变量环境组件\n\n- 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n\n**2）执行阶段** 此阶段会完成对变量的分配，最后执行完代码。\n\n**简单来说执行上下文就是指：**\n\n在执行一点 JS 代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments 和函数的参数。\n\n- 全局上下文：变量定义，函数声明\n- 函数上下文：变量定义，函数声明，`this`，`arguments`\n\n### 15\\. 实现 call、apply 及 bind 函数\n\n**（1）call 函数的实现步骤：**\n\n- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 处理传入的参数，截取第一个参数后的所有参数。\n- 将函数作为上下文对象的一个属性。\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性。\n- 返回结果。\n\njavascript\n\n```javascript\nFunction.prototype.myCall = function (context) {\n  // 判断调用对象\n  if (typeof this !== 'function') {\n    console.error('type error')\n  } // 获取参数\n  let args = [...arguments].slice(1),\n    result = null // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window // 将调用函数设为对象的方法\n  context.fn = this // 调用函数\n  result = context.fn(...args) // 将属性删除\n  delete context.fn\n  return result\n}\n```\n\n**（2）apply 函数的实现步骤：**\n\n- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 将函数作为上下文对象的一个属性。\n- 判断参数值是否传入\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性\n- 返回结果\n\njavascript\n\n```javascript\nFunction.prototype.myApply = function (context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  let result = null // 判断 context 是否存在，如果未传入则为 window\n  context = context || window // 将函数设为对象的方法\n  context.fn = this // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  } // 将属性删除\n  delete context.fn\n  return result\n}\n```\n\n**（3）bind 函数的实现步骤：**\n\n- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 保存当前函数的引用，获取其余传入参数值。\n- 创建一个函数返回\n- 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\njavascript\n\n```javascript\nFunction.prototype.myBind = function (context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  } // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    )\n  }\n}\n```\n\n### 16\\. call、apply 函数的区别\n\n它们的作用一模一样，区别仅在于传入参数的形式的不同。\n\n- apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\n- call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n\n### 17\\. 异步编程的实现方式？\n\nmarkdown\n\n```javascript\nJavaScript中的异步机制可以分为以下几种：\n -   **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\n -   **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n -   **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 -   **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n```\n\n### 18\\. setTimeout、Promise、Async/Await 的区别\n\n#### （1）setTimeout\n\njavascript\n\n```javascript\nconsole.log('script start') //1. 打印 script start\nsetTimeout(function () {\n  console.log('settimeout') // 4. 打印 settimeout\n}) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数\nconsole.log('script end') //3. 打印 script start\n// 输出顺序：script start->script end->settimeout\n```\n\n#### （2）Promise\n\nPromise 本身是**同步的立即执行函数**， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。\n\n```javascript\nconsole.log('script start')\nlet promise1 = new Promise(function (resolve) {\n  console.log('promise1')\n  resolve()\n  console.log('promise1 end')\n}).then(function () {\n  console.log('promise2')\n})\nsetTimeout(function () {\n  console.log('settimeout')\n})\nconsole.log('script end')\n// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout\n```\n\n当 JS 主线程执行到 Promise 对象时：\n\n- promise1.then() 的回调就是一个 task\n- promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue\n- promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中\n- setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况\n\n#### （3）async/await\n\njavascript\n\n```javascript\nasync function async1() {\n  console.log('async1 start')\n  await async2()\n  console.log('async1 end')\n}\nasync function async2() {\n  console.log('async2')\n}\nconsole.log('script start')\nasync1()\nconsole.log('script end')\n// 输出顺序：script start->async1 start->async2->script end->async1 end\n```\n\nasync 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。\n\n例如：\n\njavascript\n\n```javascript\nasync function func1() {\n  return 1\n}\nconsole.log(func1())\n```\n\nfunc1 的运行结果其实就是一个 Promise 对象。因此也可以使用 then 来处理后续逻辑。\n\nscss\n\n```javascript\nfunc1().then((res) => {\n  console.log(res) // 30\n})\n```\n\nawait 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。\n\n### 19\\. Promise.all 和 Promise.race 的区别的使用场景\n\n**（1）Promise.all** `Promise.all`可以将多个`Promise`实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是**一个结果数组**，而失败的时候则返回**最先被 reject 失败状态的值**。\n\nPromise.all 中传入的是数组，返回的也是是数组，并且会将进行映射，传入的 promise 对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n\n需要注意，Promise.all 获得的成功结果的数组里面的数据顺序和 Promise.all 接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用 Promise.all 来解决。\n\n**（2）Promise.race**\n\n顾名思义，Promse.race 就是赛跑的意思，意思就是说，Promise.race(\\[p1, p2, p3\\])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n\nini\n\n```javascript\nPromise.race([promise1, timeOutPromise(5000)]).then((res) => {})\n```\n\n### 20\\. 对 async/await 的理解\n\nasync/await 其实是`Generator` 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是“异步”的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：\n\njavascript\n\n```javascript\nasync function testAsy() {\n  return 'hello world'\n}\nlet result = testAsy()\nconsole.log(result)\n```\n\n所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样：\n\njavascript\n\n```javascript\nasync function testAsy(){    return 'hello world' } let result = testAsy()  console.log(result) result.then(v=>{     console.log(v)  \n// hello world\n})\n```\n\n那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n**注意：** `Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\n### 21\\. 浏览器的垃圾回收机制\n\nmarkdown\n\n`` #### （1）垃圾回收的概念 **垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。 **回收机制**： -   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。 -   JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。 -   不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。 #### （2）垃圾回收的方式 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 **1）标记清除** -   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。 -   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 **2）引用计数** -   另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。 -   这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。 ``` function fun() {     let obj1 = {};     let obj2 = {};     obj1.a = obj2; // obj1 引用 obj2     obj2.a = obj1; // obj2 引用 obj1 } ``` 这种情况下，就要手动释放变量占用的内存： ``` obj1.a =  null  obj2.a =  null ``` #### （3）减少垃圾回收 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。 -   **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。 -   **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。 -   **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。 ``\n\n### 22\\. 哪些情况会导致内存泄漏\n\nmarkdown\n\n`以下四种情况会造成内存的泄漏： -   **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 -   **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 -   **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。 -   **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。`\n\n### 23\\. ES6 有哪些新特性\n\n1.箭头函数\n\n2.解构赋值\n\n3.模板字符串\n\n4.promise\n\n5.symbol Symbol 是 ES6 中引入的一种新的基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算\n\n6.新的变量声明方式-let 和 const\n\n7.模块化-es6 新增了模块化，根据功能封装模块，通过 import 导入，然后通过 export 导出也可以使用 export default 导出\n\n8.for…of 循环,用于遍历可迭代对象(如数组、Map 和 Set)中的元素\n\n9.扩展运算符:使用 ... 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组\n\n10.展开运算符:在 ES6 中用...来表示展开运算符,它可以将数组或者对象进行展开\n\n11.Map 和 Set，引入了两种新的数据结构，分别用于存储键值对和唯一值\n\n12.Proxy，允许在对象和函数调用等操作前后添加自定义的行为\n\n13.类（Class），引入了面向对象编程中类的概念\n\n14.默认参数（Default Parameter），在定义函数时可以给参数设置默认值\n\n### 24\\. 匿名函数的典型应用场景是什么？\n\n匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。\n\njavascript\n\n```javascript\n(function () {   // 一些代码。 })();\n```\n\n匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。\n\njavascript\n\n```javascript\nsetTimeout(function () {\n  console.log('Hello world!')\n}, 1000)\n```\n\n匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。\n\nc\n\n```javascript\nconst arr = [1, 2, 3]\nconst double = arr.map(function (el) {\n  return el * 2\n})\nconsole.log(double) // [2, 4, 6]\n```\n\n### 25.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？\n\n柯里化（currying）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。值得注意的是，对于需要被 curry 的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。\n\nscss\n\n```javascript\nfunction curry(fn) {   if (fn.length === 0) {     return fn;   } ​   function _curried(depth, args) {     return function (newArgument) {       if (depth - 1 === 0) {         return fn(...args, newArgument);       }       return _curried(depth - 1, [...args, newArgument]);     };   } ​   return _curried(fn.length, []); } ​ function add(a, b) {   return a + b; } ​ var curriedAdd = curry(add); var addFive = curriedAdd(5); ​ var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]\n```\n\n### 26.什么是事件循环？调用堆栈和任务队列之间有什么区别？\n\n事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。\n\n### 27.js 设计模式有哪些？\n\n总体来说设计模式分为三大类：(`C5S7B11`)\n\n1. **创建型模式**，共五种：**工厂方法模式**、抽象工厂模式、**单例模式**、建造者模式、**原型模式**。\n2. **结构型模式**，共七种：**适配器模式**、**装饰器模式**、**代理模式**、外观模式、桥接模式、组合模式、享元模式。\n3. **行为型模式**，共十一种：策略模式、模板方法模式、**观察者模式/发布订阅模式**、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n## 手写单例模式（创建模式）\n\njavascript\n\n```javascript\nlet CreateSingleton = (function () {\n  let instance\n  return function (name) {\n    if (instance) {\n      return instance\n    }\n    this.name = name\n    return (instance = this)\n  }\n})()\nCreateSingleton.prototype.getName = function () {\n  console.log(this.name)\n}\n```\n\n代码测试\n\n```javascript\nlet Winner = new CreateSingleton('Winner'); let Looser = new CreateSingleton('Looser'); ​ console.log(Winner === Looser); // true\nconsole.log(Winner.getName());  // 'Winner'\nconsole.log(Looser.getName());  // 'Winner'\n```\n\n## 手写观察者模式（行为模式）\n\nini\n\n```javascript\n// 定义observe\nconst queuedObservers = new Set();\nconst observe = fn => queuedObservers.add(fn); ​ ​\nconst observable = obj => new Proxy(obj, {   set(target, key, value, receiver) {     const result = Reflect.set(target, key, value, receiver);     // notify     \nqueuedObservers.forEach(observer => observer());     return result;   } });\n```\n\n代码测试\n\njavascript\n\n```javascript\nobj = observable({   name:'789' }) ​ observe(function test(){   console.log('触发了') }) ​ obj.name =\"前端柒八九\" // 触发了 // 前端柒八九\n```\n\n## 手写发布订阅 （行为模式）\n\nkotlin\n\n```javascript\nclass Observer {   caches = {}; // 事件中心      // eventName事件名-独一无二, fn订阅后执行的自定义行为   \non (eventName, fn){      this.caches[eventName] = this.caches[eventName] || [];     this.caches[eventName].push(fn);   }      // 发布 => 将订阅的事件进行统一执行   \nemit (eventName, data) {      if (this.caches[eventName]) {       this.caches[eventName]       .forEach(fn => fn(data));     }   }   // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息   \noff (eventName, fn) {      if (this.caches[eventName]) {       const newCaches = fn          ? this.caches[eventName].filter(e => e !== fn)          : [];       this.caches[eventName] = newCaches;     }   } ​ }\n```\n\n代码测试\n\njavascript\n\n````javascript\nob = new Observer(); ​ l1 = (data) => console.log(`l1_${data}`) l2 = (data) => console.log(`l2_${data}`) ​ ob.on('event1',l1) ob.on('event1',l2) ​ //发布订阅\nob.emit('event1',789)  // l1_789 // l2_789 ​\n// 取消，订阅l1\nob.off('event1',l1) ​ ob.emit('event1',567) //l2_567\n```\n\n## 观察者模式 VS 发布订阅模式\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c708723f8b984c1c9ceaf24d674306b3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1014&h=804&s=19910&e=webp&b=fdf8f4)\n\n1. 从表面上看：\n\n    - 观察者模式里，只有两个角色 —— **观察者** + **被观察者**\n    - 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— {经纪人|Broker}\n2. 往更深层次讲：\n\n    - 观察者和被观察者，是`松耦合`的关系\n    - 发布者和订阅者，则完全不存在耦合\n3. 从使用层面上讲：\n\n    - 观察者模式，多用于**单个应用内部**\n    - 发布订阅模式，则更多的是一种{跨应用的模式|cross-application pattern} ，比如我们常用的消息中间件\n\n\n转至 [面试](https://juejin.cn/user/835284567342782/posts)\n````\n","source":"_posts/interview.md","raw":"---\ntitle: 2024前端高频面试题之-- JS篇\ndate: 2024-07-24 14:07:58\ntags:\n---\n\n# 2024 前端高频面试题之-- JS 篇\n\n【前端面试复习系列文章】\n\n[2024 前端高频面试题-- html 篇](https://juejin.cn/post/7316349850855211046 'https://juejin.cn/post/7316349850855211046')\n\n[2024 前端高频面试题-- CSS 篇](https://juejin.cn/post/6844904013620592654 'https://juejin.cn/post/6844904013620592654')\n\n[2024 前端高频面试题-- VUE 篇](https://juejin.cn/post/7343484473184698405 'https://juejin.cn/post/7343484473184698405')\n\n[2024 前端高频面试题-- react 篇](https://juejin.cn/post/7349971654590857216 'https://juejin.cn/post/7349971654590857216')\n\n[2024 前端高频面试题-- 前端工程化篇](https://juejin.cn/post/7350535815132659749 'https://juejin.cn/post/7350535815132659749')\n\n[2024 前端高频面试题-- HTTP 和浏览器篇](https://juejin.cn/post/7351301328206331939 'https://juejin.cn/post/7351301328206331939')\n\n[2024 前端高频面试题-- 手写代码篇](https://juejin.cn/post/7353456468094599205 'https://juejin.cn/post/7353456468094599205')\n\n[2024 前端高频面试题-- 数据结构与算法篇](https://juejin.cn/post/7356060104565997605 'https://juejin.cn/post/7356060104565997605')\n\n【导读】最近在面试，把一些前端高频面试题或知识点做一个总结，一方面自己做一个梳理和总结，另外一方面也分享给正在面试或有需要的朋友。\n\n下图为思维导图：\n\n![JS.jpg](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831963d7ed524c3796b1889037da72f9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1260&h=4032&s=669131&e=jpg&b=313131)\n\n### 1.js 基本数据类型有哪些及它们的区别\n\nJavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。\n\n其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：\n\n- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。\n- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。\n\n这些数据可以分为原始数据类型和引用数据类型：\n\n- 栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）\n- 堆：引用数据类型（对象、数组和函数）\n\n两种类型的区别在于**存储位置的不同：**\n\n- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。\n\n堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：\n\n- 在数据结构中，栈中数据的存取方式为先进后出。\n- 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。\n\n在操作系统中，内存被分为栈区和堆区：\n\n- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。\n- 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。\n\n### 2\\. 数据类型检测的方式有哪些\n\n**（1）typeof**\n\n```javascript\nconsole.log(typeof 2) // number\nconsole.log(typeof true) // boolean\nconsole.log(typeof 'str') // string\nconsole.log(typeof []) // object\nconsole.log(typeof function () {}) // function\nconsole.log(typeof {}) // object\nconsole.log(typeof undefined) // undefined\nconsole.log(typeof null) // object`\n```\n\n其中数组、对象、null 都会被判断为 object，其他判断都正确。\n\n**（2）instanceof**\n\n`instanceof`可以正确判断对象的类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。\n\n```javascript\nconsole.log(2 instanceof Number) // false\nconsole.log(true instanceof Boolean) // false\nconsole.log('str' instanceof String) // false\nconsole.log([] instanceof Array) // true\nconsole.log(function () {} instanceof Function) // true\nconsole.log({} instanceof Object) // true\n```\n\n可以看到，`instanceof`**只能正确判断引用数据类型**，而不能判断基本数据类型。`instanceof` 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性。\n\n**（3） constructor**\n\njavascript\n\n```javascript\nconsole.log((2).constructor === Number) // true\nconsole.log(true.constructor === Boolean) // true\nconsole.log('str'.constructor === String) // true\nconsole.log([].constructor === Array) // true\nconsole.log(function () {}.constructor === Function) // true\nconsole.log({}.constructor === Object) // true\n```\n\n`constructor`有两个作用，一是判断数据的类型，二是对象实例通过 `constrcutor` 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，`constructor`就不能用来判断数据类型了：\n\nini\n\n```javascript\nfunction Fn() {}\nFn.prototype = new Array()\nvar f = new Fn()\nconsole.log(f.constructor === Fn) // false\nconsole.log(f.constructor === Array) // true\n```\n\n**（4）Object.prototype.toString.call()**\n\n`Object.prototype.toString.call()` 使用 Object 对象的原型方法 toString 来判断数据类型：\n\nvbscript\n\n```javascript\nvar a = Object.prototype.toString\nconsole.log(a.call(2))\nconsole.log(a.call(true))\nconsole.log(a.call('str'))\nconsole.log(a.call([]))\nconsole.log(a.call(function () {}))\nconsole.log(a.call({}))\nconsole.log(a.call(undefined))\nconsole.log(a.call(null))\n```\n\n同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？\n\n这是因为 toString 是 Object 的原型方法，而 Array、function 等**类型作为 Object 的实例，都重写了 toString 方法**。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。\n\n### 3\\. 判断数组的方式有哪些\n\n- 通过 Object.prototype.toString.call()做判断\n\njavascript\n\n```javascript\nObject.prototype.toString.call(obj).slice(8, -1) === 'Array'\n```\n\n- 通过原型链做判断\n\nini\n\n```javascript\nobj.__proto__ === Array.prototype\n```\n\n- 通过 ES6 的 Array.isArray()做判断\n\nini\n\n```javascript\nArray.isArrray(obj)\n```\n\n- 通过 instanceof 做判断\n\njavascript\n\n```javascript\nobj instanceof Array\n```\n\n- 通过 Array.prototype.isPrototypeOf\n\njavascript\n\n```javascript\nArray.prototype.isPrototypeOf(obj)\n```\n\n### 4.请简述 JavaScript 中的 this\n\nthis 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。\n\n- 第一种是**函数调用模式**，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。\n- 第二种是**方法调用模式**，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。\n- 第三种是**构造器调用模式**，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。\n- 第四种是 **apply 、 call 和 bind 调用模式**，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。\n\n这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。\n\n3.箭头函数与普通函数有什么区别\n\n**（1）箭头函数比普通函数更加简洁**\n\n- 如果没有参数，就直接写一个空括号即可\n- 如果只有一个参数，可以省去参数的括号\n- 如果有多个参数，用逗号分割\n- 如果函数体的返回值只有一句，可以省略大括号\n- 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个 void 关键字。最常见的就是调用一个函数：\n\ncsharp\n\n```javascript\nlet fn = () => void doesNotReturn()\n```\n\n**（2）箭头函数没有自己的 this**\n\n箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。\n\n**（3）箭头函数继承来的 this 指向永远不会改变**\n\njavascript\n\n```javascript\nvar id = 'GLOBAL'\nvar obj = {\n  id: 'OBJ',\n  a: function () {\n    console.log(this.id)\n  },\n  b: () => {\n    console.log(this.id)\n  },\n}\nobj.a() // 'OBJ' obj.b();    // 'GLOBAL' new obj.a()  // undefined new obj.b()  // Uncaught TypeError: obj.b is not a constructor\n```\n\n对象 obj 的方法 b 是使用箭头函数定义的，这个函数中的 this 就永远指向它定义时所处的全局执行环境中的 this，即便这个函数是作为对象 obj 的方法调用，this 依旧指向 Window 对象。需要注意，定义对象的大括号`{}`是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。\n\n**（4）call()、apply()、bind()等方法不能改变箭头函数中 this 的指向**\n\nbash\n\n```javascript\nvar id = 'Global'\nlet fun1 = () => {\n  console.log(this.id)\n}\nfun1() // 'Global' fun1.call({id: 'Obj'});     // 'Global' fun1.apply({id: 'Obj'});    // 'Global' fun1.bind({id: 'Obj'})();   // 'Global'\n```\n\n**（5）箭头函数不能作为构造函数使用**\n\n构造函数在 new 的步骤在上面已经说过了，实际上第二步就是将函数中的 this 指向该对象。 但是由于箭头函数时没有自己的 this 的，且 this 指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。\n\n**（6）箭头函数没有自己的 arguments**\n\n箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是它外层函数的 arguments 值。\n\n**（7）箭头函数没有 prototype**\n\n**（8）箭头函数不能用作 Generator 函数，不能使用 yeild 关键字**\n\n### 5.AMD 和 CommonJS 的区别\n\n它们都是实现模块体系的方式，直到 `ES2015` 出现之前，`JavaScript` 一直没有模块体系。`CommonJS` 是同步的，而 `AMD（Asynchronous Module Definition）` 从全称中可以明显看出是异步的。`CommonJS` 的设计是为服务器端开发考虑的，而 `AMD` 支持异步加载模块，更适合浏览器。\n\n我发现 `AMD` 的语法非常冗长，`CommonJS` 更接近其他语言 `import` 声明语句的用法习惯。大多数情况下，我认为 `AMD` 没有使用的必要，因为如果把所有 `JavaScript` 都捆绑进一个文件中，将无法得到异步加载的好处。此外，`CommonJS` 语法上更接近 `Node` 编写模块的风格，在前后端都使用 `JavaScript` 开发之间进行切换时，语境的切换开销较小。\n\n我很高兴看到 `ES2015` 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 `Node` 中完全推出，但是我们可以使用代码转换工具进行转换。\n\n### 6.**ES6**模块与**CommonJS**模块有什么异同？\n\nES6 Module 和 CommonJS 模块的区别：\n\n- CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const；\n- import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。\n\nES6 Module 和 CommonJS 模块的共同点：\n\n- CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n\n### 7\\. let、const、var 的区别\n\n**（1）块级作用域：** 块作用域由 `{ }`包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：\n\n- 内层变量可能覆盖外层变量\n- 用来计数的循环变量泄露为全局变量\n\n**（2）变量提升：** var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。\n\n**（3）给全局添加属性：** 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。\n\n**（4）重复声明：** var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。\n\n**（5）暂时性死区：** 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用 var 声明的变量不存在暂时性死区。\n\n**（6）初始值设置：** 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。\n\n**（7）指针指向：** let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。\n\n| **区别**           | **var** | **let** | **const** |\n| ------------------ | ------- | ------- | --------- |\n| 是否有块级作用域   | ×       | ✔️      | ✔️        |\n| 是否存在变量提升   | ✔️      | ×       | ×         |\n| 是否添加全局属性   | ✔️      | ×       | ×         |\n| 能否重复声明变量   | ✔️      | ×       | ×         |\n| 是否存在暂时性死区 | ×       | ✔️      | ✔️        |\n| 是否必须设置初始值 | ×       | ×       | ✔️        |\n| 能否改变指针指向   | ✔️      | ✔️      | ×         |\n\n### 8.new 操作符的实现原理\n\n**new 操作符的执行过程：**\n\n（1）首先创建了一个新的空对象\n\n（2）设置原型，将对象的原型设置为函数的 prototype 对象。\n\n（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n\n（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。\n\n具体实现：\n\njavascript\n\n```javascript\nobjectFactory() {   let newObject = null;   let constructor = Array.prototype.shift.call(arguments);   let result = null;   // 判断参数是否是一个函数\n  if (typeof constructor !== \"function\") {     console.error(\"type error\");     return;   }   // 新建一个空对象，对象的原型为构造函数的 prototype 对象   \n newObject = Object.create(constructor.prototype);   // 将 this 指向新建对象，并执行函数   \n result = constructor.apply(newObject, arguments);   // 判断返回对象   \n let flag = result && (typeof result === \"object\" || typeof result === \"function\");   // 判断返回结果   \n return flag ? result : newObject;\n } // 使用方法\n objectFactory(构造函数, 初始化参数);\n```\n\n### 9.数组有哪些原生方法？\n\n数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。\n\n数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。\n\n数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。\n\n数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。\n\n数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。\n\n数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法\n\n数组归并方法 reduce() 和 reduceRight() 方法\n\n### 10.for in 和 for of 的区别\n\nfor…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构（数组、对象等）并且返回各项的值，和 ES3 中的 for…in 的区别如下\n\n- for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；\n- for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；\n- 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；\n\n**总结：** for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。\n\n### 11.数组的遍历方法有哪些？\n\n| **方法**                  | **是否改变原数组** | **特点**                                                                                                                                                                                    |\n| ------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| forEach()                 | 否                 | 数组方法，值是基本类型, 改变不了;如果是引用类型分两种情况：1、没有修改形参元素的地址值, 只是修改形参元素内部的某些属性，会改变原数组；2、直接修改整个元素对象时，无法改变原数组，没有返回值 |\n| map()                     | 否                 | 数组方法，不改变原数组，有返回值，可链式调用                                                                                                                                                |\n| filter()                  | 否                 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用                                                                                                                                |\n| for...of                  | 否                 | for...of 遍历具有 Iterator 迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的 obj 对象，将异步循环变成同步循环                                                            |\n| every() 和 some()         | 否                 | 数组方法，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false.                                                                                                 |\n| find() 和 findIndex()     | 否                 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值                                                                                                   |\n| reduce() 和 reduceRight() | 否                 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作                                                                                                                               |\n\n### 12.forEach 和 map 的区别\n\n这方法都是用来遍历数组的，两者区别如下：\n\n- forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；\n- map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；\n\n### 13.原型和原型链\n\n#### 1\\. 对原型、原型链的理解\n\n在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 **proto** 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。\n\n当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。\n\n**特点：** JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。\n\n#### 2\\. 原型修改、重写\n\njavascript\n\n```javascript\nfunction Person(name) {     this.name = name } // 修改原型\nPerson.prototype.getName = function() {}\nvar p = new Person('hello') console.log(p.__proto__ === Person.prototype) // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n// 重写原型\nPerson.prototype = {     getName: function() {} } var p = new Person('hello') console.log(p.__proto__ === Person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // false\n```\n\n可以看到修改原型的时候 p 的构造函数不是指向 Person 了，因为直接给 Person 的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数 Object，所以这时候`p.constructor === Object` ，而不是`p.constructor === Person`。要想成立，就要用 constructor 指回来：\n\nini\n\n```javascript\nPerson.prototype = {     getName: function() {} } var p = new Person('hello') p.constructor = Person console.log(p.__proto__ === Person.prototype)        // true\nconsole.log(p.__proto__ === p.constructor.prototype) // true\n```\n\n#### 3\\. 原型链指向\n\njavascript\n\n```javascript\np.__proto__ // Person.prototype\nPerson.prototype.__proto__ // Object.prototype\np.__proto__.__proto__ //Object.prototype\np.__proto__.constructor.prototype.__proto__ // Object.prototype\nPerson.prototype.constructor.prototype.__proto__ // Object.prototype\np1.__proto__.constructor // Person\nPerson.prototype.constructor // Person\n```\n\n#### 4\\. 原型链的终点是什么？如何打印出原型链的终点？\n\n由于`Object`是构造函数，原型链终点是`Object.prototype.__proto__`，而`Object.prototype.__proto__=== null // true`，所以，原型链的终点是`null`。原型链上的所有原型都是对象，所有的对象最终都是由`Object`构造的，而`Object.prototype`的下一级是`Object.prototype.__proto__`。\n\n#### 5\\. 如何获得对象非原型链上的属性？\n\n使用后`hasOwnProperty()`方法来判断属性是否属于原型链的属性：\n\nscss\n\n```javascript\nfunction iterate(obj) {\n  var res = []\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) res.push(key + ': ' + obj[key])\n  }\n  return res\n}\n```\n\n### 14\\. 对执行上下文,作用域(链),闭包的理解\n\n#### 1\\. 对闭包的理解\n\n**闭包是指有权访问另一个函数作用域中变量的函数**，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。\n\n闭包有两个常用的用途；\n\n- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n- 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。\n\n比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\n\njavascript\n\n```javascript\nfunction A() {   let a = 1   window.B = function () {       console.log(a)   } } A() B() // 1\n```\n\n在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题\n\ncss\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n```\n\n首先因为 `setTimeout` 是个异步函数，所以会先把循环全部执行完毕，这时候 `i` 就是 6 了，所以会输出一堆 6。解决办法有三种：\n\n- 第一种是使用闭包的方式\n\njavascript\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n  ;(function (j) {\n    setTimeout(function timer() {\n      console.log(j)\n    }, j * 1000)\n  })(i)\n}\n```\n\n在上述代码中，首先使用了立即执行函数将 `i` 传入函数内部，这个时候值就被固定在了参数 `j` 上面不会改变，当下次执行 `timer` 这个闭包的时候，就可以使用外部函数的变量 `j`，从而达到目的。\n\n- 第二种就是使用 `setTimeout` 的第三个参数，这个参数会被当成 `timer` 函数的参数传入。\n\ncss\n\n```javascript\nfor (var i = 1; i <= 5; i++) {\n  setTimeout(\n    function timer(j) {\n      console.log(j)\n    },\n    i * 1000,\n    i\n  )\n}\n```\n\n- 第三种就是使用 `let` 定义 `i` 了来解决问题了，这个也是最为推荐的方式\n\ncss\n\n```javascript\nfor (let i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i)\n  }, i * 1000)\n}\n```\n\n#### 2\\. 对作用域、作用域链的理解\n\n##### 1）全局作用域和函数作用域\n\n（1）全局作用域\n\n- 最外层函数和最外层函数外面定义的变量拥有全局作用域\n- 所有未定义直接赋值的变量自动声明为全局作用域\n- 所有 window 对象的属性拥有全局作用域\n- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。\n\n（2）函数作用域\n\n- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到\n- 作用域是分层的，内层作用域可以访问外层作用域，反之不行\n\n##### 2）块级作用域\n\n- 使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）\n- let 和 const 声明的变量不会有变量提升，也不可以重复声明\n- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。\n\n**作用域链：** 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。\n\n作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**\n\n作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。\n\n当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。\n\n#### 3\\. 对执行上下文的理解\n\n##### 1\\. 执行上下文类型\n\n**（1）全局执行上下文**\n\n任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的 window 对象，并且设置 this 的值等于这个全局对象，一个程序中只有一个全局执行上下文。\n\n**（2）函数执行上下文**\n\n当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。\n\n**（3）** `eval`**函数执行上下文**\n\n执行在 eval 函数中的代码会有属于他自己的执行上下文，不过 eval 函数不常使用，不做介绍。\n\n##### 2\\. 执行上下文栈\n\n- JavaScript 引擎使用执行上下文栈来管理执行上下文\n- 当 JavaScript 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。\n\nsql\n\n```javascript\nlet a = 'Hello World!'\nfunction first() {\n  console.log('Inside first function')\n  second()\n  console.log('Again inside first function')\n}\nfunction second() {\n  console.log('Inside second function')\n}\nfirst() //执行顺序 //先执行second(),在执行first()\n```\n\n##### 3\\. 创建执行上下文\n\n创建执行上下文有两个阶段：**创建阶段**和**执行阶段**\n\n**1）创建阶段**\n\n（1）this 绑定\n\n- 在全局执行上下文中，this 指向全局对象（window 对象）\n- 在函数执行上下文中，this 指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined\n\n（2）创建词法环境组件\n\n- 词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。\n- 词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域\n\n（3）创建变量环境组件\n\n- 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。\n\n**2）执行阶段** 此阶段会完成对变量的分配，最后执行完代码。\n\n**简单来说执行上下文就是指：**\n\n在执行一点 JS 代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。\n\n在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments 和函数的参数。\n\n- 全局上下文：变量定义，函数声明\n- 函数上下文：变量定义，函数声明，`this`，`arguments`\n\n### 15\\. 实现 call、apply 及 bind 函数\n\n**（1）call 函数的实现步骤：**\n\n- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 处理传入的参数，截取第一个参数后的所有参数。\n- 将函数作为上下文对象的一个属性。\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性。\n- 返回结果。\n\njavascript\n\n```javascript\nFunction.prototype.myCall = function (context) {\n  // 判断调用对象\n  if (typeof this !== 'function') {\n    console.error('type error')\n  } // 获取参数\n  let args = [...arguments].slice(1),\n    result = null // 判断 context 是否传入，如果未传入则设置为 window\n  context = context || window // 将调用函数设为对象的方法\n  context.fn = this // 调用函数\n  result = context.fn(...args) // 将属性删除\n  delete context.fn\n  return result\n}\n```\n\n**（2）apply 函数的实现步骤：**\n\n- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。\n- 将函数作为上下文对象的一个属性。\n- 判断参数值是否传入\n- 使用上下文对象来调用这个方法，并保存返回结果。\n- 删除刚才新增的属性\n- 返回结果\n\njavascript\n\n```javascript\nFunction.prototype.myApply = function (context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  }\n  let result = null // 判断 context 是否存在，如果未传入则为 window\n  context = context || window // 将函数设为对象的方法\n  context.fn = this // 调用方法\n  if (arguments[1]) {\n    result = context.fn(...arguments[1])\n  } else {\n    result = context.fn()\n  } // 将属性删除\n  delete context.fn\n  return result\n}\n```\n\n**（3）bind 函数的实现步骤：**\n\n- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。\n- 保存当前函数的引用，获取其余传入参数值。\n- 创建一个函数返回\n- 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。\n\njavascript\n\n```javascript\nFunction.prototype.myBind = function (context) {\n  // 判断调用对象是否为函数\n  if (typeof this !== 'function') {\n    throw new TypeError('Error')\n  } // 获取参数\n  var args = [...arguments].slice(1),\n    fn = this\n  return function Fn() {\n    // 根据调用方式，传入不同绑定值\n    return fn.apply(\n      this instanceof Fn ? this : context,\n      args.concat(...arguments)\n    )\n  }\n}\n```\n\n### 16\\. call、apply 函数的区别\n\n它们的作用一模一样，区别仅在于传入参数的形式的不同。\n\n- apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。\n- call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。\n\n### 17\\. 异步编程的实现方式？\n\nmarkdown\n\n```javascript\nJavaScript中的异步机制可以分为以下几种：\n -   **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。\n -   **Promise** 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。\n -   **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 -   **async 函数** 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。\n```\n\n### 18\\. setTimeout、Promise、Async/Await 的区别\n\n#### （1）setTimeout\n\njavascript\n\n```javascript\nconsole.log('script start') //1. 打印 script start\nsetTimeout(function () {\n  console.log('settimeout') // 4. 打印 settimeout\n}) // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数\nconsole.log('script end') //3. 打印 script start\n// 输出顺序：script start->script end->settimeout\n```\n\n#### （2）Promise\n\nPromise 本身是**同步的立即执行函数**， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。\n\n```javascript\nconsole.log('script start')\nlet promise1 = new Promise(function (resolve) {\n  console.log('promise1')\n  resolve()\n  console.log('promise1 end')\n}).then(function () {\n  console.log('promise2')\n})\nsetTimeout(function () {\n  console.log('settimeout')\n})\nconsole.log('script end')\n// 输出顺序: script start->promise1->promise1 end->script end->promise2->settimeout\n```\n\n当 JS 主线程执行到 Promise 对象时：\n\n- promise1.then() 的回调就是一个 task\n- promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue\n- promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中\n- setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况\n\n#### （3）async/await\n\njavascript\n\n```javascript\nasync function async1() {\n  console.log('async1 start')\n  await async2()\n  console.log('async1 end')\n}\nasync function async2() {\n  console.log('async2')\n}\nconsole.log('script start')\nasync1()\nconsole.log('script end')\n// 输出顺序：script start->async1 start->async2->script end->async1 end\n```\n\nasync 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。\n\n例如：\n\njavascript\n\n```javascript\nasync function func1() {\n  return 1\n}\nconsole.log(func1())\n```\n\nfunc1 的运行结果其实就是一个 Promise 对象。因此也可以使用 then 来处理后续逻辑。\n\nscss\n\n```javascript\nfunc1().then((res) => {\n  console.log(res) // 30\n})\n```\n\nawait 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。\n\n### 19\\. Promise.all 和 Promise.race 的区别的使用场景\n\n**（1）Promise.all** `Promise.all`可以将多个`Promise`实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是**一个结果数组**，而失败的时候则返回**最先被 reject 失败状态的值**。\n\nPromise.all 中传入的是数组，返回的也是是数组，并且会将进行映射，传入的 promise 对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。\n\n需要注意，Promise.all 获得的成功结果的数组里面的数据顺序和 Promise.all 接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用 Promise.all 来解决。\n\n**（2）Promise.race**\n\n顾名思义，Promse.race 就是赛跑的意思，意思就是说，Promise.race(\\[p1, p2, p3\\])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：\n\nini\n\n```javascript\nPromise.race([promise1, timeOutPromise(5000)]).then((res) => {})\n```\n\n### 20\\. 对 async/await 的理解\n\nasync/await 其实是`Generator` 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是“异步”的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：\n\njavascript\n\n```javascript\nasync function testAsy() {\n  return 'hello world'\n}\nlet result = testAsy()\nconsole.log(result)\n```\n\n所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样：\n\njavascript\n\n```javascript\nasync function testAsy(){    return 'hello world' } let result = testAsy()  console.log(result) result.then(v=>{     console.log(v)  \n// hello world\n})\n```\n\n那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n**注意：** `Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\n### 21\\. 浏览器的垃圾回收机制\n\nmarkdown\n\n`` #### （1）垃圾回收的概念 **垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。 **回收机制**： -   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。 -   JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。 -   不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。 #### （2）垃圾回收的方式 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 **1）标记清除** -   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。 -   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 **2）引用计数** -   另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。 -   这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。 ``` function fun() {     let obj1 = {};     let obj2 = {};     obj1.a = obj2; // obj1 引用 obj2     obj2.a = obj1; // obj2 引用 obj1 } ``` 这种情况下，就要手动释放变量占用的内存： ``` obj1.a =  null  obj2.a =  null ``` #### （3）减少垃圾回收 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。 -   **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。 -   **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。 -   **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。 ``\n\n### 22\\. 哪些情况会导致内存泄漏\n\nmarkdown\n\n`以下四种情况会造成内存的泄漏： -   **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 -   **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 -   **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。 -   **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。`\n\n### 23\\. ES6 有哪些新特性\n\n1.箭头函数\n\n2.解构赋值\n\n3.模板字符串\n\n4.promise\n\n5.symbol Symbol 是 ES6 中引入的一种新的基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算\n\n6.新的变量声明方式-let 和 const\n\n7.模块化-es6 新增了模块化，根据功能封装模块，通过 import 导入，然后通过 export 导出也可以使用 export default 导出\n\n8.for…of 循环,用于遍历可迭代对象(如数组、Map 和 Set)中的元素\n\n9.扩展运算符:使用 ... 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组\n\n10.展开运算符:在 ES6 中用...来表示展开运算符,它可以将数组或者对象进行展开\n\n11.Map 和 Set，引入了两种新的数据结构，分别用于存储键值对和唯一值\n\n12.Proxy，允许在对象和函数调用等操作前后添加自定义的行为\n\n13.类（Class），引入了面向对象编程中类的概念\n\n14.默认参数（Default Parameter），在定义函数时可以给参数设置默认值\n\n### 24\\. 匿名函数的典型应用场景是什么？\n\n匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。\n\njavascript\n\n```javascript\n(function () {   // 一些代码。 })();\n```\n\n匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。\n\njavascript\n\n```javascript\nsetTimeout(function () {\n  console.log('Hello world!')\n}, 1000)\n```\n\n匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。\n\nc\n\n```javascript\nconst arr = [1, 2, 3]\nconst double = arr.map(function (el) {\n  return el * 2\n})\nconsole.log(double) // [2, 4, 6]\n```\n\n### 25.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？\n\n柯里化（currying）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。值得注意的是，对于需要被 curry 的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。\n\nscss\n\n```javascript\nfunction curry(fn) {   if (fn.length === 0) {     return fn;   } ​   function _curried(depth, args) {     return function (newArgument) {       if (depth - 1 === 0) {         return fn(...args, newArgument);       }       return _curried(depth - 1, [...args, newArgument]);     };   } ​   return _curried(fn.length, []); } ​ function add(a, b) {   return a + b; } ​ var curriedAdd = curry(add); var addFive = curriedAdd(5); ​ var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]\n```\n\n### 26.什么是事件循环？调用堆栈和任务队列之间有什么区别？\n\n事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。\n\n### 27.js 设计模式有哪些？\n\n总体来说设计模式分为三大类：(`C5S7B11`)\n\n1. **创建型模式**，共五种：**工厂方法模式**、抽象工厂模式、**单例模式**、建造者模式、**原型模式**。\n2. **结构型模式**，共七种：**适配器模式**、**装饰器模式**、**代理模式**、外观模式、桥接模式、组合模式、享元模式。\n3. **行为型模式**，共十一种：策略模式、模板方法模式、**观察者模式/发布订阅模式**、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n\n## 手写单例模式（创建模式）\n\njavascript\n\n```javascript\nlet CreateSingleton = (function () {\n  let instance\n  return function (name) {\n    if (instance) {\n      return instance\n    }\n    this.name = name\n    return (instance = this)\n  }\n})()\nCreateSingleton.prototype.getName = function () {\n  console.log(this.name)\n}\n```\n\n代码测试\n\n```javascript\nlet Winner = new CreateSingleton('Winner'); let Looser = new CreateSingleton('Looser'); ​ console.log(Winner === Looser); // true\nconsole.log(Winner.getName());  // 'Winner'\nconsole.log(Looser.getName());  // 'Winner'\n```\n\n## 手写观察者模式（行为模式）\n\nini\n\n```javascript\n// 定义observe\nconst queuedObservers = new Set();\nconst observe = fn => queuedObservers.add(fn); ​ ​\nconst observable = obj => new Proxy(obj, {   set(target, key, value, receiver) {     const result = Reflect.set(target, key, value, receiver);     // notify     \nqueuedObservers.forEach(observer => observer());     return result;   } });\n```\n\n代码测试\n\njavascript\n\n```javascript\nobj = observable({   name:'789' }) ​ observe(function test(){   console.log('触发了') }) ​ obj.name =\"前端柒八九\" // 触发了 // 前端柒八九\n```\n\n## 手写发布订阅 （行为模式）\n\nkotlin\n\n```javascript\nclass Observer {   caches = {}; // 事件中心      // eventName事件名-独一无二, fn订阅后执行的自定义行为   \non (eventName, fn){      this.caches[eventName] = this.caches[eventName] || [];     this.caches[eventName].push(fn);   }      // 发布 => 将订阅的事件进行统一执行   \nemit (eventName, data) {      if (this.caches[eventName]) {       this.caches[eventName]       .forEach(fn => fn(data));     }   }   // 取消订阅 => 若fn不传, 直接取消该事件所有订阅信息   \noff (eventName, fn) {      if (this.caches[eventName]) {       const newCaches = fn          ? this.caches[eventName].filter(e => e !== fn)          : [];       this.caches[eventName] = newCaches;     }   } ​ }\n```\n\n代码测试\n\njavascript\n\n````javascript\nob = new Observer(); ​ l1 = (data) => console.log(`l1_${data}`) l2 = (data) => console.log(`l2_${data}`) ​ ob.on('event1',l1) ob.on('event1',l2) ​ //发布订阅\nob.emit('event1',789)  // l1_789 // l2_789 ​\n// 取消，订阅l1\nob.off('event1',l1) ​ ob.emit('event1',567) //l2_567\n```\n\n## 观察者模式 VS 发布订阅模式\n\n![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c708723f8b984c1c9ceaf24d674306b3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1014&h=804&s=19910&e=webp&b=fdf8f4)\n\n1. 从表面上看：\n\n    - 观察者模式里，只有两个角色 —— **观察者** + **被观察者**\n    - 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— {经纪人|Broker}\n2. 往更深层次讲：\n\n    - 观察者和被观察者，是`松耦合`的关系\n    - 发布者和订阅者，则完全不存在耦合\n3. 从使用层面上讲：\n\n    - 观察者模式，多用于**单个应用内部**\n    - 发布订阅模式，则更多的是一种{跨应用的模式|cross-application pattern} ，比如我们常用的消息中间件\n\n\n转至 [面试](https://juejin.cn/user/835284567342782/posts)\n````\n","slug":"interview","published":1,"updated":"2024-07-24T06:50:52.495Z","_id":"clyzg0xvr000ilyxxa1t8aw84","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"2024-前端高频面试题之–-JS-篇\"><a href=\"#2024-前端高频面试题之–-JS-篇\" class=\"headerlink\" title=\"2024 前端高频面试题之– JS 篇\"></a>2024 前端高频面试题之– JS 篇</h1><p>【前端面试复习系列文章】</p>\n<p><a href=\"https://juejin.cn/post/7316349850855211046\" title=\"https://juejin.cn/post/7316349850855211046\">2024 前端高频面试题– html 篇</a></p>\n<p><a href=\"https://juejin.cn/post/6844904013620592654\" title=\"https://juejin.cn/post/6844904013620592654\">2024 前端高频面试题– CSS 篇</a></p>\n<p><a href=\"https://juejin.cn/post/7343484473184698405\" title=\"https://juejin.cn/post/7343484473184698405\">2024 前端高频面试题– VUE 篇</a></p>\n<p><a href=\"https://juejin.cn/post/7349971654590857216\" title=\"https://juejin.cn/post/7349971654590857216\">2024 前端高频面试题– react 篇</a></p>\n<p><a href=\"https://juejin.cn/post/7350535815132659749\" title=\"https://juejin.cn/post/7350535815132659749\">2024 前端高频面试题– 前端工程化篇</a></p>\n<p><a href=\"https://juejin.cn/post/7351301328206331939\" title=\"https://juejin.cn/post/7351301328206331939\">2024 前端高频面试题– HTTP 和浏览器篇</a></p>\n<p><a href=\"https://juejin.cn/post/7353456468094599205\" title=\"https://juejin.cn/post/7353456468094599205\">2024 前端高频面试题– 手写代码篇</a></p>\n<p><a href=\"https://juejin.cn/post/7356060104565997605\" title=\"https://juejin.cn/post/7356060104565997605\">2024 前端高频面试题– 数据结构与算法篇</a></p>\n<p>【导读】最近在面试，把一些前端高频面试题或知识点做一个总结，一方面自己做一个梳理和总结，另外一方面也分享给正在面试或有需要的朋友。</p>\n<p>下图为思维导图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831963d7ed524c3796b1889037da72f9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1260&h=4032&s=669131&e=jpg&b=313131\" alt=\"JS.jpg\"></p>\n<h3 id=\"1-js-基本数据类型有哪些及它们的区别\"><a href=\"#1-js-基本数据类型有哪些及它们的区别\" class=\"headerlink\" title=\"1.js 基本数据类型有哪些及它们的区别\"></a>1.js 基本数据类型有哪些及它们的区别</h3><p>JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>\n<p>其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：</p>\n<ul>\n<li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>\n<li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>\n</ul>\n<p>这些数据可以分为原始数据类型和引用数据类型：</p>\n<ul>\n<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）</li>\n<li>堆：引用数据类型（对象、数组和函数）</li>\n</ul>\n<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>\n<ul>\n<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>\n<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>\n</ul>\n<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>\n<ul>\n<li>在数据结构中，栈中数据的存取方式为先进后出。</li>\n<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>\n</ul>\n<p>在操作系统中，内存被分为栈区和堆区：</p>\n<ul>\n<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>\n<li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>\n</ul>\n<h3 id=\"2-数据类型检测的方式有哪些\"><a href=\"#2-数据类型检测的方式有哪些\" class=\"headerlink\" title=\"2. 数据类型检测的方式有哪些\"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// number</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// boolean</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&#x27;str&#x27;</span>) <span class=\"hljs-comment\">// string</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> []) <span class=\"hljs-comment\">// object</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;) <span class=\"hljs-comment\">// function</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> &#123;&#125;) <span class=\"hljs-comment\">// object</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// object`</span><br></code></pre></td></tr></table></figure>\n\n<p>其中数组、对象、null 都会被判断为 object，其他判断都正确。</p>\n<p><strong>（2）instanceof</strong></p>\n<p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Number</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Boolean</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;str&#x27;</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">String</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125; <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Function</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125; <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>\n<p><strong>（3） constructor</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>((<span class=\"hljs-number\">2</span>).<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Number</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-literal\">true</span>.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Boolean</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;str&#x27;</span>.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">String</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([].<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Array</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Function</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125;.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Object</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fn</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Fn</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>()<br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fn</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Fn</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Array</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>（4）Object.prototype.toString.call()</strong></p>\n<p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>\n<p>vbscript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">2</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">true</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&#x27;str&#x27;</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>([]))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(&#123;&#125;))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>))<br></code></pre></td></tr></table></figure>\n\n<p>同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>\n<p>这是因为 toString 是 Object 的原型方法，而 Array、function 等<strong>类型作为 Object 的实例，都重写了 toString 方法</strong>。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p>\n<h3 id=\"3-判断数组的方式有哪些\"><a href=\"#3-判断数组的方式有哪些\" class=\"headerlink\" title=\"3. 判断数组的方式有哪些\"></a>3. 判断数组的方式有哪些</h3><ul>\n<li>通过 Object.prototype.toString.call()做判断</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(obj).<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">8</span>, -<span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;Array&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过原型链做判断</li>\n</ul>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 ES6 的 Array.isArray()做判断</li>\n</ul>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArrray</span>(obj)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 instanceof 做判断</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 Array.prototype.isPrototypeOf</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-请简述-JavaScript-中的-this\"><a href=\"#4-请简述-JavaScript-中的-this\" class=\"headerlink\" title=\"4.请简述 JavaScript 中的 this\"></a>4.请简述 JavaScript 中的 this</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>\n<ul>\n<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>\n<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>\n<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>\n<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>\n</ul>\n<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>\n<p>3.箭头函数与普通函数有什么区别</p>\n<p><strong>（1）箭头函数比普通函数更加简洁</strong></p>\n<ul>\n<li>如果没有参数，就直接写一个空括号即可</li>\n<li>如果只有一个参数，可以省去参数的括号</li>\n<li>如果有多个参数，用逗号分割</li>\n<li>如果函数体的返回值只有一句，可以省略大括号</li>\n<li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个 void 关键字。最常见的就是调用一个函数：</li>\n</ul>\n<p>csharp</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fn</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doesNotReturn</span>()<br></code></pre></td></tr></table></figure>\n\n<p><strong>（2）箭头函数没有自己的 this</strong></p>\n<p>箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。</p>\n<p><strong>（3）箭头函数继承来的 this 指向永远不会改变</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-string\">&#x27;GLOBAL&#x27;</span><br><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;OBJ&#x27;</span>,<br>  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>)<br>  &#125;,<br>  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>)<br>  &#125;,<br>&#125;<br>obj.<span class=\"hljs-title function_\">a</span>() <span class=\"hljs-comment\">// &#x27;OBJ&#x27; obj.b();    // &#x27;GLOBAL&#x27; new obj.a()  // undefined new obj.b()  // Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure>\n\n<p>对象 obj 的方法 b 是使用箭头函数定义的，这个函数中的 this 就永远指向它定义时所处的全局执行环境中的 this，即便这个函数是作为对象 obj 的方法调用，this 依旧指向 Window 对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>\n<p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中 this 的指向</strong></p>\n<p>bash</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-string\">&#x27;Global&#x27;</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fun1</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>)<br>&#125;<br><span class=\"hljs-title function_\">fun1</span>() <span class=\"hljs-comment\">// &#x27;Global&#x27; fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27; fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27; fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>（5）箭头函数不能作为构造函数使用</strong></p>\n<p>构造函数在 new 的步骤在上面已经说过了，实际上第二步就是将函数中的 this 指向该对象。 但是由于箭头函数时没有自己的 this 的，且 this 指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>\n<p><strong>（6）箭头函数没有自己的 arguments</strong></p>\n<p>箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是它外层函数的 arguments 值。</p>\n<p><strong>（7）箭头函数没有 prototype</strong></p>\n<p><strong>（8）箭头函数不能用作 Generator 函数，不能使用 yeild 关键字</strong></p>\n<h3 id=\"5-AMD-和-CommonJS-的区别\"><a href=\"#5-AMD-和-CommonJS-的区别\" class=\"headerlink\" title=\"5.AMD 和 CommonJS 的区别\"></a>5.AMD 和 CommonJS 的区别</h3><p>它们都是实现模块体系的方式，直到 <code>ES2015</code> 出现之前，<code>JavaScript</code> 一直没有模块体系。<code>CommonJS</code> 是同步的，而 <code>AMD（Asynchronous Module Definition）</code> 从全称中可以明显看出是异步的。<code>CommonJS</code> 的设计是为服务器端开发考虑的，而 <code>AMD</code> 支持异步加载模块，更适合浏览器。</p>\n<p>我发现 <code>AMD</code> 的语法非常冗长，<code>CommonJS</code> 更接近其他语言 <code>import</code> 声明语句的用法习惯。大多数情况下，我认为 <code>AMD</code> 没有使用的必要，因为如果把所有 <code>JavaScript</code> 都捆绑进一个文件中，将无法得到异步加载的好处。此外，<code>CommonJS</code> 语法上更接近 <code>Node</code> 编写模块的风格，在前后端都使用 <code>JavaScript</code> 开发之间进行切换时，语境的切换开销较小。</p>\n<p>我很高兴看到 <code>ES2015</code> 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 <code>Node</code> 中完全推出，但是我们可以使用代码转换工具进行转换。</p>\n<h3 id=\"6-ES6模块与CommonJS模块有什么异同？\"><a href=\"#6-ES6模块与CommonJS模块有什么异同？\" class=\"headerlink\" title=\"6.ES6模块与CommonJS模块有什么异同？\"></a>6.<strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module 和 CommonJS 模块的区别：</p>\n<ul>\n<li>CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const；</li>\n<li>import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。</li>\n</ul>\n<p>ES6 Module 和 CommonJS 模块的共同点：</p>\n<ul>\n<li>CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li>\n</ul>\n<h3 id=\"7-let、const、var-的区别\"><a href=\"#7-let、const、var-的区别\" class=\"headerlink\" title=\"7. let、const、var 的区别\"></a>7. let、const、var 的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：</p>\n<ul>\n<li>内层变量可能覆盖外层变量</li>\n<li>用来计数的循环变量泄露为全局变量</li>\n</ul>\n<p><strong>（2）变量提升：</strong> var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>\n<p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。</p>\n<p><strong>（4）重复声明：</strong> var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。</p>\n<p><strong>（5）暂时性死区：</strong> 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用 var 声明的变量不存在暂时性死区。</p>\n<p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。</p>\n<p><strong>（7）指针指向：</strong> let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。</p>\n<table>\n<thead>\n<tr>\n<th><strong>区别</strong></th>\n<th><strong>var</strong></th>\n<th><strong>let</strong></th>\n<th><strong>const</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否有块级作用域</td>\n<td>×</td>\n<td>✔️</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>是否存在变量提升</td>\n<td>✔️</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>是否添加全局属性</td>\n<td>✔️</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>能否重复声明变量</td>\n<td>✔️</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>是否存在暂时性死区</td>\n<td>×</td>\n<td>✔️</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>是否必须设置初始值</td>\n<td>×</td>\n<td>×</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>能否改变指针指向</td>\n<td>✔️</td>\n<td>✔️</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-new-操作符的实现原理\"><a href=\"#8-new-操作符的实现原理\" class=\"headerlink\" title=\"8.new 操作符的实现原理\"></a>8.new 操作符的实现原理</h3><p><strong>new 操作符的执行过程：</strong></p>\n<p>（1）首先创建了一个新的空对象</p>\n<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>\n<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>\n<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>\n<p>具体实现：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">objectFactory</span>(<span class=\"hljs-params\"></span>) &#123;   <span class=\"hljs-keyword\">let</span> newObject = <span class=\"hljs-literal\">null</span>;   <span class=\"hljs-keyword\">let</span> constructor = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">shift</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);   <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-literal\">null</span>;   <span class=\"hljs-comment\">// 判断参数是否是一个函数</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> constructor !== <span class=\"hljs-string\">&quot;function&quot;</span>) &#123;     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&quot;type error&quot;</span>);     <span class=\"hljs-keyword\">return</span>;   &#125;   <span class=\"hljs-comment\">// 新建一个空对象，对象的原型为构造函数的 prototype 对象   </span><br> newObject = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(constructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);   <span class=\"hljs-comment\">// 将 this 指向新建对象，并执行函数   </span><br> result = constructor.<span class=\"hljs-title function_\">apply</span>(newObject, <span class=\"hljs-variable language_\">arguments</span>);   <span class=\"hljs-comment\">// 判断返回对象   </span><br> <span class=\"hljs-keyword\">let</span> flag = result &amp;&amp; (<span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&quot;object&quot;</span> || <span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&quot;function&quot;</span>);   <span class=\"hljs-comment\">// 判断返回结果   </span><br> <span class=\"hljs-keyword\">return</span> flag ? result : newObject;<br> &#125; <span class=\"hljs-comment\">// 使用方法</span><br> <span class=\"hljs-title function_\">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"9-数组有哪些原生方法？\"><a href=\"#9-数组有哪些原生方法？\" class=\"headerlink\" title=\"9.数组有哪些原生方法？\"></a>9.数组有哪些原生方法？</h3><p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</p>\n<p>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</p>\n<p>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p>\n<p>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</p>\n<p>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</p>\n<p>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</p>\n<p>数组归并方法 reduce() 和 reduceRight() 方法</p>\n<h3 id=\"10-for-in-和-for-of-的区别\"><a href=\"#10-for-in-和-for-of-的区别\" class=\"headerlink\" title=\"10.for in 和 for of 的区别\"></a>10.for in 和 for of 的区别</h3><p>for…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构（数组、对象等）并且返回各项的值，和 ES3 中的 for…in 的区别如下</p>\n<ul>\n<li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>\n<li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>\n<li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>\n</ul>\n<p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>\n<h3 id=\"11-数组的遍历方法有哪些？\"><a href=\"#11-数组的遍历方法有哪些？\" class=\"headerlink\" title=\"11.数组的遍历方法有哪些？\"></a>11.数组的遍历方法有哪些？</h3><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>是否改变原数组</strong></th>\n<th><strong>特点</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>forEach()</td>\n<td>否</td>\n<td>数组方法，值是基本类型, 改变不了;如果是引用类型分两种情况：1、没有修改形参元素的地址值, 只是修改形参元素内部的某些属性，会改变原数组；2、直接修改整个元素对象时，无法改变原数组，没有返回值</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>否</td>\n<td>数组方法，不改变原数组，有返回值，可链式调用</td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>否</td>\n<td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td>\n</tr>\n<tr>\n<td>for…of</td>\n<td>否</td>\n<td>for…of 遍历具有 Iterator 迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的 obj 对象，将异步循环变成同步循环</td>\n</tr>\n<tr>\n<td>every() 和 some()</td>\n<td>否</td>\n<td>数组方法，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false.</td>\n</tr>\n<tr>\n<td>find() 和 findIndex()</td>\n<td>否</td>\n<td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>\n</tr>\n<tr>\n<td>reduce() 和 reduceRight()</td>\n<td>否</td>\n<td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"12-forEach-和-map-的区别\"><a href=\"#12-forEach-和-map-的区别\" class=\"headerlink\" title=\"12.forEach 和 map 的区别\"></a>12.forEach 和 map 的区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p>\n<ul>\n<li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li>\n<li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>\n</ul>\n<h3 id=\"13-原型和原型链\"><a href=\"#13-原型和原型链\" class=\"headerlink\" title=\"13.原型和原型链\"></a>13.原型和原型链</h3><h4 id=\"1-对原型、原型链的理解\"><a href=\"#1-对原型、原型链的理解\" class=\"headerlink\" title=\"1. 对原型、原型链的理解\"></a>1. 对原型、原型链的理解</h4><p>在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p>\n<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p>\n<p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>\n<h4 id=\"2-原型修改、重写\"><a href=\"#2-原型修改、重写\" class=\"headerlink\" title=\"2. 原型修改、重写\"></a>2. 原型修改、重写</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;     <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name &#125; <span class=\"hljs-comment\">// 修改原型</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>) <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === p.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-comment\">// 重写原型</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = &#123;     <span class=\"hljs-attr\">getName</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125; &#125; <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>) <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)        <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === p.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到修改原型的时候 p 的构造函数不是指向 Person 了，因为直接给 Person 的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数 Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用 constructor 指回来：</p>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = &#123;     <span class=\"hljs-attr\">getName</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125; &#125; <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>) p.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Person</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)        <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === p.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-原型链指向\"><a href=\"#3-原型链指向\" class=\"headerlink\" title=\"3. 原型链指向\"></a>3. 原型链指向</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">p.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Person.prototype</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Object.prototype</span><br>p.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">//Object.prototype</span><br>p.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Object.prototype</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Object.prototype</span><br>p1.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">constructor</span> <span class=\"hljs-comment\">// Person</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> <span class=\"hljs-comment\">// Person</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-原型链的终点是什么？如何打印出原型链的终点？\"><a href=\"#4-原型链的终点是什么？如何打印出原型链的终点？\" class=\"headerlink\" title=\"4. 原型链的终点是什么？如何打印出原型链的终点？\"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h4><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p>\n<h4 id=\"5-如何获得对象非原型链上的属性？\"><a href=\"#5-如何获得对象非原型链上的属性？\" class=\"headerlink\" title=\"5. 如何获得对象非原型链上的属性？\"></a>5. 如何获得对象非原型链上的属性？</h4><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p>\n<p>scss</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">iterate</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> res = []<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> obj) &#123;<br>    <span class=\"hljs-keyword\">if</span> (obj.<span class=\"hljs-title function_\">hasOwnProperty</span>(key)) res.<span class=\"hljs-title function_\">push</span>(key + <span class=\"hljs-string\">&#x27;: &#x27;</span> + obj[key])<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"14-对执行上下文-作用域-链-闭包的理解\"><a href=\"#14-对执行上下文-作用域-链-闭包的理解\" class=\"headerlink\" title=\"14. 对执行上下文,作用域(链),闭包的理解\"></a>14. 对执行上下文,作用域(链),闭包的理解</h3><h4 id=\"1-对闭包的理解\"><a href=\"#1-对闭包的理解\" class=\"headerlink\" title=\"1. 对闭包的理解\"></a>1. 对闭包的理解</h4><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>\n<p>闭包有两个常用的用途；</p>\n<ul>\n<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>\n<li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>\n</ul>\n<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\"></span>) &#123;   <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>   <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">B</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;       <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a)   &#125; &#125; <span class=\"hljs-title function_\">A</span>() <span class=\"hljs-title function_\">B</span>() <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>\n<p>css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i)<br>  &#125;, i * <span class=\"hljs-number\">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>\n<ul>\n<li>第一种是使用闭包的方式</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  ;(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">j</span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(j)<br>    &#125;, j * <span class=\"hljs-number\">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>\n<ul>\n<li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li>\n</ul>\n<p>css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<br>    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\">j</span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(j)<br>    &#125;,<br>    i * <span class=\"hljs-number\">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li>\n</ul>\n<p>css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i)<br>  &#125;, i * <span class=\"hljs-number\">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-对作用域、作用域链的理解\"><a href=\"#2-对作用域、作用域链的理解\" class=\"headerlink\" title=\"2. 对作用域、作用域链的理解\"></a>2. 对作用域、作用域链的理解</h4><h5 id=\"1）全局作用域和函数作用域\"><a href=\"#1）全局作用域和函数作用域\" class=\"headerlink\" title=\"1）全局作用域和函数作用域\"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>\n<ul>\n<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>\n<li>所有未定义直接赋值的变量自动声明为全局作用域</li>\n<li>所有 window 对象的属性拥有全局作用域</li>\n<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>\n</ul>\n<p>（2）函数作用域</p>\n<ul>\n<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>\n<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>\n</ul>\n<h5 id=\"2）块级作用域\"><a href=\"#2）块级作用域\" class=\"headerlink\" title=\"2）块级作用域\"></a>2）块级作用域</h5><ul>\n<li>使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>\n<li>let 和 const 声明的变量不会有变量提升，也不可以重复声明</li>\n<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>\n</ul>\n<p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。</p>\n<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>\n<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>\n<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>\n<h4 id=\"3-对执行上下文的理解\"><a href=\"#3-对执行上下文的理解\" class=\"headerlink\" title=\"3. 对执行上下文的理解\"></a>3. 对执行上下文的理解</h4><h5 id=\"1-执行上下文类型\"><a href=\"#1-执行上下文类型\" class=\"headerlink\" title=\"1. 执行上下文类型\"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p>\n<p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的 window 对象，并且设置 this 的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p>\n<p><strong>（2）函数执行上下文</strong></p>\n<p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p>\n<p><strong>（3）</strong> <code>eval</code><strong>函数执行上下文</strong></p>\n<p>执行在 eval 函数中的代码会有属于他自己的执行上下文，不过 eval 函数不常使用，不做介绍。</p>\n<h5 id=\"2-执行上下文栈\"><a href=\"#2-执行上下文栈\" class=\"headerlink\" title=\"2. 执行上下文栈\"></a>2. 执行上下文栈</h5><ul>\n<li>JavaScript 引擎使用执行上下文栈来管理执行上下文</li>\n<li>当 JavaScript 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>\n</ul>\n<p>sql</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-string\">&#x27;Hello World!&#x27;</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">first</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inside first function&#x27;</span>)<br>  <span class=\"hljs-title function_\">second</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Again inside first function&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">second</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inside second function&#x27;</span>)<br>&#125;<br><span class=\"hljs-title function_\">first</span>() <span class=\"hljs-comment\">//执行顺序 //先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-创建执行上下文\"><a href=\"#3-创建执行上下文\" class=\"headerlink\" title=\"3. 创建执行上下文\"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p>\n<p><strong>1）创建阶段</strong></p>\n<p>（1）this 绑定</p>\n<ul>\n<li>在全局执行上下文中，this 指向全局对象（window 对象）</li>\n<li>在函数执行上下文中，this 指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>\n</ul>\n<p>（2）创建词法环境组件</p>\n<ul>\n<li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li>\n<li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>\n</ul>\n<p>（3）创建变量环境组件</p>\n<ul>\n<li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li>\n</ul>\n<p><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。</p>\n<p><strong>简单来说执行上下文就是指：</strong></p>\n<p>在执行一点 JS 代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p>\n<p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments 和函数的参数。</p>\n<ul>\n<li>全局上下文：变量定义，函数声明</li>\n<li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>\n</ul>\n<h3 id=\"15-实现-call、apply-及-bind-函数\"><a href=\"#15-实现-call、apply-及-bind-函数\" class=\"headerlink\" title=\"15. 实现 call、apply 及 bind 函数\"></a>15. 实现 call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p>\n<ul>\n<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>处理传入的参数，截取第一个参数后的所有参数。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性。</li>\n<li>返回结果。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myCall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-comment\">// 判断调用对象</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;type error&#x27;</span>)<br>  &#125; <span class=\"hljs-comment\">// 获取参数</span><br>  <span class=\"hljs-keyword\">let</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>),<br>    result = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class=\"hljs-variable language_\">window</span> <span class=\"hljs-comment\">// 将调用函数设为对象的方法</span><br>  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-comment\">// 调用函数</span><br>  result = context.<span class=\"hljs-title function_\">fn</span>(...args) <span class=\"hljs-comment\">// 将属性删除</span><br>  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>（2）apply 函数的实现步骤：</strong></p>\n<ul>\n<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>判断参数值是否传入</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性</li>\n<li>返回结果</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myApply</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-comment\">// 判断调用对象是否为函数</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class=\"hljs-variable language_\">window</span> <span class=\"hljs-comment\">// 将函数设为对象的方法</span><br>  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-comment\">// 调用方法</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]) &#123;<br>    result = context.<span class=\"hljs-title function_\">fn</span>(...<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>])<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    result = context.<span class=\"hljs-title function_\">fn</span>()<br>  &#125; <span class=\"hljs-comment\">// 将属性删除</span><br>  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>（3）bind 函数的实现步骤：</strong></p>\n<ul>\n<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>保存当前函数的引用，获取其余传入参数值。</li>\n<li>创建一个函数返回</li>\n<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-comment\">// 判断调用对象是否为函数</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br>  &#125; <span class=\"hljs-comment\">// 获取参数</span><br>  <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>),<br>    fn = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fn</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 根据调用方式，传入不同绑定值</span><br>    <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<br>      <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Fn</span> ? <span class=\"hljs-variable language_\">this</span> : context,<br>      args.<span class=\"hljs-title function_\">concat</span>(...<span class=\"hljs-variable language_\">arguments</span>)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"16-call、apply-函数的区别\"><a href=\"#16-call、apply-函数的区别\" class=\"headerlink\" title=\"16. call、apply 函数的区别\"></a>16. call、apply 函数的区别</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>\n<ul>\n<li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>\n<li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>\n</ul>\n<h3 id=\"17-异步编程的实现方式？\"><a href=\"#17-异步编程的实现方式？\" class=\"headerlink\" title=\"17. 异步编程的实现方式？\"></a>17. 异步编程的实现方式？</h3><p>markdown</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">JavaScript</span>中的异步机制可以分为以下几种：<br> -   **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。<br> -   **<span class=\"hljs-title class_\">Promise</span>** 的方式，使用 <span class=\"hljs-title class_\">Promise</span> 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。<br> -   **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 -   **<span class=\"hljs-keyword\">async</span> 函数** 的方式，<span class=\"hljs-keyword\">async</span> 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 <span class=\"hljs-keyword\">await</span> 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"18-setTimeout、Promise、Async-x2F-Await-的区别\"><a href=\"#18-setTimeout、Promise、Async-x2F-Await-的区别\" class=\"headerlink\" title=\"18. setTimeout、Promise、Async&#x2F;Await 的区别\"></a>18. setTimeout、Promise、Async&#x2F;Await 的区别</h3><h4 id=\"（1）setTimeout\"><a href=\"#（1）setTimeout\" class=\"headerlink\" title=\"（1）setTimeout\"></a>（1）setTimeout</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script start&#x27;</span>) <span class=\"hljs-comment\">//1. 打印 script start</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>) <span class=\"hljs-comment\">// 4. 打印 settimeout</span><br>&#125;) <span class=\"hljs-comment\">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script end&#x27;</span>) <span class=\"hljs-comment\">//3. 打印 script start</span><br><span class=\"hljs-comment\">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（2）Promise\"><a href=\"#（2）Promise\" class=\"headerlink\" title=\"（2）Promise\"></a>（2）Promise</h4><p>Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then&#x2F;catch 等，当主栈完成后，才会去调用 resolve&#x2F;reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> promise1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>)<br>  <span class=\"hljs-title function_\">resolve</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br><span class=\"hljs-comment\">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure>\n\n<p>当 JS 主线程执行到 Promise 对象时：</p>\n<ul>\n<li>promise1.then() 的回调就是一个 task</li>\n<li>promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>\n<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>\n<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>\n</ul>\n<h4 id=\"（3）async-x2F-await\"><a href=\"#（3）async-x2F-await\" class=\"headerlink\" title=\"（3）async&#x2F;await\"></a>（3）async&#x2F;await</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">async1</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;async1 start&#x27;</span>)<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">async2</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">async2</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;async2&#x27;</span>)<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-title function_\">async1</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br><span class=\"hljs-comment\">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure>\n\n<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>\n<p>例如：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func1</span>())<br></code></pre></td></tr></table></figure>\n\n<p>func1 的运行结果其实就是一个 Promise 对象。因此也可以使用 then 来处理后续逻辑。</p>\n<p>scss</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">func1</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res) <span class=\"hljs-comment\">// 30</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。</p>\n<h3 id=\"19-Promise-all-和-Promise-race-的区别的使用场景\"><a href=\"#19-Promise-all-和-Promise-race-的区别的使用场景\" class=\"headerlink\" title=\"19. Promise.all 和 Promise.race 的区别的使用场景\"></a>19. Promise.all 和 Promise.race 的区别的使用场景</h3><p><strong>（1）Promise.all</strong> <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被 reject 失败状态的值</strong>。</p>\n<p>Promise.all 中传入的是数组，返回的也是是数组，并且会将进行映射，传入的 promise 对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>\n<p>需要注意，Promise.all 获得的成功结果的数组里面的数据顺序和 Promise.all 接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用 Promise.all 来解决。</p>\n<p><strong>（2）Promise.race</strong></p>\n<p>顾名思义，Promse.race 就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([promise1, <span class=\"hljs-title function_\">timeOutPromise</span>(<span class=\"hljs-number\">5000</span>)]).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"20-对-async-x2F-await-的理解\"><a href=\"#20-对-async-x2F-await-的理解\" class=\"headerlink\" title=\"20. 对 async&#x2F;await 的理解\"></a>20. 对 async&#x2F;await 的理解</h3><p>async&#x2F;await 其实是<code>Generator</code> 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是“异步”的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testAsy</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br>&#125;<br><span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title function_\">testAsy</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result)<br></code></pre></td></tr></table></figure>\n\n<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>\n<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testAsy</span>(<span class=\"hljs-params\"></span>)&#123;    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span> &#125; <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title function_\">testAsy</span>()  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result) result.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span>=&gt;</span>&#123;     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v)  <br><span class=\"hljs-comment\">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>\n<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<p><strong>注意：</strong> <code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>\n<h3 id=\"21-浏览器的垃圾回收机制\"><a href=\"#21-浏览器的垃圾回收机制\" class=\"headerlink\" title=\"21. 浏览器的垃圾回收机制\"></a>21. 浏览器的垃圾回收机制</h3><p>markdown</p>\n<p><code>#### （1）垃圾回收的概念 **垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。 **回收机制**： -   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。 -   JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。 -   不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。 #### （2）垃圾回收的方式 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 **1）标记清除** -   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。 -   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 **2）引用计数** -   另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。 -   这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。 ``` function fun() &#123;     let obj1 = &#123;&#125;;     let obj2 = &#123;&#125;;     obj1.a = obj2; // obj1 引用 obj2     obj2.a = obj1; // obj2 引用 obj1 &#125; ``` 这种情况下，就要手动释放变量占用的内存： ``` obj1.a =  null  obj2.a =  null ``` #### （3）减少垃圾回收 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。 -   **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。 -   **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。 -   **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</code></p>\n<h3 id=\"22-哪些情况会导致内存泄漏\"><a href=\"#22-哪些情况会导致内存泄漏\" class=\"headerlink\" title=\"22. 哪些情况会导致内存泄漏\"></a>22. 哪些情况会导致内存泄漏</h3><p>markdown</p>\n<p><code>以下四种情况会造成内存的泄漏： -   **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 -   **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 -   **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。 -   **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</code></p>\n<h3 id=\"23-ES6-有哪些新特性\"><a href=\"#23-ES6-有哪些新特性\" class=\"headerlink\" title=\"23. ES6 有哪些新特性\"></a>23. ES6 有哪些新特性</h3><p>1.箭头函数</p>\n<p>2.解构赋值</p>\n<p>3.模板字符串</p>\n<p>4.promise</p>\n<p>5.symbol Symbol 是 ES6 中引入的一种新的基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算</p>\n<p>6.新的变量声明方式-let 和 const</p>\n<p>7.模块化-es6 新增了模块化，根据功能封装模块，通过 import 导入，然后通过 export 导出也可以使用 export default 导出</p>\n<p>8.for…of 循环,用于遍历可迭代对象(如数组、Map 和 Set)中的元素</p>\n<p>9.扩展运算符:使用 … 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组</p>\n<p>10.展开运算符:在 ES6 中用…来表示展开运算符,它可以将数组或者对象进行展开</p>\n<p>11.Map 和 Set，引入了两种新的数据结构，分别用于存储键值对和唯一值</p>\n<p>12.Proxy，允许在对象和函数调用等操作前后添加自定义的行为</p>\n<p>13.类（Class），引入了面向对象编程中类的概念</p>\n<p>14.默认参数（Default Parameter），在定义函数时可以给参数设置默认值</p>\n<h3 id=\"24-匿名函数的典型应用场景是什么？\"><a href=\"#24-匿名函数的典型应用场景是什么？\" class=\"headerlink\" title=\"24. 匿名函数的典型应用场景是什么？\"></a>24. 匿名函数的典型应用场景是什么？</h3><p>匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;   <span class=\"hljs-comment\">// 一些代码。 &#125;)();</span><br></code></pre></td></tr></table></figure>\n\n<p>匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello world!&#x27;</span>)<br>&#125;, <span class=\"hljs-number\">1000</span>)<br></code></pre></td></tr></table></figure>\n\n<p>匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。</p>\n<p>c</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br><span class=\"hljs-keyword\">const</span> double = arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> el * <span class=\"hljs-number\">2</span><br>&#125;)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(double) <span class=\"hljs-comment\">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"25-你能举出一个柯里化函数（curry-function）的例子吗？它有哪些好处？\"><a href=\"#25-你能举出一个柯里化函数（curry-function）的例子吗？它有哪些好处？\" class=\"headerlink\" title=\"25.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？\"></a>25.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？</h3><p>柯里化（currying）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。值得注意的是，对于需要被 curry 的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。</p>\n<p>scss</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">fn</span>) &#123;   <span class=\"hljs-keyword\">if</span> (fn.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) &#123;     <span class=\"hljs-keyword\">return</span> fn;   &#125; ​   <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_curried</span>(<span class=\"hljs-params\">depth, args</span>) &#123;     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newArgument</span>) &#123;       <span class=\"hljs-keyword\">if</span> (depth - <span class=\"hljs-number\">1</span> === <span class=\"hljs-number\">0</span>) &#123;         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(...args, newArgument);       &#125;       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_curried</span>(depth - <span class=\"hljs-number\">1</span>, [...args, newArgument]);     &#125;;   &#125; ​   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_curried</span>(fn.<span class=\"hljs-property\">length</span>, []); &#125; ​ <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;   <span class=\"hljs-keyword\">return</span> a + b; &#125; ​ <span class=\"hljs-keyword\">var</span> curriedAdd = <span class=\"hljs-title function_\">curry</span>(add); <span class=\"hljs-keyword\">var</span> addFive = <span class=\"hljs-title function_\">curriedAdd</span>(<span class=\"hljs-number\">5</span>); ​ <span class=\"hljs-keyword\">var</span> result = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">map</span>(addFive); <span class=\"hljs-comment\">// [5, 6, 7, 8, 9, 10]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"26-什么是事件循环？调用堆栈和任务队列之间有什么区别？\"><a href=\"#26-什么是事件循环？调用堆栈和任务队列之间有什么区别？\" class=\"headerlink\" title=\"26.什么是事件循环？调用堆栈和任务队列之间有什么区别？\"></a>26.什么是事件循环？调用堆栈和任务队列之间有什么区别？</h3><p>事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。</p>\n<h3 id=\"27-js-设计模式有哪些？\"><a href=\"#27-js-设计模式有哪些？\" class=\"headerlink\" title=\"27.js 设计模式有哪些？\"></a>27.js 设计模式有哪些？</h3><p>总体来说设计模式分为三大类：(<code>C5S7B11</code>)</p>\n<ol>\n<li><strong>创建型模式</strong>，共五种：<strong>工厂方法模式</strong>、抽象工厂模式、<strong>单例模式</strong>、建造者模式、<strong>原型模式</strong>。</li>\n<li><strong>结构型模式</strong>，共七种：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。</li>\n<li><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、<strong>观察者模式&#x2F;发布订阅模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>\n</ol>\n<h2 id=\"手写单例模式（创建模式）\"><a href=\"#手写单例模式（创建模式）\" class=\"headerlink\" title=\"手写单例模式（创建模式）\"></a>手写单例模式（创建模式）</h2><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">CreateSingleton</span> = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> instance<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (instance) &#123;<br>      <span class=\"hljs-keyword\">return</span> instance<br>    &#125;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>    <span class=\"hljs-keyword\">return</span> (instance = <span class=\"hljs-variable language_\">this</span>)<br>  &#125;<br>&#125;)()<br><span class=\"hljs-title class_\">CreateSingleton</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>代码测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Winner</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CreateSingleton</span>(<span class=\"hljs-string\">&#x27;Winner&#x27;</span>); <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Looser</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CreateSingleton</span>(<span class=\"hljs-string\">&#x27;Looser&#x27;</span>); ​ <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Winner</span> === <span class=\"hljs-title class_\">Looser</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Winner</span>.<span class=\"hljs-title function_\">getName</span>());  <span class=\"hljs-comment\">// &#x27;Winner&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Looser</span>.<span class=\"hljs-title function_\">getName</span>());  <span class=\"hljs-comment\">// &#x27;Winner&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"手写观察者模式（行为模式）\"><a href=\"#手写观察者模式（行为模式）\" class=\"headerlink\" title=\"手写观察者模式（行为模式）\"></a>手写观察者模式（行为模式）</h2><p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义observe</span><br><span class=\"hljs-keyword\">const</span> queuedObservers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">observe</span> = fn =&gt; queuedObservers.<span class=\"hljs-title function_\">add</span>(fn); ​ ​<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">observable</span> = obj =&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, &#123;   <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, key, value, receiver</span>) &#123;     <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);     <span class=\"hljs-comment\">// notify     </span><br>queuedObservers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> <span class=\"hljs-title function_\">observer</span>());     <span class=\"hljs-keyword\">return</span> result;   &#125; &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>代码测试</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj = <span class=\"hljs-title function_\">observable</span>(&#123;   <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;789&#x27;</span> &#125;) ​ <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>)&#123;   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;触发了&#x27;</span>) &#125;) ​ obj.<span class=\"hljs-property\">name</span> =<span class=\"hljs-string\">&quot;前端柒八九&quot;</span> <span class=\"hljs-comment\">// 触发了 // 前端柒八九</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"手写发布订阅-（行为模式）\"><a href=\"#手写发布订阅-（行为模式）\" class=\"headerlink\" title=\"手写发布订阅 （行为模式）\"></a>手写发布订阅 （行为模式）</h2><p>kotlin</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Observer</span> &#123;   caches = &#123;&#125;; <span class=\"hljs-comment\">// 事件中心      // eventName事件名-独一无二, fn订阅后执行的自定义行为   </span><br>on (eventName, fn)&#123;      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName] = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName] || [];     <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName].<span class=\"hljs-title function_\">push</span>(fn);   &#125;      <span class=\"hljs-comment\">// 发布 =&gt; 将订阅的事件进行统一执行   </span><br>emit (eventName, data) &#123;      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName]) &#123;       <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName]       .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =&gt;</span> <span class=\"hljs-title function_\">fn</span>(data));     &#125;   &#125;   <span class=\"hljs-comment\">// 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息   </span><br>off (eventName, fn) &#123;      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName]) &#123;       <span class=\"hljs-keyword\">const</span> newCaches = fn          ? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName].<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> e !== fn)          : [];       <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName] = newCaches;     &#125;   &#125; ​ &#125;<br></code></pre></td></tr></table></figure>\n\n<p>代码测试</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ob = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>(); ​ l1 = <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`l1_<span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>) l2 = <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`l2_<span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>) ​ ob.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,l1) ob.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,l2) ​ <span class=\"hljs-comment\">//发布订阅</span><br>ob.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,<span class=\"hljs-number\">789</span>)  <span class=\"hljs-comment\">// l1_789 // l2_789 ​</span><br><span class=\"hljs-comment\">// 取消，订阅l1</span><br>ob.<span class=\"hljs-title function_\">off</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,l1) ​ ob.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,<span class=\"hljs-number\">567</span>) <span class=\"hljs-comment\">//l2_567</span><br><span class=\"hljs-string\">``</span><span class=\"hljs-string\">`</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">## 观察者模式 VS 发布订阅模式</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c708723f8b984c1c9ceaf24d674306b3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1014&amp;h=804&amp;s=19910&amp;e=webp&amp;b=fdf8f4)</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">1. 从表面上看：</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    - 观察者模式里，只有两个角色 —— **观察者** + **被观察者**</span><br><span class=\"hljs-string\">    - 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— &#123;经纪人|Broker&#125;</span><br><span class=\"hljs-string\">2. 往更深层次讲：</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    - 观察者和被观察者，是`</span>松耦合<span class=\"hljs-string\">`的关系</span><br><span class=\"hljs-string\">    - 发布者和订阅者，则完全不存在耦合</span><br><span class=\"hljs-string\">3. 从使用层面上讲：</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    - 观察者模式，多用于**单个应用内部**</span><br><span class=\"hljs-string\">    - 发布订阅模式，则更多的是一种&#123;跨应用的模式|cross-application pattern&#125; ，比如我们常用的消息中间件</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">转至 [面试](https://juejin.cn/user/835284567342782/posts)</span><br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":25917,"excerpt":"","more":"<h1 id=\"2024-前端高频面试题之–-JS-篇\"><a href=\"#2024-前端高频面试题之–-JS-篇\" class=\"headerlink\" title=\"2024 前端高频面试题之– JS 篇\"></a>2024 前端高频面试题之– JS 篇</h1><p>【前端面试复习系列文章】</p>\n<p><a href=\"https://juejin.cn/post/7316349850855211046\" title=\"https://juejin.cn/post/7316349850855211046\">2024 前端高频面试题– html 篇</a></p>\n<p><a href=\"https://juejin.cn/post/6844904013620592654\" title=\"https://juejin.cn/post/6844904013620592654\">2024 前端高频面试题– CSS 篇</a></p>\n<p><a href=\"https://juejin.cn/post/7343484473184698405\" title=\"https://juejin.cn/post/7343484473184698405\">2024 前端高频面试题– VUE 篇</a></p>\n<p><a href=\"https://juejin.cn/post/7349971654590857216\" title=\"https://juejin.cn/post/7349971654590857216\">2024 前端高频面试题– react 篇</a></p>\n<p><a href=\"https://juejin.cn/post/7350535815132659749\" title=\"https://juejin.cn/post/7350535815132659749\">2024 前端高频面试题– 前端工程化篇</a></p>\n<p><a href=\"https://juejin.cn/post/7351301328206331939\" title=\"https://juejin.cn/post/7351301328206331939\">2024 前端高频面试题– HTTP 和浏览器篇</a></p>\n<p><a href=\"https://juejin.cn/post/7353456468094599205\" title=\"https://juejin.cn/post/7353456468094599205\">2024 前端高频面试题– 手写代码篇</a></p>\n<p><a href=\"https://juejin.cn/post/7356060104565997605\" title=\"https://juejin.cn/post/7356060104565997605\">2024 前端高频面试题– 数据结构与算法篇</a></p>\n<p>【导读】最近在面试，把一些前端高频面试题或知识点做一个总结，一方面自己做一个梳理和总结，另外一方面也分享给正在面试或有需要的朋友。</p>\n<p>下图为思维导图：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831963d7ed524c3796b1889037da72f9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1260&h=4032&s=669131&e=jpg&b=313131\" alt=\"JS.jpg\"></p>\n<h3 id=\"1-js-基本数据类型有哪些及它们的区别\"><a href=\"#1-js-基本数据类型有哪些及它们的区别\" class=\"headerlink\" title=\"1.js 基本数据类型有哪些及它们的区别\"></a>1.js 基本数据类型有哪些及它们的区别</h3><p>JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>\n<p>其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：</p>\n<ul>\n<li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>\n<li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>\n</ul>\n<p>这些数据可以分为原始数据类型和引用数据类型：</p>\n<ul>\n<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String、Symbol、BigInt）</li>\n<li>堆：引用数据类型（对象、数组和函数）</li>\n</ul>\n<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>\n<ul>\n<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>\n<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>\n</ul>\n<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>\n<ul>\n<li>在数据结构中，栈中数据的存取方式为先进后出。</li>\n<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>\n</ul>\n<p>在操作系统中，内存被分为栈区和堆区：</p>\n<ul>\n<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>\n<li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>\n</ul>\n<h3 id=\"2-数据类型检测的方式有哪些\"><a href=\"#2-数据类型检测的方式有哪些\" class=\"headerlink\" title=\"2. 数据类型检测的方式有哪些\"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// number</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">true</span>) <span class=\"hljs-comment\">// boolean</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-string\">&#x27;str&#x27;</span>) <span class=\"hljs-comment\">// string</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> []) <span class=\"hljs-comment\">// object</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;) <span class=\"hljs-comment\">// function</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> &#123;&#125;) <span class=\"hljs-comment\">// object</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">undefined</span>) <span class=\"hljs-comment\">// undefined</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-literal\">null</span>) <span class=\"hljs-comment\">// object`</span><br></code></pre></td></tr></table></figure>\n\n<p>其中数组、对象、null 都会被判断为 object，其他判断都正确。</p>\n<p><strong>（2）instanceof</strong></p>\n<p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Number</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Boolean</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;str&#x27;</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">String</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([] <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125; <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Function</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125; <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>\n<p><strong>（3） constructor</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>((<span class=\"hljs-number\">2</span>).<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Number</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-literal\">true</span>.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Boolean</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;str&#x27;</span>.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">String</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([].<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Array</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Function</span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(&#123;&#125;.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Object</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fn</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Fn</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>()<br><span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Fn</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Fn</span>) <span class=\"hljs-comment\">// false</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(f.<span class=\"hljs-property\">constructor</span> === <span class=\"hljs-title class_\">Array</span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>（4）Object.prototype.toString.call()</strong></p>\n<p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>\n<p>vbscript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-number\">2</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">true</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-string\">&#x27;str&#x27;</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>([]))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(&#123;&#125;))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">undefined</span>))<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>))<br></code></pre></td></tr></table></figure>\n\n<p>同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>\n<p>这是因为 toString 是 Object 的原型方法，而 Array、function 等<strong>类型作为 Object 的实例，都重写了 toString 方法</strong>。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p>\n<h3 id=\"3-判断数组的方式有哪些\"><a href=\"#3-判断数组的方式有哪些\" class=\"headerlink\" title=\"3. 判断数组的方式有哪些\"></a>3. 判断数组的方式有哪些</h3><ul>\n<li>通过 Object.prototype.toString.call()做判断</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">toString</span>.<span class=\"hljs-title function_\">call</span>(obj).<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">8</span>, -<span class=\"hljs-number\">1</span>) === <span class=\"hljs-string\">&#x27;Array&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过原型链做判断</li>\n</ul>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 ES6 的 Array.isArray()做判断</li>\n</ul>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">isArrray</span>(obj)<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 instanceof 做判断</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Array</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 Array.prototype.isPrototypeOf</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-title function_\">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-请简述-JavaScript-中的-this\"><a href=\"#4-请简述-JavaScript-中的-this\" class=\"headerlink\" title=\"4.请简述 JavaScript 中的 this\"></a>4.请简述 JavaScript 中的 this</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>\n<ul>\n<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>\n<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>\n<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>\n<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>\n</ul>\n<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>\n<p>3.箭头函数与普通函数有什么区别</p>\n<p><strong>（1）箭头函数比普通函数更加简洁</strong></p>\n<ul>\n<li>如果没有参数，就直接写一个空括号即可</li>\n<li>如果只有一个参数，可以省去参数的括号</li>\n<li>如果有多个参数，用逗号分割</li>\n<li>如果函数体的返回值只有一句，可以省略大括号</li>\n<li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个 void 关键字。最常见的就是调用一个函数：</li>\n</ul>\n<p>csharp</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fn</span> = (<span class=\"hljs-params\"></span>) =&gt; <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doesNotReturn</span>()<br></code></pre></td></tr></table></figure>\n\n<p><strong>（2）箭头函数没有自己的 this</strong></p>\n<p>箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。</p>\n<p><strong>（3）箭头函数继承来的 this 指向永远不会改变</strong></p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-string\">&#x27;GLOBAL&#x27;</span><br><span class=\"hljs-keyword\">var</span> obj = &#123;<br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">&#x27;OBJ&#x27;</span>,<br>  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>)<br>  &#125;,<br>  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-function\">() =&gt;</span> &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>)<br>  &#125;,<br>&#125;<br>obj.<span class=\"hljs-title function_\">a</span>() <span class=\"hljs-comment\">// &#x27;OBJ&#x27; obj.b();    // &#x27;GLOBAL&#x27; new obj.a()  // undefined new obj.b()  // Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure>\n\n<p>对象 obj 的方法 b 是使用箭头函数定义的，这个函数中的 this 就永远指向它定义时所处的全局执行环境中的 this，即便这个函数是作为对象 obj 的方法调用，this 依旧指向 Window 对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>\n<p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中 this 的指向</strong></p>\n<p>bash</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> id = <span class=\"hljs-string\">&#x27;Global&#x27;</span><br><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title function_\">fun1</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">id</span>)<br>&#125;<br><span class=\"hljs-title function_\">fun1</span>() <span class=\"hljs-comment\">// &#x27;Global&#x27; fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27; fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27; fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>（5）箭头函数不能作为构造函数使用</strong></p>\n<p>构造函数在 new 的步骤在上面已经说过了，实际上第二步就是将函数中的 this 指向该对象。 但是由于箭头函数时没有自己的 this 的，且 this 指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>\n<p><strong>（6）箭头函数没有自己的 arguments</strong></p>\n<p>箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是它外层函数的 arguments 值。</p>\n<p><strong>（7）箭头函数没有 prototype</strong></p>\n<p><strong>（8）箭头函数不能用作 Generator 函数，不能使用 yeild 关键字</strong></p>\n<h3 id=\"5-AMD-和-CommonJS-的区别\"><a href=\"#5-AMD-和-CommonJS-的区别\" class=\"headerlink\" title=\"5.AMD 和 CommonJS 的区别\"></a>5.AMD 和 CommonJS 的区别</h3><p>它们都是实现模块体系的方式，直到 <code>ES2015</code> 出现之前，<code>JavaScript</code> 一直没有模块体系。<code>CommonJS</code> 是同步的，而 <code>AMD（Asynchronous Module Definition）</code> 从全称中可以明显看出是异步的。<code>CommonJS</code> 的设计是为服务器端开发考虑的，而 <code>AMD</code> 支持异步加载模块，更适合浏览器。</p>\n<p>我发现 <code>AMD</code> 的语法非常冗长，<code>CommonJS</code> 更接近其他语言 <code>import</code> 声明语句的用法习惯。大多数情况下，我认为 <code>AMD</code> 没有使用的必要，因为如果把所有 <code>JavaScript</code> 都捆绑进一个文件中，将无法得到异步加载的好处。此外，<code>CommonJS</code> 语法上更接近 <code>Node</code> 编写模块的风格，在前后端都使用 <code>JavaScript</code> 开发之间进行切换时，语境的切换开销较小。</p>\n<p>我很高兴看到 <code>ES2015</code> 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和 <code>Node</code> 中完全推出，但是我们可以使用代码转换工具进行转换。</p>\n<h3 id=\"6-ES6模块与CommonJS模块有什么异同？\"><a href=\"#6-ES6模块与CommonJS模块有什么异同？\" class=\"headerlink\" title=\"6.ES6模块与CommonJS模块有什么异同？\"></a>6.<strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module 和 CommonJS 模块的区别：</p>\n<ul>\n<li>CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const；</li>\n<li>import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。</li>\n</ul>\n<p>ES6 Module 和 CommonJS 模块的共同点：</p>\n<ul>\n<li>CommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li>\n</ul>\n<h3 id=\"7-let、const、var-的区别\"><a href=\"#7-let、const、var-的区别\" class=\"headerlink\" title=\"7. let、const、var 的区别\"></a>7. let、const、var 的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：</p>\n<ul>\n<li>内层变量可能覆盖外层变量</li>\n<li>用来计数的循环变量泄露为全局变量</li>\n</ul>\n<p><strong>（2）变量提升：</strong> var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>\n<p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。</p>\n<p><strong>（4）重复声明：</strong> var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。</p>\n<p><strong>（5）暂时性死区：</strong> 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用 var 声明的变量不存在暂时性死区。</p>\n<p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。</p>\n<p><strong>（7）指针指向：</strong> let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。</p>\n<table>\n<thead>\n<tr>\n<th><strong>区别</strong></th>\n<th><strong>var</strong></th>\n<th><strong>let</strong></th>\n<th><strong>const</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否有块级作用域</td>\n<td>×</td>\n<td>✔️</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>是否存在变量提升</td>\n<td>✔️</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>是否添加全局属性</td>\n<td>✔️</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>能否重复声明变量</td>\n<td>✔️</td>\n<td>×</td>\n<td>×</td>\n</tr>\n<tr>\n<td>是否存在暂时性死区</td>\n<td>×</td>\n<td>✔️</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>是否必须设置初始值</td>\n<td>×</td>\n<td>×</td>\n<td>✔️</td>\n</tr>\n<tr>\n<td>能否改变指针指向</td>\n<td>✔️</td>\n<td>✔️</td>\n<td>×</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-new-操作符的实现原理\"><a href=\"#8-new-操作符的实现原理\" class=\"headerlink\" title=\"8.new 操作符的实现原理\"></a>8.new 操作符的实现原理</h3><p><strong>new 操作符的执行过程：</strong></p>\n<p>（1）首先创建了一个新的空对象</p>\n<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>\n<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>\n<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>\n<p>具体实现：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">objectFactory</span>(<span class=\"hljs-params\"></span>) &#123;   <span class=\"hljs-keyword\">let</span> newObject = <span class=\"hljs-literal\">null</span>;   <span class=\"hljs-keyword\">let</span> constructor = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">shift</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);   <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-literal\">null</span>;   <span class=\"hljs-comment\">// 判断参数是否是一个函数</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> constructor !== <span class=\"hljs-string\">&quot;function&quot;</span>) &#123;     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&quot;type error&quot;</span>);     <span class=\"hljs-keyword\">return</span>;   &#125;   <span class=\"hljs-comment\">// 新建一个空对象，对象的原型为构造函数的 prototype 对象   </span><br> newObject = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(constructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);   <span class=\"hljs-comment\">// 将 this 指向新建对象，并执行函数   </span><br> result = constructor.<span class=\"hljs-title function_\">apply</span>(newObject, <span class=\"hljs-variable language_\">arguments</span>);   <span class=\"hljs-comment\">// 判断返回对象   </span><br> <span class=\"hljs-keyword\">let</span> flag = result &amp;&amp; (<span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&quot;object&quot;</span> || <span class=\"hljs-keyword\">typeof</span> result === <span class=\"hljs-string\">&quot;function&quot;</span>);   <span class=\"hljs-comment\">// 判断返回结果   </span><br> <span class=\"hljs-keyword\">return</span> flag ? result : newObject;<br> &#125; <span class=\"hljs-comment\">// 使用方法</span><br> <span class=\"hljs-title function_\">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"9-数组有哪些原生方法？\"><a href=\"#9-数组有哪些原生方法？\" class=\"headerlink\" title=\"9.数组有哪些原生方法？\"></a>9.数组有哪些原生方法？</h3><p>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</p>\n<p>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</p>\n<p>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</p>\n<p>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</p>\n<p>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</p>\n<p>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</p>\n<p>数组归并方法 reduce() 和 reduceRight() 方法</p>\n<h3 id=\"10-for-in-和-for-of-的区别\"><a href=\"#10-for-in-和-for-of-的区别\" class=\"headerlink\" title=\"10.for in 和 for of 的区别\"></a>10.for in 和 for of 的区别</h3><p>for…of 是 ES6 新增的遍历方式，允许遍历一个含有 iterator 接口的数据结构（数组、对象等）并且返回各项的值，和 ES3 中的 for…in 的区别如下</p>\n<ul>\n<li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>\n<li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>\n<li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>\n</ul>\n<p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>\n<h3 id=\"11-数组的遍历方法有哪些？\"><a href=\"#11-数组的遍历方法有哪些？\" class=\"headerlink\" title=\"11.数组的遍历方法有哪些？\"></a>11.数组的遍历方法有哪些？</h3><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th><strong>是否改变原数组</strong></th>\n<th><strong>特点</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>forEach()</td>\n<td>否</td>\n<td>数组方法，值是基本类型, 改变不了;如果是引用类型分两种情况：1、没有修改形参元素的地址值, 只是修改形参元素内部的某些属性，会改变原数组；2、直接修改整个元素对象时，无法改变原数组，没有返回值</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>否</td>\n<td>数组方法，不改变原数组，有返回值，可链式调用</td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>否</td>\n<td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td>\n</tr>\n<tr>\n<td>for…of</td>\n<td>否</td>\n<td>for…of 遍历具有 Iterator 迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的 obj 对象，将异步循环变成同步循环</td>\n</tr>\n<tr>\n<td>every() 和 some()</td>\n<td>否</td>\n<td>数组方法，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false.</td>\n</tr>\n<tr>\n<td>find() 和 findIndex()</td>\n<td>否</td>\n<td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>\n</tr>\n<tr>\n<td>reduce() 和 reduceRight()</td>\n<td>否</td>\n<td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td>\n</tr>\n</tbody></table>\n<h3 id=\"12-forEach-和-map-的区别\"><a href=\"#12-forEach-和-map-的区别\" class=\"headerlink\" title=\"12.forEach 和 map 的区别\"></a>12.forEach 和 map 的区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p>\n<ul>\n<li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li>\n<li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>\n</ul>\n<h3 id=\"13-原型和原型链\"><a href=\"#13-原型和原型链\" class=\"headerlink\" title=\"13.原型和原型链\"></a>13.原型和原型链</h3><h4 id=\"1-对原型、原型链的理解\"><a href=\"#1-对原型、原型链的理解\" class=\"headerlink\" title=\"1. 对原型、原型链的理解\"></a>1. 对原型、原型链的理解</h4><p>在 JavaScript 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p>\n<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p>\n<p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>\n<h4 id=\"2-原型修改、重写\"><a href=\"#2-原型修改、重写\" class=\"headerlink\" title=\"2. 原型修改、重写\"></a>2. 原型修改、重写</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;     <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name &#125; <span class=\"hljs-comment\">// 修改原型</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>) <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === p.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-comment\">// 重写原型</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = &#123;     <span class=\"hljs-attr\">getName</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125; &#125; <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>) <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)        <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === p.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到修改原型的时候 p 的构造函数不是指向 Person 了，因为直接给 Person 的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数 Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用 constructor 指回来：</p>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = &#123;     <span class=\"hljs-attr\">getName</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125; &#125; <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>) p.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Person</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>)        <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(p.<span class=\"hljs-property\">__proto__</span> === p.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>) <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-原型链指向\"><a href=\"#3-原型链指向\" class=\"headerlink\" title=\"3. 原型链指向\"></a>3. 原型链指向</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">p.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Person.prototype</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Object.prototype</span><br>p.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">//Object.prototype</span><br>p.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Object.prototype</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// Object.prototype</span><br>p1.<span class=\"hljs-property\">__proto__</span>.<span class=\"hljs-property\">constructor</span> <span class=\"hljs-comment\">// Person</span><br><span class=\"hljs-title class_\">Person</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> <span class=\"hljs-comment\">// Person</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-原型链的终点是什么？如何打印出原型链的终点？\"><a href=\"#4-原型链的终点是什么？如何打印出原型链的终点？\" class=\"headerlink\" title=\"4. 原型链的终点是什么？如何打印出原型链的终点？\"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h4><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p>\n<h4 id=\"5-如何获得对象非原型链上的属性？\"><a href=\"#5-如何获得对象非原型链上的属性？\" class=\"headerlink\" title=\"5. 如何获得对象非原型链上的属性？\"></a>5. 如何获得对象非原型链上的属性？</h4><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p>\n<p>scss</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">iterate</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> res = []<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> key <span class=\"hljs-keyword\">in</span> obj) &#123;<br>    <span class=\"hljs-keyword\">if</span> (obj.<span class=\"hljs-title function_\">hasOwnProperty</span>(key)) res.<span class=\"hljs-title function_\">push</span>(key + <span class=\"hljs-string\">&#x27;: &#x27;</span> + obj[key])<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"14-对执行上下文-作用域-链-闭包的理解\"><a href=\"#14-对执行上下文-作用域-链-闭包的理解\" class=\"headerlink\" title=\"14. 对执行上下文,作用域(链),闭包的理解\"></a>14. 对执行上下文,作用域(链),闭包的理解</h3><h4 id=\"1-对闭包的理解\"><a href=\"#1-对闭包的理解\" class=\"headerlink\" title=\"1. 对闭包的理解\"></a>1. 对闭包的理解</h4><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>\n<p>闭包有两个常用的用途；</p>\n<ul>\n<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>\n<li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>\n</ul>\n<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">A</span>(<span class=\"hljs-params\"></span>) &#123;   <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">1</span>   <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">B</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;       <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a)   &#125; &#125; <span class=\"hljs-title function_\">A</span>() <span class=\"hljs-title function_\">B</span>() <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>\n<p>css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i)<br>  &#125;, i * <span class=\"hljs-number\">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>\n<ul>\n<li>第一种是使用闭包的方式</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  ;(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">j</span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(j)<br>    &#125;, j * <span class=\"hljs-number\">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>\n<ul>\n<li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li>\n</ul>\n<p>css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<br>    <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\">j</span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(j)<br>    &#125;,<br>    i * <span class=\"hljs-number\">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li>\n</ul>\n<p>css</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &lt;= <span class=\"hljs-number\">5</span>; i++) &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">timer</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(i)<br>  &#125;, i * <span class=\"hljs-number\">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-对作用域、作用域链的理解\"><a href=\"#2-对作用域、作用域链的理解\" class=\"headerlink\" title=\"2. 对作用域、作用域链的理解\"></a>2. 对作用域、作用域链的理解</h4><h5 id=\"1）全局作用域和函数作用域\"><a href=\"#1）全局作用域和函数作用域\" class=\"headerlink\" title=\"1）全局作用域和函数作用域\"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>\n<ul>\n<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>\n<li>所有未定义直接赋值的变量自动声明为全局作用域</li>\n<li>所有 window 对象的属性拥有全局作用域</li>\n<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>\n</ul>\n<p>（2）函数作用域</p>\n<ul>\n<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>\n<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>\n</ul>\n<h5 id=\"2）块级作用域\"><a href=\"#2）块级作用域\" class=\"headerlink\" title=\"2）块级作用域\"></a>2）块级作用域</h5><ul>\n<li>使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>\n<li>let 和 const 声明的变量不会有变量提升，也不可以重复声明</li>\n<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>\n</ul>\n<p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。</p>\n<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>\n<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>\n<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>\n<h4 id=\"3-对执行上下文的理解\"><a href=\"#3-对执行上下文的理解\" class=\"headerlink\" title=\"3. 对执行上下文的理解\"></a>3. 对执行上下文的理解</h4><h5 id=\"1-执行上下文类型\"><a href=\"#1-执行上下文类型\" class=\"headerlink\" title=\"1. 执行上下文类型\"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p>\n<p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的 window 对象，并且设置 this 的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p>\n<p><strong>（2）函数执行上下文</strong></p>\n<p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p>\n<p><strong>（3）</strong> <code>eval</code><strong>函数执行上下文</strong></p>\n<p>执行在 eval 函数中的代码会有属于他自己的执行上下文，不过 eval 函数不常使用，不做介绍。</p>\n<h5 id=\"2-执行上下文栈\"><a href=\"#2-执行上下文栈\" class=\"headerlink\" title=\"2. 执行上下文栈\"></a>2. 执行上下文栈</h5><ul>\n<li>JavaScript 引擎使用执行上下文栈来管理执行上下文</li>\n<li>当 JavaScript 执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>\n</ul>\n<p>sql</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-string\">&#x27;Hello World!&#x27;</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">first</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inside first function&#x27;</span>)<br>  <span class=\"hljs-title function_\">second</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Again inside first function&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">second</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Inside second function&#x27;</span>)<br>&#125;<br><span class=\"hljs-title function_\">first</span>() <span class=\"hljs-comment\">//执行顺序 //先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-创建执行上下文\"><a href=\"#3-创建执行上下文\" class=\"headerlink\" title=\"3. 创建执行上下文\"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p>\n<p><strong>1）创建阶段</strong></p>\n<p>（1）this 绑定</p>\n<ul>\n<li>在全局执行上下文中，this 指向全局对象（window 对象）</li>\n<li>在函数执行上下文中，this 指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>\n</ul>\n<p>（2）创建词法环境组件</p>\n<ul>\n<li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li>\n<li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>\n</ul>\n<p>（3）创建变量环境组件</p>\n<ul>\n<li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li>\n</ul>\n<p><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。</p>\n<p><strong>简单来说执行上下文就是指：</strong></p>\n<p>在执行一点 JS 代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p>\n<p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments 和函数的参数。</p>\n<ul>\n<li>全局上下文：变量定义，函数声明</li>\n<li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>\n</ul>\n<h3 id=\"15-实现-call、apply-及-bind-函数\"><a href=\"#15-实现-call、apply-及-bind-函数\" class=\"headerlink\" title=\"15. 实现 call、apply 及 bind 函数\"></a>15. 实现 call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p>\n<ul>\n<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>处理传入的参数，截取第一个参数后的所有参数。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性。</li>\n<li>返回结果。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myCall</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-comment\">// 判断调用对象</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;type error&#x27;</span>)<br>  &#125; <span class=\"hljs-comment\">// 获取参数</span><br>  <span class=\"hljs-keyword\">let</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>),<br>    result = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class=\"hljs-variable language_\">window</span> <span class=\"hljs-comment\">// 将调用函数设为对象的方法</span><br>  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-comment\">// 调用函数</span><br>  result = context.<span class=\"hljs-title function_\">fn</span>(...args) <span class=\"hljs-comment\">// 将属性删除</span><br>  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>（2）apply 函数的实现步骤：</strong></p>\n<ul>\n<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>\n<li>将函数作为上下文对象的一个属性。</li>\n<li>判断参数值是否传入</li>\n<li>使用上下文对象来调用这个方法，并保存返回结果。</li>\n<li>删除刚才新增的属性</li>\n<li>返回结果</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myApply</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-comment\">// 判断调用对象是否为函数</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-literal\">null</span> <span class=\"hljs-comment\">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class=\"hljs-variable language_\">window</span> <span class=\"hljs-comment\">// 将函数设为对象的方法</span><br>  context.<span class=\"hljs-property\">fn</span> = <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-comment\">// 调用方法</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>]) &#123;<br>    result = context.<span class=\"hljs-title function_\">fn</span>(...<span class=\"hljs-variable language_\">arguments</span>[<span class=\"hljs-number\">1</span>])<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    result = context.<span class=\"hljs-title function_\">fn</span>()<br>  &#125; <span class=\"hljs-comment\">// 将属性删除</span><br>  <span class=\"hljs-keyword\">delete</span> context.<span class=\"hljs-property\">fn</span><br>  <span class=\"hljs-keyword\">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>（3）bind 函数的实现步骤：</strong></p>\n<ul>\n<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>\n<li>保存当前函数的引用，获取其余传入参数值。</li>\n<li>创建一个函数返回</li>\n<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>\n</ul>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">myBind</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">context</span>) &#123;<br>  <span class=\"hljs-comment\">// 判断调用对象是否为函数</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-variable language_\">this</span> !== <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TypeError</span>(<span class=\"hljs-string\">&#x27;Error&#x27;</span>)<br>  &#125; <span class=\"hljs-comment\">// 获取参数</span><br>  <span class=\"hljs-keyword\">var</span> args = [...<span class=\"hljs-variable language_\">arguments</span>].<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>),<br>    fn = <span class=\"hljs-variable language_\">this</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Fn</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-comment\">// 根据调用方式，传入不同绑定值</span><br>    <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<br>      <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Fn</span> ? <span class=\"hljs-variable language_\">this</span> : context,<br>      args.<span class=\"hljs-title function_\">concat</span>(...<span class=\"hljs-variable language_\">arguments</span>)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"16-call、apply-函数的区别\"><a href=\"#16-call、apply-函数的区别\" class=\"headerlink\" title=\"16. call、apply 函数的区别\"></a>16. call、apply 函数的区别</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>\n<ul>\n<li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>\n<li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>\n</ul>\n<h3 id=\"17-异步编程的实现方式？\"><a href=\"#17-异步编程的实现方式？\" class=\"headerlink\" title=\"17. 异步编程的实现方式？\"></a>17. 异步编程的实现方式？</h3><p>markdown</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">JavaScript</span>中的异步机制可以分为以下几种：<br> -   **回调函数** 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。<br> -   **<span class=\"hljs-title class_\">Promise</span>** 的方式，使用 <span class=\"hljs-title class_\">Promise</span> 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。<br> -   **generator** 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。 -   **<span class=\"hljs-keyword\">async</span> 函数** 的方式，<span class=\"hljs-keyword\">async</span> 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 <span class=\"hljs-keyword\">await</span> 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"18-setTimeout、Promise、Async-x2F-Await-的区别\"><a href=\"#18-setTimeout、Promise、Async-x2F-Await-的区别\" class=\"headerlink\" title=\"18. setTimeout、Promise、Async&#x2F;Await 的区别\"></a>18. setTimeout、Promise、Async&#x2F;Await 的区别</h3><h4 id=\"（1）setTimeout\"><a href=\"#（1）setTimeout\" class=\"headerlink\" title=\"（1）setTimeout\"></a>（1）setTimeout</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script start&#x27;</span>) <span class=\"hljs-comment\">//1. 打印 script start</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>) <span class=\"hljs-comment\">// 4. 打印 settimeout</span><br>&#125;) <span class=\"hljs-comment\">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script end&#x27;</span>) <span class=\"hljs-comment\">//3. 打印 script start</span><br><span class=\"hljs-comment\">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（2）Promise\"><a href=\"#（2）Promise\" class=\"headerlink\" title=\"（2）Promise\"></a>（2）Promise</h4><p>Promise 本身是<strong>同步的立即执行函数</strong>， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then&#x2F;catch 等，当主栈完成后，才会去调用 resolve&#x2F;reject 中存放的方法执行，打印 p 的时候，是打印的返回结果，一个 Promise 实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-keyword\">let</span> promise1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1&#x27;</span>)<br>  <span class=\"hljs-title function_\">resolve</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br><span class=\"hljs-comment\">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure>\n\n<p>当 JS 主线程执行到 Promise 对象时：</p>\n<ul>\n<li>promise1.then() 的回调就是一个 task</li>\n<li>promise1 是 resolved 或 rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>\n<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>\n<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>\n</ul>\n<h4 id=\"（3）async-x2F-await\"><a href=\"#（3）async-x2F-await\" class=\"headerlink\" title=\"（3）async&#x2F;await\"></a>（3）async&#x2F;await</h4><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">async1</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;async1 start&#x27;</span>)<br>  <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">async2</span>()<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">async2</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;async2&#x27;</span>)<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script start&#x27;</span>)<br><span class=\"hljs-title function_\">async1</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;script end&#x27;</span>)<br><span class=\"hljs-comment\">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure>\n\n<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>\n<p>例如：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">func1</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span><br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">func1</span>())<br></code></pre></td></tr></table></figure>\n\n<p>func1 的运行结果其实就是一个 Promise 对象。因此也可以使用 then 来处理后续逻辑。</p>\n<p>scss</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">func1</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(res) <span class=\"hljs-comment\">// 30</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>await 的含义为等待，也就是 async 函数需要等待 await 后的函数执行完成并且有了返回结果（Promise 对象）之后，才能继续执行下面的代码。await 通过返回一个 Promise 对象来实现同步的效果。</p>\n<h3 id=\"19-Promise-all-和-Promise-race-的区别的使用场景\"><a href=\"#19-Promise-all-和-Promise-race-的区别的使用场景\" class=\"headerlink\" title=\"19. Promise.all 和 Promise.race 的区别的使用场景\"></a>19. Promise.all 和 Promise.race 的区别的使用场景</h3><p><strong>（1）Promise.all</strong> <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被 reject 失败状态的值</strong>。</p>\n<p>Promise.all 中传入的是数组，返回的也是是数组，并且会将进行映射，传入的 promise 对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>\n<p>需要注意，Promise.all 获得的成功结果的数组里面的数据顺序和 Promise.all 接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用 Promise.all 来解决。</p>\n<p><strong>（2）Promise.race</strong></p>\n<p>顾名思义，Promse.race 就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>\n<p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([promise1, <span class=\"hljs-title function_\">timeOutPromise</span>(<span class=\"hljs-number\">5000</span>)]).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">res</span>) =&gt;</span> &#123;&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"20-对-async-x2F-await-的理解\"><a href=\"#20-对-async-x2F-await-的理解\" class=\"headerlink\" title=\"20. 对 async&#x2F;await 的理解\"></a>20. 对 async&#x2F;await 的理解</h3><p>async&#x2F;await 其实是<code>Generator</code> 的语法糖，它能实现的效果都能用 then 链来实现，它是为优化 then 链而开发出来的。从字面上来看，async 是“异步”的简写，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定 await 只能出现在 asnyc 函数中，先来看看 async 函数返回了什么：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testAsy</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span><br>&#125;<br><span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title function_\">testAsy</span>()<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result)<br></code></pre></td></tr></table></figure>\n\n<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>\n<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testAsy</span>(<span class=\"hljs-params\"></span>)&#123;    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;hello world&#x27;</span> &#125; <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-title function_\">testAsy</span>()  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(result) result.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span>=&gt;</span>&#123;     <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v)  <br><span class=\"hljs-comment\">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>\n<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<p><strong>注意：</strong> <code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>\n<h3 id=\"21-浏览器的垃圾回收机制\"><a href=\"#21-浏览器的垃圾回收机制\" class=\"headerlink\" title=\"21. 浏览器的垃圾回收机制\"></a>21. 浏览器的垃圾回收机制</h3><p>markdown</p>\n<p><code>#### （1）垃圾回收的概念 **垃圾回收**：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。 **回收机制**： -   Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。 -   JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。 -   不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。 #### （2）垃圾回收的方式 浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 **1）标记清除** -   标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。 -   垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。 **2）引用计数** -   另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。 -   这种方法会引起**循环引用**的问题：例如：`obj1`和`obj2`通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，`obj1`和`obj2`还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。 ``` function fun() &#123;     let obj1 = &#123;&#125;;     let obj2 = &#123;&#125;;     obj1.a = obj2; // obj1 引用 obj2     obj2.a = obj1; // obj2 引用 obj1 &#125; ``` 这种情况下，就要手动释放变量占用的内存： ``` obj1.a =  null  obj2.a =  null ``` #### （3）减少垃圾回收 虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。 -   **对数组进行优化：** 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。 -   **对**`object`**进行优化：** 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。 -   **对函数进行优化：** 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</code></p>\n<h3 id=\"22-哪些情况会导致内存泄漏\"><a href=\"#22-哪些情况会导致内存泄漏\" class=\"headerlink\" title=\"22. 哪些情况会导致内存泄漏\"></a>22. 哪些情况会导致内存泄漏</h3><p>markdown</p>\n<p><code>以下四种情况会造成内存的泄漏： -   **意外的全局变量：** 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。 -   **被遗忘的计时器或回调函数：** 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。 -   **脱离 DOM 的引用：** 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。 -   **闭包：** 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</code></p>\n<h3 id=\"23-ES6-有哪些新特性\"><a href=\"#23-ES6-有哪些新特性\" class=\"headerlink\" title=\"23. ES6 有哪些新特性\"></a>23. ES6 有哪些新特性</h3><p>1.箭头函数</p>\n<p>2.解构赋值</p>\n<p>3.模板字符串</p>\n<p>4.promise</p>\n<p>5.symbol Symbol 是 ES6 中引入的一种新的基本数据类型,用于表示一个独一无二的值,不能与其他数据类型进行运算</p>\n<p>6.新的变量声明方式-let 和 const</p>\n<p>7.模块化-es6 新增了模块化，根据功能封装模块，通过 import 导入，然后通过 export 导出也可以使用 export default 导出</p>\n<p>8.for…of 循环,用于遍历可迭代对象(如数组、Map 和 Set)中的元素</p>\n<p>9.扩展运算符:使用 … 可以将数组或对象展开成多个参数,或者将多个参数合并成一个数组</p>\n<p>10.展开运算符:在 ES6 中用…来表示展开运算符,它可以将数组或者对象进行展开</p>\n<p>11.Map 和 Set，引入了两种新的数据结构，分别用于存储键值对和唯一值</p>\n<p>12.Proxy，允许在对象和函数调用等操作前后添加自定义的行为</p>\n<p>13.类（Class），引入了面向对象编程中类的概念</p>\n<p>14.默认参数（Default Parameter），在定义函数时可以给参数设置默认值</p>\n<h3 id=\"24-匿名函数的典型应用场景是什么？\"><a href=\"#24-匿名函数的典型应用场景是什么？\" class=\"headerlink\" title=\"24. 匿名函数的典型应用场景是什么？\"></a>24. 匿名函数的典型应用场景是什么？</h3><p>匿名函数可以在 IIFE 中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;   <span class=\"hljs-comment\">// 一些代码。 &#125;)();</span><br></code></pre></td></tr></table></figure>\n\n<p>匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;Hello world!&#x27;</span>)<br>&#125;, <span class=\"hljs-number\">1000</span>)<br></code></pre></td></tr></table></figure>\n\n<p>匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。</p>\n<p>c</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]<br><span class=\"hljs-keyword\">const</span> double = arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> el * <span class=\"hljs-number\">2</span><br>&#125;)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(double) <span class=\"hljs-comment\">// [2, 4, 6]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"25-你能举出一个柯里化函数（curry-function）的例子吗？它有哪些好处？\"><a href=\"#25-你能举出一个柯里化函数（curry-function）的例子吗？它有哪些好处？\" class=\"headerlink\" title=\"25.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？\"></a>25.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？</h3><p>柯里化（currying）是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。值得注意的是，对于需要被 curry 的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。</p>\n<p>scss</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">fn</span>) &#123;   <span class=\"hljs-keyword\">if</span> (fn.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) &#123;     <span class=\"hljs-keyword\">return</span> fn;   &#125; ​   <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">_curried</span>(<span class=\"hljs-params\">depth, args</span>) &#123;     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newArgument</span>) &#123;       <span class=\"hljs-keyword\">if</span> (depth - <span class=\"hljs-number\">1</span> === <span class=\"hljs-number\">0</span>) &#123;         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(...args, newArgument);       &#125;       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_curried</span>(depth - <span class=\"hljs-number\">1</span>, [...args, newArgument]);     &#125;;   &#125; ​   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_curried</span>(fn.<span class=\"hljs-property\">length</span>, []); &#125; ​ <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;   <span class=\"hljs-keyword\">return</span> a + b; &#125; ​ <span class=\"hljs-keyword\">var</span> curriedAdd = <span class=\"hljs-title function_\">curry</span>(add); <span class=\"hljs-keyword\">var</span> addFive = <span class=\"hljs-title function_\">curriedAdd</span>(<span class=\"hljs-number\">5</span>); ​ <span class=\"hljs-keyword\">var</span> result = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>].<span class=\"hljs-title function_\">map</span>(addFive); <span class=\"hljs-comment\">// [5, 6, 7, 8, 9, 10]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"26-什么是事件循环？调用堆栈和任务队列之间有什么区别？\"><a href=\"#26-什么是事件循环？调用堆栈和任务队列之间有什么区别？\" class=\"headerlink\" title=\"26.什么是事件循环？调用堆栈和任务队列之间有什么区别？\"></a>26.什么是事件循环？调用堆栈和任务队列之间有什么区别？</h3><p>事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。</p>\n<h3 id=\"27-js-设计模式有哪些？\"><a href=\"#27-js-设计模式有哪些？\" class=\"headerlink\" title=\"27.js 设计模式有哪些？\"></a>27.js 设计模式有哪些？</h3><p>总体来说设计模式分为三大类：(<code>C5S7B11</code>)</p>\n<ol>\n<li><strong>创建型模式</strong>，共五种：<strong>工厂方法模式</strong>、抽象工厂模式、<strong>单例模式</strong>、建造者模式、<strong>原型模式</strong>。</li>\n<li><strong>结构型模式</strong>，共七种：<strong>适配器模式</strong>、<strong>装饰器模式</strong>、<strong>代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。</li>\n<li><strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、<strong>观察者模式&#x2F;发布订阅模式</strong>、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li>\n</ol>\n<h2 id=\"手写单例模式（创建模式）\"><a href=\"#手写单例模式（创建模式）\" class=\"headerlink\" title=\"手写单例模式（创建模式）\"></a>手写单例模式（创建模式）</h2><p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">CreateSingleton</span> = (<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> instance<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">name</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (instance) &#123;<br>      <span class=\"hljs-keyword\">return</span> instance<br>    &#125;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>    <span class=\"hljs-keyword\">return</span> (instance = <span class=\"hljs-variable language_\">this</span>)<br>  &#125;<br>&#125;)()<br><span class=\"hljs-title class_\">CreateSingleton</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">getName</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>代码测试</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Winner</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CreateSingleton</span>(<span class=\"hljs-string\">&#x27;Winner&#x27;</span>); <span class=\"hljs-keyword\">let</span> <span class=\"hljs-title class_\">Looser</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CreateSingleton</span>(<span class=\"hljs-string\">&#x27;Looser&#x27;</span>); ​ <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Winner</span> === <span class=\"hljs-title class_\">Looser</span>); <span class=\"hljs-comment\">// true</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Winner</span>.<span class=\"hljs-title function_\">getName</span>());  <span class=\"hljs-comment\">// &#x27;Winner&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Looser</span>.<span class=\"hljs-title function_\">getName</span>());  <span class=\"hljs-comment\">// &#x27;Winner&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"手写观察者模式（行为模式）\"><a href=\"#手写观察者模式（行为模式）\" class=\"headerlink\" title=\"手写观察者模式（行为模式）\"></a>手写观察者模式（行为模式）</h2><p>ini</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义observe</span><br><span class=\"hljs-keyword\">const</span> queuedObservers = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">observe</span> = fn =&gt; queuedObservers.<span class=\"hljs-title function_\">add</span>(fn); ​ ​<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">observable</span> = obj =&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Proxy</span>(obj, &#123;   <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">target, key, value, receiver</span>) &#123;     <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title class_\">Reflect</span>.<span class=\"hljs-title function_\">set</span>(target, key, value, receiver);     <span class=\"hljs-comment\">// notify     </span><br>queuedObservers.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =&gt;</span> <span class=\"hljs-title function_\">observer</span>());     <span class=\"hljs-keyword\">return</span> result;   &#125; &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>代码测试</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">obj = <span class=\"hljs-title function_\">observable</span>(&#123;   <span class=\"hljs-attr\">name</span>:<span class=\"hljs-string\">&#x27;789&#x27;</span> &#125;) ​ <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\"></span>)&#123;   <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;触发了&#x27;</span>) &#125;) ​ obj.<span class=\"hljs-property\">name</span> =<span class=\"hljs-string\">&quot;前端柒八九&quot;</span> <span class=\"hljs-comment\">// 触发了 // 前端柒八九</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"手写发布订阅-（行为模式）\"><a href=\"#手写发布订阅-（行为模式）\" class=\"headerlink\" title=\"手写发布订阅 （行为模式）\"></a>手写发布订阅 （行为模式）</h2><p>kotlin</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Observer</span> &#123;   caches = &#123;&#125;; <span class=\"hljs-comment\">// 事件中心      // eventName事件名-独一无二, fn订阅后执行的自定义行为   </span><br>on (eventName, fn)&#123;      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName] = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName] || [];     <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName].<span class=\"hljs-title function_\">push</span>(fn);   &#125;      <span class=\"hljs-comment\">// 发布 =&gt; 将订阅的事件进行统一执行   </span><br>emit (eventName, data) &#123;      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName]) &#123;       <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName]       .<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">fn</span> =&gt;</span> <span class=\"hljs-title function_\">fn</span>(data));     &#125;   &#125;   <span class=\"hljs-comment\">// 取消订阅 =&gt; 若fn不传, 直接取消该事件所有订阅信息   </span><br>off (eventName, fn) &#123;      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName]) &#123;       <span class=\"hljs-keyword\">const</span> newCaches = fn          ? <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName].<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> e !== fn)          : [];       <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">caches</span>[eventName] = newCaches;     &#125;   &#125; ​ &#125;<br></code></pre></td></tr></table></figure>\n\n<p>代码测试</p>\n<p>javascript</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ob = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>(); ​ l1 = <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`l1_<span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>) l2 = <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`l2_<span class=\"hljs-subst\">$&#123;data&#125;</span>`</span>) ​ ob.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,l1) ob.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,l2) ​ <span class=\"hljs-comment\">//发布订阅</span><br>ob.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,<span class=\"hljs-number\">789</span>)  <span class=\"hljs-comment\">// l1_789 // l2_789 ​</span><br><span class=\"hljs-comment\">// 取消，订阅l1</span><br>ob.<span class=\"hljs-title function_\">off</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,l1) ​ ob.<span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-string\">&#x27;event1&#x27;</span>,<span class=\"hljs-number\">567</span>) <span class=\"hljs-comment\">//l2_567</span><br><span class=\"hljs-string\">``</span><span class=\"hljs-string\">`</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">## 观察者模式 VS 发布订阅模式</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c708723f8b984c1c9ceaf24d674306b3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1014&amp;h=804&amp;s=19910&amp;e=webp&amp;b=fdf8f4)</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">1. 从表面上看：</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    - 观察者模式里，只有两个角色 —— **观察者** + **被观察者**</span><br><span class=\"hljs-string\">    - 而发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个经常被我们忽略的 —— &#123;经纪人|Broker&#125;</span><br><span class=\"hljs-string\">2. 往更深层次讲：</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    - 观察者和被观察者，是`</span>松耦合<span class=\"hljs-string\">`的关系</span><br><span class=\"hljs-string\">    - 发布者和订阅者，则完全不存在耦合</span><br><span class=\"hljs-string\">3. 从使用层面上讲：</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    - 观察者模式，多用于**单个应用内部**</span><br><span class=\"hljs-string\">    - 发布订阅模式，则更多的是一种&#123;跨应用的模式|cross-application pattern&#125; ，比如我们常用的消息中间件</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">转至 [面试](https://juejin.cn/user/835284567342782/posts)</span><br></code></pre></td></tr></table></figure>\n"},{"title":"前端模块化：CommonJS,AMD,CMD,ES6","date":"2024-07-24T06:44:41.000Z","_content":"\n# 前端模块化：CommonJS,AMD,CMD,ES6\n\n模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 [module-loader](https://link.juejin.cn/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fmodule-loader 'http://es6.ruanyifeng.com/#docs/module-loader') 。\n\n## 一、CommonJS\n\nNode.js 是 commonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module`、`exports`、`require`、`global`。实际使用时，用`module.exports`定义当前模块对外输出的接口（不推荐直接用`exports`），用`require`加载模块。\n\n代码解读\n\n复制代码\n\n```javascript\n// 定义模块math.js\nvar basicNum = 0;\nfunction add(a, b) {   return a + b; }\nmodule.exports = { //在这里写上需要向外暴露的函数、变量\nadd: add,   basicNum: basicNum\n} // 引用自定义的模块时，参数包含路径，可省略.js\nvar math = require('./math'); math.add(2, 5); // 引用核心模块时，不需要带路径\nvar http = require('http'); http.createService(...).listen(3000);\n```\n\ncommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n## 二、AMD 和 require.js\n\nAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用 require.js 实现 AMD 规范的模块化：用`require.config()`指定引用路径等，用`define()`定义模块，用`require()`加载模块。\n\n首先我们需要引入 require.js 文件和一个入口文件 main.js。main.js 中配置`require.config()`并规定项目中用到的基础模块。\n\n代码解读\n\n复制代码\n\n```javascript\n/** 网页中引入require.js及main.js **/\n;<script\n  src=\"js/require.js\"\n  data-main=\"js/main\"\n></script> /** main.js 入口文件/主模块 **/\n// 首先用config()指定各模块路径和引用名\nrequire.config({\n  baseUrl: 'js/lib',\n  paths: {\n    jquery: 'jquery.min', //实际路径为js/lib/jquery.min.js\n    underscore: 'underscore.min',\n  },\n}) // 执行基本操作\nrequire(['jquery', 'underscore'], function ($, _) {\n  // some code here\n})\n```\n\n引用模块的时候，我们将模块名放在`[]`中作为`reqiure()`的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在`[]`中作为`define()`的第一参数。\n\n代码解读\n\n复制代码\n\n```javascript\n// 定义math.js模块\ndefine(function () {\n  var basicNum = 0\n  var add = function (x, y) {\n    return x + y\n  }\n  return { add: add, basicNum: basicNum }\n}) // 定义一个依赖underscore.js的模块\ndefine(['underscore'], function (_) {\n  var classify = function (list) {\n    _.countBy(list, function (num) {\n      return num > 30 ? 'old' : 'young'\n    })\n  }\n  return { classify: classify }\n}) // 引用模块，将模块放在[]内\nrequire(['jquery', 'math'], function ($, math) {\n  var sum = math.add(10, 20)\n  $('#sum').html(sum)\n})\n```\n\n## 三、CMD 和 sea.js\n\nrequire.js 在申明依赖的模块时会在第一之间加载并执行模块内的代码：\n\n代码解读\n\n复制代码\n\n```javascript\ndefine(['a', 'b', 'c', 'd', 'e', 'f'], function (a, b, c, d, e, f) {\n  // 等于在最前面声明并初始化了要用到的所有模块\n  if (false) {\n    // 即便没用到某个模块 b，但 b 还是提前执行了\n    b.foo()\n  }\n})\n```\n\nCMD 是另一种 js 模块化方案，它与 AMD 很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。此规范其实是在 sea.js 推广过程中产生的。\n\n代码解读\n\n复制代码\n\n```javascript\n/** AMD写法 **/\ndefine([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) {       // 等于在最前面声明并初始化了要用到的所有模块\na.doSomething();     if (false) {         // 即便没用到某个模块 b，但 b 还是提前执行了\nb.doSomething()     }  }); /** CMD写法 **/\ndefine(function(require, exports, module) {     var a = require('./a'); //在需要时申明\na.doSomething();     if (false) {         var b = require('./b');         b.doSomething();     } });\n/** sea.js **/\n// 定义模块 math.js\ndefine(function(require, exports, module) {     var $ = require('jquery.js');     var add = function(a,b){         return a+b;     }     exports.add = add; }); // 加载模块\nseajs.use(['math.js'], function(math){     var sum = math.add(1+2); });\n```\n\n## 四、ES6 Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。\n\n代码解读\n\n复制代码\n\n```javascript\n/** 定义模块 math.js **/ var basicNum = 0\nvar add = function (a, b) {\n  return a + b\n}\nexport { basicNum, add }\n/** 引用模块 **/ import { basicNum, add } from './math'\nfunction test(ele) {\n  ele.textContent = add(99 + basicNum)\n}\n```\n\n如上例所示，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了`export default`命令，为模块指定默认输出，对应的`import`语句不需要使用大括号。这也更趋近于 ADM 的引用写法。\n\n代码解读\n\n复制代码\n\n```javascript\n/** export default **/ //定义输出\nexport default { basicNum, add } //引入 import math from './math';\nfunction test(ele) {\n  ele.textContent = math.add(99 + math.basicNum)\n}\n```\n\nES6 的模块不是对象，`import`命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n## 五、 ES6 模块与 CommonJS 模块的差异\n\n### 1\\. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n### 2\\. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n- 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。\n\nCommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n[subwaydown](https://juejin.cn/user/4388906146731486/posts)\n","source":"_posts/jsModel.md","raw":"---\ntitle: 前端模块化：CommonJS,AMD,CMD,ES6\ndate: 2024-07-24 14:44:41\ntags: js\n---\n\n# 前端模块化：CommonJS,AMD,CMD,ES6\n\n模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 [module-loader](https://link.juejin.cn/?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fmodule-loader 'http://es6.ruanyifeng.com/#docs/module-loader') 。\n\n## 一、CommonJS\n\nNode.js 是 commonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：`module`、`exports`、`require`、`global`。实际使用时，用`module.exports`定义当前模块对外输出的接口（不推荐直接用`exports`），用`require`加载模块。\n\n代码解读\n\n复制代码\n\n```javascript\n// 定义模块math.js\nvar basicNum = 0;\nfunction add(a, b) {   return a + b; }\nmodule.exports = { //在这里写上需要向外暴露的函数、变量\nadd: add,   basicNum: basicNum\n} // 引用自定义的模块时，参数包含路径，可省略.js\nvar math = require('./math'); math.add(2, 5); // 引用核心模块时，不需要带路径\nvar http = require('http'); http.createService(...).listen(3000);\n```\n\ncommonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。\n\n## 二、AMD 和 require.js\n\nAMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用 require.js 实现 AMD 规范的模块化：用`require.config()`指定引用路径等，用`define()`定义模块，用`require()`加载模块。\n\n首先我们需要引入 require.js 文件和一个入口文件 main.js。main.js 中配置`require.config()`并规定项目中用到的基础模块。\n\n代码解读\n\n复制代码\n\n```javascript\n/** 网页中引入require.js及main.js **/\n;<script\n  src=\"js/require.js\"\n  data-main=\"js/main\"\n></script> /** main.js 入口文件/主模块 **/\n// 首先用config()指定各模块路径和引用名\nrequire.config({\n  baseUrl: 'js/lib',\n  paths: {\n    jquery: 'jquery.min', //实际路径为js/lib/jquery.min.js\n    underscore: 'underscore.min',\n  },\n}) // 执行基本操作\nrequire(['jquery', 'underscore'], function ($, _) {\n  // some code here\n})\n```\n\n引用模块的时候，我们将模块名放在`[]`中作为`reqiure()`的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在`[]`中作为`define()`的第一参数。\n\n代码解读\n\n复制代码\n\n```javascript\n// 定义math.js模块\ndefine(function () {\n  var basicNum = 0\n  var add = function (x, y) {\n    return x + y\n  }\n  return { add: add, basicNum: basicNum }\n}) // 定义一个依赖underscore.js的模块\ndefine(['underscore'], function (_) {\n  var classify = function (list) {\n    _.countBy(list, function (num) {\n      return num > 30 ? 'old' : 'young'\n    })\n  }\n  return { classify: classify }\n}) // 引用模块，将模块放在[]内\nrequire(['jquery', 'math'], function ($, math) {\n  var sum = math.add(10, 20)\n  $('#sum').html(sum)\n})\n```\n\n## 三、CMD 和 sea.js\n\nrequire.js 在申明依赖的模块时会在第一之间加载并执行模块内的代码：\n\n代码解读\n\n复制代码\n\n```javascript\ndefine(['a', 'b', 'c', 'd', 'e', 'f'], function (a, b, c, d, e, f) {\n  // 等于在最前面声明并初始化了要用到的所有模块\n  if (false) {\n    // 即便没用到某个模块 b，但 b 还是提前执行了\n    b.foo()\n  }\n})\n```\n\nCMD 是另一种 js 模块化方案，它与 AMD 很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。此规范其实是在 sea.js 推广过程中产生的。\n\n代码解读\n\n复制代码\n\n```javascript\n/** AMD写法 **/\ndefine([\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], function(a, b, c, d, e, f) {       // 等于在最前面声明并初始化了要用到的所有模块\na.doSomething();     if (false) {         // 即便没用到某个模块 b，但 b 还是提前执行了\nb.doSomething()     }  }); /** CMD写法 **/\ndefine(function(require, exports, module) {     var a = require('./a'); //在需要时申明\na.doSomething();     if (false) {         var b = require('./b');         b.doSomething();     } });\n/** sea.js **/\n// 定义模块 math.js\ndefine(function(require, exports, module) {     var $ = require('jquery.js');     var add = function(a,b){         return a+b;     }     exports.add = add; }); // 加载模块\nseajs.use(['math.js'], function(math){     var sum = math.add(1+2); });\n```\n\n## 四、ES6 Module\n\nES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：`export`和`import`。`export`命令用于规定模块的对外接口，`import`命令用于输入其他模块提供的功能。\n\n代码解读\n\n复制代码\n\n```javascript\n/** 定义模块 math.js **/ var basicNum = 0\nvar add = function (a, b) {\n  return a + b\n}\nexport { basicNum, add }\n/** 引用模块 **/ import { basicNum, add } from './math'\nfunction test(ele) {\n  ele.textContent = add(99 + basicNum)\n}\n```\n\n如上例所示，使用`import`命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了`export default`命令，为模块指定默认输出，对应的`import`语句不需要使用大括号。这也更趋近于 ADM 的引用写法。\n\n代码解读\n\n复制代码\n\n```javascript\n/** export default **/ //定义输出\nexport default { basicNum, add } //引入 import math from './math';\nfunction test(ele) {\n  ele.textContent = math.add(99 + math.basicNum)\n}\n```\n\nES6 的模块不是对象，`import`命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\n\n## 五、 ES6 模块与 CommonJS 模块的差异\n\n### 1\\. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\n\n- CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。\n\n### 2\\. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\n\n- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。\n- 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。\n\nCommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。\n\n[subwaydown](https://juejin.cn/user/4388906146731486/posts)\n","slug":"jsModel","published":1,"updated":"2024-07-24T06:50:37.669Z","_id":"clyzhc59b000jlyxxf3a4gvoj","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前端模块化：CommonJS-AMD-CMD-ES6\"><a href=\"#前端模块化：CommonJS-AMD-CMD-ES6\" class=\"headerlink\" title=\"前端模块化：CommonJS,AMD,CMD,ES6\"></a>前端模块化：CommonJS,AMD,CMD,ES6</h1><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 <a href=\"https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/module-loader\" title=\"http://es6.ruanyifeng.com/#docs/module-loader\">module-loader</a> 。</p>\n<h2 id=\"一、CommonJS\"><a href=\"#一、CommonJS\" class=\"headerlink\" title=\"一、CommonJS\"></a>一、CommonJS</h2><p>Node.js 是 commonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义模块math.js</span><br><span class=\"hljs-keyword\">var</span> basicNum = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;   <span class=\"hljs-keyword\">return</span> a + b; &#125;<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123; <span class=\"hljs-comment\">//在这里写上需要向外暴露的函数、变量</span><br><span class=\"hljs-attr\">add</span>: add,   <span class=\"hljs-attr\">basicNum</span>: basicNum<br>&#125; <span class=\"hljs-comment\">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class=\"hljs-keyword\">var</span> math = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./math&#x27;</span>); math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 引用核心模块时，不需要带路径</span><br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>); http.<span class=\"hljs-title function_\">createService</span>(...).<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);<br></code></pre></td></tr></table></figure>\n\n<p>commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2 id=\"二、AMD-和-require-js\"><a href=\"#二、AMD-和-require-js\" class=\"headerlink\" title=\"二、AMD 和 require.js\"></a>二、AMD 和 require.js</h2><p>AMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用 require.js 实现 AMD 规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p>\n<p>首先我们需要引入 require.js 文件和一个入口文件 main.js。main.js 中配置<code>require.config()</code>并规定项目中用到的基础模块。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** 网页中引入require.js及main.js **/</span><br>;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;js/require.js&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">  <span class=\"hljs-attr\">data-main</span>=<span class=\"hljs-string\">&quot;js/main&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span> <span class=\"hljs-comment\">/** main.js 入口文件/主模块 **/</span><br><span class=\"hljs-comment\">// 首先用config()指定各模块路径和引用名</span><br><span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">config</span>(&#123;<br>  <span class=\"hljs-attr\">baseUrl</span>: <span class=\"hljs-string\">&#x27;js/lib&#x27;</span>,<br>  <span class=\"hljs-attr\">paths</span>: &#123;<br>    <span class=\"hljs-attr\">jquery</span>: <span class=\"hljs-string\">&#x27;jquery.min&#x27;</span>, <span class=\"hljs-comment\">//实际路径为js/lib/jquery.min.js</span><br>    <span class=\"hljs-attr\">underscore</span>: <span class=\"hljs-string\">&#x27;underscore.min&#x27;</span>,<br>  &#125;,<br>&#125;) <span class=\"hljs-comment\">// 执行基本操作</span><br><span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;jquery&#x27;</span>, <span class=\"hljs-string\">&#x27;underscore&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$, _</span>) &#123;<br>  <span class=\"hljs-comment\">// some code here</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义math.js模块</span><br><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> basicNum = <span class=\"hljs-number\">0</span><br>  <span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> x + y<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">add</span>: add, <span class=\"hljs-attr\">basicNum</span>: basicNum &#125;<br>&#125;) <span class=\"hljs-comment\">// 定义一个依赖underscore.js的模块</span><br><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&#x27;underscore&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">_</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> classify = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">list</span>) &#123;<br>    _.<span class=\"hljs-title function_\">countBy</span>(list, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">num</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> num &gt; <span class=\"hljs-number\">30</span> ? <span class=\"hljs-string\">&#x27;old&#x27;</span> : <span class=\"hljs-string\">&#x27;young&#x27;</span><br>    &#125;)<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">classify</span>: classify &#125;<br>&#125;) <span class=\"hljs-comment\">// 引用模块，将模块放在[]内</span><br><span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;jquery&#x27;</span>, <span class=\"hljs-string\">&#x27;math&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$, math</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> sum = math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>)<br>  $(<span class=\"hljs-string\">&#x27;#sum&#x27;</span>).<span class=\"hljs-title function_\">html</span>(sum)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、CMD-和-sea-js\"><a href=\"#三、CMD-和-sea-js\" class=\"headerlink\" title=\"三、CMD 和 sea.js\"></a>三、CMD 和 sea.js</h2><p>require.js 在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b, c, d, e, f</span>) &#123;<br>  <span class=\"hljs-comment\">// 等于在最前面声明并初始化了要用到的所有模块</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) &#123;<br>    <span class=\"hljs-comment\">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>    b.<span class=\"hljs-title function_\">foo</span>()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>CMD 是另一种 js 模块化方案，它与 AMD 很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。此规范其实是在 sea.js 推广过程中产生的。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** AMD写法 **/</span><br><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>], <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b, c, d, e, f</span>) &#123;       <span class=\"hljs-comment\">// 等于在最前面声明并初始化了要用到的所有模块</span><br>a.<span class=\"hljs-title function_\">doSomething</span>();     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) &#123;         <span class=\"hljs-comment\">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>b.<span class=\"hljs-title function_\">doSomething</span>()     &#125;  &#125;); <span class=\"hljs-comment\">/** CMD写法 **/</span><br><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-variable language_\">module</span></span>) &#123;     <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a&#x27;</span>); <span class=\"hljs-comment\">//在需要时申明</span><br>a.<span class=\"hljs-title function_\">doSomething</span>();     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) &#123;         <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./b&#x27;</span>);         b.<span class=\"hljs-title function_\">doSomething</span>();     &#125; &#125;);<br><span class=\"hljs-comment\">/** sea.js **/</span><br><span class=\"hljs-comment\">// 定义模块 math.js</span><br><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-variable language_\">module</span></span>) &#123;     <span class=\"hljs-keyword\">var</span> $ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;jquery.js&#x27;</span>);     <span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a,b</span>)&#123;         <span class=\"hljs-keyword\">return</span> a+b;     &#125;     <span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">add</span> = add; &#125;); <span class=\"hljs-comment\">// 加载模块</span><br>seajs.<span class=\"hljs-title function_\">use</span>([<span class=\"hljs-string\">&#x27;math.js&#x27;</span>], <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">math</span>)&#123;     <span class=\"hljs-keyword\">var</span> sum = math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span>); &#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、ES6-Module\"><a href=\"#四、ES6-Module\" class=\"headerlink\" title=\"四、ES6 Module\"></a>四、ES6 Module</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** 定义模块 math.js **/</span> <span class=\"hljs-keyword\">var</span> basicNum = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b<br>&#125;<br><span class=\"hljs-keyword\">export</span> &#123; basicNum, add &#125;<br><span class=\"hljs-comment\">/** 引用模块 **/</span> <span class=\"hljs-keyword\">import</span> &#123; basicNum, add &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./math&#x27;</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">ele</span>) &#123;<br>  ele.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">99</span> + basicNum)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了<code>export default</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于 ADM 的引用写法。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** export default **/</span> <span class=\"hljs-comment\">//定义输出</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123; basicNum, add &#125; <span class=\"hljs-comment\">//引入 import math from &#x27;./math&#x27;;</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">ele</span>) &#123;<br>  ele.<span class=\"hljs-property\">textContent</span> = math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">99</span> + math.<span class=\"hljs-property\">basicNum</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>ES6 的模块不是对象，<code>import</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>\n<h2 id=\"五、-ES6-模块与-CommonJS-模块的差异\"><a href=\"#五、-ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"五、 ES6 模块与 CommonJS 模块的差异\"></a>五、 ES6 模块与 CommonJS 模块的差异</h2><h3 id=\"1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。\"><a href=\"#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。\" class=\"headerlink\" title=\"1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<h3 id=\"2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。\"><a href=\"#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。\" class=\"headerlink\" title=\"2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n<p><a href=\"https://juejin.cn/user/4388906146731486/posts\">subwaydown</a></p>\n","site":{"data":{}},"wordcount":4463,"excerpt":"","more":"<h1 id=\"前端模块化：CommonJS-AMD-CMD-ES6\"><a href=\"#前端模块化：CommonJS-AMD-CMD-ES6\" class=\"headerlink\" title=\"前端模块化：CommonJS,AMD,CMD,ES6\"></a>前端模块化：CommonJS,AMD,CMD,ES6</h1><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的 js 模块化规范有 CommonJS、AMD、CMD 以及 ES6 的模块系统。参见阮一峰老师的文章 <a href=\"https://link.juejin.cn/?target=http://es6.ruanyifeng.com/%23docs/module-loader\" title=\"http://es6.ruanyifeng.com/#docs/module-loader\">module-loader</a> 。</p>\n<h2 id=\"一、CommonJS\"><a href=\"#一、CommonJS\" class=\"headerlink\" title=\"一、CommonJS\"></a>一、CommonJS</h2><p>Node.js 是 commonJS 规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持：<code>module</code>、<code>exports</code>、<code>require</code>、<code>global</code>。实际使用时，用<code>module.exports</code>定义当前模块对外输出的接口（不推荐直接用<code>exports</code>），用<code>require</code>加载模块。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义模块math.js</span><br><span class=\"hljs-keyword\">var</span> basicNum = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;   <span class=\"hljs-keyword\">return</span> a + b; &#125;<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123; <span class=\"hljs-comment\">//在这里写上需要向外暴露的函数、变量</span><br><span class=\"hljs-attr\">add</span>: add,   <span class=\"hljs-attr\">basicNum</span>: basicNum<br>&#125; <span class=\"hljs-comment\">// 引用自定义的模块时，参数包含路径，可省略.js</span><br><span class=\"hljs-keyword\">var</span> math = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./math&#x27;</span>); math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// 引用核心模块时，不需要带路径</span><br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>); http.<span class=\"hljs-title function_\">createService</span>(...).<span class=\"hljs-title function_\">listen</span>(<span class=\"hljs-number\">3000</span>);<br></code></pre></td></tr></table></figure>\n\n<p>commonJS 用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>\n<h2 id=\"二、AMD-和-require-js\"><a href=\"#二、AMD-和-require-js\" class=\"headerlink\" title=\"二、AMD 和 require.js\"></a>二、AMD 和 require.js</h2><p>AMD 规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。这里介绍用 require.js 实现 AMD 规范的模块化：用<code>require.config()</code>指定引用路径等，用<code>define()</code>定义模块，用<code>require()</code>加载模块。</p>\n<p>首先我们需要引入 require.js 文件和一个入口文件 main.js。main.js 中配置<code>require.config()</code>并规定项目中用到的基础模块。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** 网页中引入require.js及main.js **/</span><br>;<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;js/require.js&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">  <span class=\"hljs-attr\">data-main</span>=<span class=\"hljs-string\">&quot;js/main&quot;</span></span></span><br><span class=\"hljs-tag\"><span class=\"language-xml\">&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span> <span class=\"hljs-comment\">/** main.js 入口文件/主模块 **/</span><br><span class=\"hljs-comment\">// 首先用config()指定各模块路径和引用名</span><br><span class=\"hljs-built_in\">require</span>.<span class=\"hljs-title function_\">config</span>(&#123;<br>  <span class=\"hljs-attr\">baseUrl</span>: <span class=\"hljs-string\">&#x27;js/lib&#x27;</span>,<br>  <span class=\"hljs-attr\">paths</span>: &#123;<br>    <span class=\"hljs-attr\">jquery</span>: <span class=\"hljs-string\">&#x27;jquery.min&#x27;</span>, <span class=\"hljs-comment\">//实际路径为js/lib/jquery.min.js</span><br>    <span class=\"hljs-attr\">underscore</span>: <span class=\"hljs-string\">&#x27;underscore.min&#x27;</span>,<br>  &#125;,<br>&#125;) <span class=\"hljs-comment\">// 执行基本操作</span><br><span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;jquery&#x27;</span>, <span class=\"hljs-string\">&#x27;underscore&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$, _</span>) &#123;<br>  <span class=\"hljs-comment\">// some code here</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>引用模块的时候，我们将模块名放在<code>[]</code>中作为<code>reqiure()</code>的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在<code>[]</code>中作为<code>define()</code>的第一参数。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 定义math.js模块</span><br><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> basicNum = <span class=\"hljs-number\">0</span><br>  <span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">x, y</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> x + y<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">add</span>: add, <span class=\"hljs-attr\">basicNum</span>: basicNum &#125;<br>&#125;) <span class=\"hljs-comment\">// 定义一个依赖underscore.js的模块</span><br><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&#x27;underscore&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">_</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> classify = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">list</span>) &#123;<br>    _.<span class=\"hljs-title function_\">countBy</span>(list, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">num</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> num &gt; <span class=\"hljs-number\">30</span> ? <span class=\"hljs-string\">&#x27;old&#x27;</span> : <span class=\"hljs-string\">&#x27;young&#x27;</span><br>    &#125;)<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">classify</span>: classify &#125;<br>&#125;) <span class=\"hljs-comment\">// 引用模块，将模块放在[]内</span><br><span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">&#x27;jquery&#x27;</span>, <span class=\"hljs-string\">&#x27;math&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$, math</span>) &#123;<br>  <span class=\"hljs-keyword\">var</span> sum = math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>)<br>  $(<span class=\"hljs-string\">&#x27;#sum&#x27;</span>).<span class=\"hljs-title function_\">html</span>(sum)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、CMD-和-sea-js\"><a href=\"#三、CMD-和-sea-js\" class=\"headerlink\" title=\"三、CMD 和 sea.js\"></a>三、CMD 和 sea.js</h2><p>require.js 在申明依赖的模块时会在第一之间加载并执行模块内的代码：</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>], <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b, c, d, e, f</span>) &#123;<br>  <span class=\"hljs-comment\">// 等于在最前面声明并初始化了要用到的所有模块</span><br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) &#123;<br>    <span class=\"hljs-comment\">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>    b.<span class=\"hljs-title function_\">foo</span>()<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>CMD 是另一种 js 模块化方案，它与 AMD 很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD 推崇依赖就近、延迟执行。此规范其实是在 sea.js 推广过程中产生的。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** AMD写法 **/</span><br><span class=\"hljs-title function_\">define</span>([<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>], <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b, c, d, e, f</span>) &#123;       <span class=\"hljs-comment\">// 等于在最前面声明并初始化了要用到的所有模块</span><br>a.<span class=\"hljs-title function_\">doSomething</span>();     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) &#123;         <span class=\"hljs-comment\">// 即便没用到某个模块 b，但 b 还是提前执行了</span><br>b.<span class=\"hljs-title function_\">doSomething</span>()     &#125;  &#125;); <span class=\"hljs-comment\">/** CMD写法 **/</span><br><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-variable language_\">module</span></span>) &#123;     <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./a&#x27;</span>); <span class=\"hljs-comment\">//在需要时申明</span><br>a.<span class=\"hljs-title function_\">doSomething</span>();     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">false</span>) &#123;         <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./b&#x27;</span>);         b.<span class=\"hljs-title function_\">doSomething</span>();     &#125; &#125;);<br><span class=\"hljs-comment\">/** sea.js **/</span><br><span class=\"hljs-comment\">// 定义模块 math.js</span><br><span class=\"hljs-title function_\">define</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">require</span>, <span class=\"hljs-built_in\">exports</span>, <span class=\"hljs-variable language_\">module</span></span>) &#123;     <span class=\"hljs-keyword\">var</span> $ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;jquery.js&#x27;</span>);     <span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a,b</span>)&#123;         <span class=\"hljs-keyword\">return</span> a+b;     &#125;     <span class=\"hljs-built_in\">exports</span>.<span class=\"hljs-property\">add</span> = add; &#125;); <span class=\"hljs-comment\">// 加载模块</span><br>seajs.<span class=\"hljs-title function_\">use</span>([<span class=\"hljs-string\">&#x27;math.js&#x27;</span>], <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">math</span>)&#123;     <span class=\"hljs-keyword\">var</span> sum = math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>+<span class=\"hljs-number\">2</span>); &#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、ES6-Module\"><a href=\"#四、ES6-Module\" class=\"headerlink\" title=\"四、ES6 Module\"></a>四、ES6 Module</h2><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** 定义模块 math.js **/</span> <span class=\"hljs-keyword\">var</span> basicNum = <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b<br>&#125;<br><span class=\"hljs-keyword\">export</span> &#123; basicNum, add &#125;<br><span class=\"hljs-comment\">/** 引用模块 **/</span> <span class=\"hljs-keyword\">import</span> &#123; basicNum, add &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./math&#x27;</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">ele</span>) &#123;<br>  ele.<span class=\"hljs-property\">textContent</span> = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">99</span> + basicNum)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如上例所示，使用<code>import</code>命令的时候，用户需要知道所要加载的变量名或函数名。其实 ES6 还提供了<code>export default</code>命令，为模块指定默认输出，对应的<code>import</code>语句不需要使用大括号。这也更趋近于 ADM 的引用写法。</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/** export default **/</span> <span class=\"hljs-comment\">//定义输出</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123; basicNum, add &#125; <span class=\"hljs-comment\">//引入 import math from &#x27;./math&#x27;;</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-params\">ele</span>) &#123;<br>  ele.<span class=\"hljs-property\">textContent</span> = math.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">99</span> + math.<span class=\"hljs-property\">basicNum</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>ES6 的模块不是对象，<code>import</code>命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>\n<h2 id=\"五、-ES6-模块与-CommonJS-模块的差异\"><a href=\"#五、-ES6-模块与-CommonJS-模块的差异\" class=\"headerlink\" title=\"五、 ES6 模块与 CommonJS 模块的差异\"></a>五、 ES6 模块与 CommonJS 模块的差异</h2><h3 id=\"1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。\"><a href=\"#1-CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用。\" class=\"headerlink\" title=\"1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。\"></a>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</h3><ul>\n<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>\n<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>\n</ul>\n<h3 id=\"2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。\"><a href=\"#2-CommonJS-模块是运行时加载，ES6-模块是编译时输出接口。\" class=\"headerlink\" title=\"2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。\"></a>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</h3><ul>\n<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>\n<li>编译时加载: ES6 模块不是对象，而是通过 <code>export</code> 命令显式指定输出的代码，<code>import</code>时采用静态命令的形式。即在<code>import</code>时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>\n</ul>\n<p>CommonJS 加载的是一个对象（即<code>module.exports</code>属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>\n<p><a href=\"https://juejin.cn/user/4388906146731486/posts\">subwaydown</a></p>\n"},{"title":"js原型和原型链","date":"2024-07-24T06:55:08.000Z","_content":"\n## 前言\n\n不要为了面试而去背题，匆匆忙忙的，不仅学不进去，背完了几天后马上会忘记。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1337beace1894b31bd868190ddb5ee75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n你可能会说，“没办法，这不是为了能找份工作嘛！”。我想说的是，“那你没开始找工作的时候，咋不好好学习呢。”\n\n好了，上述扯的这些，意思就是让大家不要做**收藏家**，不要把好文收藏了，就放在收藏夹里吃灰！\n\n下面为大家简单阐述我对原型和原型链的理解，若是觉得有说的不对的地方，还望直接把页面关闭了，别在我这篇文章上继续浪费时间。（逃）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fb1e5227de446f8ec8f2bbf39a9e26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 四个规则\n\n我们先来了解下面引用类型的四个规则：\n\n1、引用类型，都具有对象特性，即可自由扩展属性。\n\n2、引用类型，都有一个隐式原型 `__proto__` 属性，属性值是一个普通的对象。\n\n3、引用类型，隐式原型 `__proto__`  的属性值指向它的构造函数的显式原型 `prototype` 属性值。\n\n4、当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 `__proto__`（也就是它的构造函数的显式原型 `prototype`）中寻找。\n\n> 引用类型：Object、Array、Function、Date、RegExp。这里我姑且称 **proto** 为隐式原型，没有官方中文叫法，大家都瞎叫居多。\n\n下面我们逐一验证上面几个规则，就会慢慢地理解原型和原型链。\n\n#### 规则一\n\n引用类型，都具有对象特性，即可自由扩展属性：\n\n```javascript\nconst obj = {}\nconst arr = []\nconst fn = function () {}\nobj.a = 1\narr.a = 1\nfn.a = 1\nconsole.log(obj.a) // 1\nconsole.log(arr.a) // 1\nconsole.log(fn.a) // 1\n```\n\n> 这个规则应该比较好理解，Date 和 RegExp 也一样，就不赘述了。\n\n#### 规则二\n\n引用类型，都有一个隐式原型 `__proto__` 属性，属性值是一个普通的对象：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nconst obj = {}\nconst arr = []\nconst fn = function () {}\nconsole.log('obj.__proto__', obj.__proto__)\nconsole.log('arr.__proto__', arr.__proto__)\nconsole.log('fn.__proto__', fn.__proto__)\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8640c1029037485ca324b2cf61bdf928~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 规则三\n\n引用类型，隐式原型 `__proto__` 的属性值指向它的构造函数的显式原型 `prototype` 属性值：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nconst obj = {}\nconst arr = []\nconst fn = function () {}\nobj.__proto__ == Object.prototype // true\narr.__proto__ === Array.prototype // true\nfn.__proto__ == Function.prototype // true\n```\n\n#### 规则四\n\n当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 `__proto__`（也就是它的构造函数的显式原型 `prototype`）中寻找：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nconst obj = { a: 1 }\nobj.toString // ƒ toString() { [native code] }\n```\n\n首先， `obj`  对象并没有 `toString`  属性，之所以能获取到 `toString`  属性，是遵循了第四条规则，从它的构造函数 `Object`  的 `prototype`  里去获取。\n\n## 一个特例\n\n我试图想推翻上面的规则，看下面这段代码：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nfunction Person(name) {\n  this.name = name\n  return this // 其实这行可以不写，默认返回 this 对象\n  }\n  var nick = new Person(\"nick\") nick.toString // ƒ toString() { [native code] }\n```\n\n按理说， `nick`  是 `Person`  构造函数生成的实例，而 `Person`  的 `prototype`  并没有 `toString`  方法，那么为什么， `nick`  能获取到 `toString`  方法？\n\n这里就引出 `原型链`  的概念了， `nick`  实例先从自身出发检讨自己，发现并没有 `toString`  方法。找不到，就往上走，找 `Person`  构造函数的 `prototype`  属性，还是没找到。构造函数的 `prototype`  也是一个对象嘛，那对象的构造函数是 `Object` ，所以就找到了 `Object.prototype` 下的 `toString`  方法。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4cc571148745f4b25545d3a7ccf73d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 上述寻找的过程就形成了原型链的概念，我理解的原型链就是这样一个过程。也不知道哪个人说过一句，JavaScript 里万物皆对象。从上述情况看来，好像是这么个理。🤔\n\n## 一张图片\n\n用图片描述原型链：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n最后一个 `null`，设计上是为了避免死循环而设置的, `Object.prototype`  的隐式原型指向 `null`。\n\n## 一个方法\n\n`instanceof`  运算符用于测试构造函数的 `prototype` 属性是否出现在对象原型链中的任何位置。 `instanceof`  的简易手写版，如下所示：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\n// 变量R的原型 存在于 变量L的原型链上\nfunction instance_of(L, R) {\n  // 验证如果为基本数据类型，就直接返回 false\n  const baseType = ['string', 'number', 'boolean', 'undefined', 'symbol']\n  if (baseType.includes(typeof L)) {\n    return false\n  }\n  let RP = R.prototype // 取 R 的显示原型\n  L = L.__proto__ // 取 L 的隐式原型\n  while (true) {\n    if (L === null) {\n      // 找到最顶层\n      return false\n    }\n    if (L === RP) {\n      // 严格相等\n      return true\n    }\n    L = L.__proto__ // 没找到继续向上一层原型链查找\n  }\n}\n```\n\n我们再来看下面这段代码：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nfunction Foo(name) {   this.name = name; } var f = new Foo('nick') f instanceof Foo // true\nf instanceof Object // true\n```\n\n上述代码判断流程大致如下：\n\n1、 `f instanceof Foo`： `f`  的隐式原型 `__proto__`  和 `Foo.prototype` ，是相等的，所以返回 `true` 。\n\n2、 `f instanceof Object`： `f`  的隐式原型 `__proto__` ，和 `Object.prototype`  不等，所以继续往上走。 `f`  的隐式原型 `__proto__`  指向 `Foo.prototype` ，所以继续用 `Foo.prototype.__proto__`  去对比 `Object.prototype` ，这会儿就相等了，因为 `Foo.prototype`  就是一个普通的对象。\n\n> 再一次验证万物皆对象。。。。\n\n## 总结\n\n通过四个特性、一个例子、一张图片、一个方法，大家应该对原型和原型链的关系有了大概的认知。我的认知就是，原型链就是一个过程，原型是原型链这个过程中的一个单位，贯穿整个原型链。就好像你要是看完了不点个赞，我可以顺着网线找到你。\n\nhttps://juejin.cn/post/6934498361475072014\n","source":"_posts/jsPrototype.md","raw":"---\ntitle: js原型和原型链\ndate: 2024-07-24 14:55:08\ntags: js\n---\n\n## 前言\n\n不要为了面试而去背题，匆匆忙忙的，不仅学不进去，背完了几天后马上会忘记。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1337beace1894b31bd868190ddb5ee75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n你可能会说，“没办法，这不是为了能找份工作嘛！”。我想说的是，“那你没开始找工作的时候，咋不好好学习呢。”\n\n好了，上述扯的这些，意思就是让大家不要做**收藏家**，不要把好文收藏了，就放在收藏夹里吃灰！\n\n下面为大家简单阐述我对原型和原型链的理解，若是觉得有说的不对的地方，还望直接把页面关闭了，别在我这篇文章上继续浪费时间。（逃）\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fb1e5227de446f8ec8f2bbf39a9e26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n## 四个规则\n\n我们先来了解下面引用类型的四个规则：\n\n1、引用类型，都具有对象特性，即可自由扩展属性。\n\n2、引用类型，都有一个隐式原型 `__proto__` 属性，属性值是一个普通的对象。\n\n3、引用类型，隐式原型 `__proto__`  的属性值指向它的构造函数的显式原型 `prototype` 属性值。\n\n4、当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 `__proto__`（也就是它的构造函数的显式原型 `prototype`）中寻找。\n\n> 引用类型：Object、Array、Function、Date、RegExp。这里我姑且称 **proto** 为隐式原型，没有官方中文叫法，大家都瞎叫居多。\n\n下面我们逐一验证上面几个规则，就会慢慢地理解原型和原型链。\n\n#### 规则一\n\n引用类型，都具有对象特性，即可自由扩展属性：\n\n```javascript\nconst obj = {}\nconst arr = []\nconst fn = function () {}\nobj.a = 1\narr.a = 1\nfn.a = 1\nconsole.log(obj.a) // 1\nconsole.log(arr.a) // 1\nconsole.log(fn.a) // 1\n```\n\n> 这个规则应该比较好理解，Date 和 RegExp 也一样，就不赘述了。\n\n#### 规则二\n\n引用类型，都有一个隐式原型 `__proto__` 属性，属性值是一个普通的对象：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nconst obj = {}\nconst arr = []\nconst fn = function () {}\nconsole.log('obj.__proto__', obj.__proto__)\nconsole.log('arr.__proto__', arr.__proto__)\nconsole.log('fn.__proto__', fn.__proto__)\n```\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8640c1029037485ca324b2cf61bdf928~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n#### 规则三\n\n引用类型，隐式原型 `__proto__` 的属性值指向它的构造函数的显式原型 `prototype` 属性值：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nconst obj = {}\nconst arr = []\nconst fn = function () {}\nobj.__proto__ == Object.prototype // true\narr.__proto__ === Array.prototype // true\nfn.__proto__ == Function.prototype // true\n```\n\n#### 规则四\n\n当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 `__proto__`（也就是它的构造函数的显式原型 `prototype`）中寻找：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nconst obj = { a: 1 }\nobj.toString // ƒ toString() { [native code] }\n```\n\n首先， `obj`  对象并没有 `toString`  属性，之所以能获取到 `toString`  属性，是遵循了第四条规则，从它的构造函数 `Object`  的 `prototype`  里去获取。\n\n## 一个特例\n\n我试图想推翻上面的规则，看下面这段代码：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nfunction Person(name) {\n  this.name = name\n  return this // 其实这行可以不写，默认返回 this 对象\n  }\n  var nick = new Person(\"nick\") nick.toString // ƒ toString() { [native code] }\n```\n\n按理说， `nick`  是 `Person`  构造函数生成的实例，而 `Person`  的 `prototype`  并没有 `toString`  方法，那么为什么， `nick`  能获取到 `toString`  方法？\n\n这里就引出 `原型链`  的概念了， `nick`  实例先从自身出发检讨自己，发现并没有 `toString`  方法。找不到，就往上走，找 `Person`  构造函数的 `prototype`  属性，还是没找到。构造函数的 `prototype`  也是一个对象嘛，那对象的构造函数是 `Object` ，所以就找到了 `Object.prototype` 下的 `toString`  方法。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4cc571148745f4b25545d3a7ccf73d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n> 上述寻找的过程就形成了原型链的概念，我理解的原型链就是这样一个过程。也不知道哪个人说过一句，JavaScript 里万物皆对象。从上述情况看来，好像是这么个理。🤔\n\n## 一张图片\n\n用图片描述原型链：\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)\n\n最后一个 `null`，设计上是为了避免死循环而设置的, `Object.prototype`  的隐式原型指向 `null`。\n\n## 一个方法\n\n`instanceof`  运算符用于测试构造函数的 `prototype` 属性是否出现在对象原型链中的任何位置。 `instanceof`  的简易手写版，如下所示：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\n// 变量R的原型 存在于 变量L的原型链上\nfunction instance_of(L, R) {\n  // 验证如果为基本数据类型，就直接返回 false\n  const baseType = ['string', 'number', 'boolean', 'undefined', 'symbol']\n  if (baseType.includes(typeof L)) {\n    return false\n  }\n  let RP = R.prototype // 取 R 的显示原型\n  L = L.__proto__ // 取 L 的隐式原型\n  while (true) {\n    if (L === null) {\n      // 找到最顶层\n      return false\n    }\n    if (L === RP) {\n      // 严格相等\n      return true\n    }\n    L = L.__proto__ // 没找到继续向上一层原型链查找\n  }\n}\n```\n\n我们再来看下面这段代码：\n\njavascript\n\n代码解读\n\n复制代码\n\n```javascript\nfunction Foo(name) {   this.name = name; } var f = new Foo('nick') f instanceof Foo // true\nf instanceof Object // true\n```\n\n上述代码判断流程大致如下：\n\n1、 `f instanceof Foo`： `f`  的隐式原型 `__proto__`  和 `Foo.prototype` ，是相等的，所以返回 `true` 。\n\n2、 `f instanceof Object`： `f`  的隐式原型 `__proto__` ，和 `Object.prototype`  不等，所以继续往上走。 `f`  的隐式原型 `__proto__`  指向 `Foo.prototype` ，所以继续用 `Foo.prototype.__proto__`  去对比 `Object.prototype` ，这会儿就相等了，因为 `Foo.prototype`  就是一个普通的对象。\n\n> 再一次验证万物皆对象。。。。\n\n## 总结\n\n通过四个特性、一个例子、一张图片、一个方法，大家应该对原型和原型链的关系有了大概的认知。我的认知就是，原型链就是一个过程，原型是原型链这个过程中的一个单位，贯穿整个原型链。就好像你要是看完了不点个赞，我可以顺着网线找到你。\n\nhttps://juejin.cn/post/6934498361475072014\n","slug":"jsPrototype","published":1,"updated":"2024-07-24T06:59:51.020Z","_id":"clyzhplcy000llyxxdq0aeefr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不要为了面试而去背题，匆匆忙忙的，不仅学不进去，背完了几天后马上会忘记。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1337beace1894b31bd868190ddb5ee75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>你可能会说，“没办法，这不是为了能找份工作嘛！”。我想说的是，“那你没开始找工作的时候，咋不好好学习呢。”</p>\n<p>好了，上述扯的这些，意思就是让大家不要做<strong>收藏家</strong>，不要把好文收藏了，就放在收藏夹里吃灰！</p>\n<p>下面为大家简单阐述我对原型和原型链的理解，若是觉得有说的不对的地方，还望直接把页面关闭了，别在我这篇文章上继续浪费时间。（逃）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fb1e5227de446f8ec8f2bbf39a9e26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<h2 id=\"四个规则\"><a href=\"#四个规则\" class=\"headerlink\" title=\"四个规则\"></a>四个规则</h2><p>我们先来了解下面引用类型的四个规则：</p>\n<p>1、引用类型，都具有对象特性，即可自由扩展属性。</p>\n<p>2、引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象。</p>\n<p>3、引用类型，隐式原型 <code>__proto__</code>  的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值。</p>\n<p>4、当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找。</p>\n<blockquote>\n<p>引用类型：Object、Array、Function、Date、RegExp。这里我姑且称 <strong>proto</strong> 为隐式原型，没有官方中文叫法，大家都瞎叫居多。</p>\n</blockquote>\n<p>下面我们逐一验证上面几个规则，就会慢慢地理解原型和原型链。</p>\n<h4 id=\"规则一\"><a href=\"#规则一\" class=\"headerlink\" title=\"规则一\"></a>规则一</h4><p>引用类型，都具有对象特性，即可自由扩展属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-keyword\">const</span> arr = []<br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>obj.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span><br>arr.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span><br>fn.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个规则应该比较好理解，Date 和 RegExp 也一样，就不赘述了。</p>\n</blockquote>\n<h4 id=\"规则二\"><a href=\"#规则二\" class=\"headerlink\" title=\"规则二\"></a>规则二</h4><p>引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-keyword\">const</span> arr = []<br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;obj.__proto__&#x27;</span>, obj.<span class=\"hljs-property\">__proto__</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;arr.__proto__&#x27;</span>, arr.<span class=\"hljs-property\">__proto__</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;fn.__proto__&#x27;</span>, fn.<span class=\"hljs-property\">__proto__</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8640c1029037485ca324b2cf61bdf928~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<h4 id=\"规则三\"><a href=\"#规则三\" class=\"headerlink\" title=\"规则三\"></a>规则三</h4><p>引用类型，隐式原型 <code>__proto__</code> 的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-keyword\">const</span> arr = []<br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>obj.<span class=\"hljs-property\">__proto__</span> == <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br>arr.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br>fn.<span class=\"hljs-property\">__proto__</span> == <span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"规则四\"><a href=\"#规则四\" class=\"headerlink\" title=\"规则四\"></a>规则四</h4><p>当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;<br>obj.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// ƒ toString() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>首先， <code>obj</code>  对象并没有 <code>toString</code>  属性，之所以能获取到 <code>toString</code>  属性，是遵循了第四条规则，从它的构造函数 <code>Object</code>  的 <code>prototype</code>  里去获取。</p>\n<h2 id=\"一个特例\"><a href=\"#一个特例\" class=\"headerlink\" title=\"一个特例\"></a>一个特例</h2><p>我试图想推翻上面的规则，看下面这段代码：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-comment\">// 其实这行可以不写，默认返回 this 对象</span><br>  &#125;<br>  <span class=\"hljs-keyword\">var</span> nick = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&quot;nick&quot;</span>) nick.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// ƒ toString() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>按理说， <code>nick</code>  是 <code>Person</code>  构造函数生成的实例，而 <code>Person</code>  的 <code>prototype</code>  并没有 <code>toString</code>  方法，那么为什么， <code>nick</code>  能获取到 <code>toString</code>  方法？</p>\n<p>这里就引出 <code>原型链</code>  的概念了， <code>nick</code>  实例先从自身出发检讨自己，发现并没有 <code>toString</code>  方法。找不到，就往上走，找 <code>Person</code>  构造函数的 <code>prototype</code>  属性，还是没找到。构造函数的 <code>prototype</code>  也是一个对象嘛，那对象的构造函数是 <code>Object</code> ，所以就找到了 <code>Object.prototype</code> 下的 <code>toString</code>  方法。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4cc571148745f4b25545d3a7ccf73d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<blockquote>\n<p>上述寻找的过程就形成了原型链的概念，我理解的原型链就是这样一个过程。也不知道哪个人说过一句，JavaScript 里万物皆对象。从上述情况看来，好像是这么个理。🤔</p>\n</blockquote>\n<h2 id=\"一张图片\"><a href=\"#一张图片\" class=\"headerlink\" title=\"一张图片\"></a>一张图片</h2><p>用图片描述原型链：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>最后一个 <code>null</code>，设计上是为了避免死循环而设置的, <code>Object.prototype</code>  的隐式原型指向 <code>null</code>。</p>\n<h2 id=\"一个方法\"><a href=\"#一个方法\" class=\"headerlink\" title=\"一个方法\"></a>一个方法</h2><p><code>instanceof</code>  运算符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象原型链中的任何位置。 <code>instanceof</code>  的简易手写版，如下所示：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 变量R的原型 存在于 变量L的原型链上</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">instance_of</span>(<span class=\"hljs-params\">L, R</span>) &#123;<br>  <span class=\"hljs-comment\">// 验证如果为基本数据类型，就直接返回 false</span><br>  <span class=\"hljs-keyword\">const</span> baseType = [<span class=\"hljs-string\">&#x27;string&#x27;</span>, <span class=\"hljs-string\">&#x27;number&#x27;</span>, <span class=\"hljs-string\">&#x27;boolean&#x27;</span>, <span class=\"hljs-string\">&#x27;undefined&#x27;</span>, <span class=\"hljs-string\">&#x27;symbol&#x27;</span>]<br>  <span class=\"hljs-keyword\">if</span> (baseType.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-keyword\">typeof</span> L)) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable constant_\">RP</span> = R.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// 取 R 的显示原型</span><br>  L = L.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// 取 L 的隐式原型</span><br>  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-literal\">null</span>) &#123;<br>      <span class=\"hljs-comment\">// 找到最顶层</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-variable constant_\">RP</span>) &#123;<br>      <span class=\"hljs-comment\">// 严格相等</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>    L = L.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// 没找到继续向上一层原型链查找</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们再来看下面这段代码：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Foo</span>(<span class=\"hljs-params\">name</span>) &#123;   <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name; &#125; <span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;nick&#x27;</span>) f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Foo</span> <span class=\"hljs-comment\">// true</span><br>f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>上述代码判断流程大致如下：</p>\n<p>1、 <code>f instanceof Foo</code>： <code>f</code>  的隐式原型 <code>__proto__</code>  和 <code>Foo.prototype</code> ，是相等的，所以返回 <code>true</code> 。</p>\n<p>2、 <code>f instanceof Object</code>： <code>f</code>  的隐式原型 <code>__proto__</code> ，和 <code>Object.prototype</code>  不等，所以继续往上走。 <code>f</code>  的隐式原型 <code>__proto__</code>  指向 <code>Foo.prototype</code> ，所以继续用 <code>Foo.prototype.__proto__</code>  去对比 <code>Object.prototype</code> ，这会儿就相等了，因为 <code>Foo.prototype</code>  就是一个普通的对象。</p>\n<blockquote>\n<p>再一次验证万物皆对象。。。。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过四个特性、一个例子、一张图片、一个方法，大家应该对原型和原型链的关系有了大概的认知。我的认知就是，原型链就是一个过程，原型是原型链这个过程中的一个单位，贯穿整个原型链。就好像你要是看完了不点个赞，我可以顺着网线找到你。</p>\n<p><a href=\"https://juejin.cn/post/6934498361475072014\">https://juejin.cn/post/6934498361475072014</a></p>\n","site":{"data":{}},"wordcount":3227,"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>不要为了面试而去背题，匆匆忙忙的，不仅学不进去，背完了几天后马上会忘记。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1337beace1894b31bd868190ddb5ee75~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>你可能会说，“没办法，这不是为了能找份工作嘛！”。我想说的是，“那你没开始找工作的时候，咋不好好学习呢。”</p>\n<p>好了，上述扯的这些，意思就是让大家不要做<strong>收藏家</strong>，不要把好文收藏了，就放在收藏夹里吃灰！</p>\n<p>下面为大家简单阐述我对原型和原型链的理解，若是觉得有说的不对的地方，还望直接把页面关闭了，别在我这篇文章上继续浪费时间。（逃）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fb1e5227de446f8ec8f2bbf39a9e26~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<h2 id=\"四个规则\"><a href=\"#四个规则\" class=\"headerlink\" title=\"四个规则\"></a>四个规则</h2><p>我们先来了解下面引用类型的四个规则：</p>\n<p>1、引用类型，都具有对象特性，即可自由扩展属性。</p>\n<p>2、引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象。</p>\n<p>3、引用类型，隐式原型 <code>__proto__</code>  的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值。</p>\n<p>4、当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找。</p>\n<blockquote>\n<p>引用类型：Object、Array、Function、Date、RegExp。这里我姑且称 <strong>proto</strong> 为隐式原型，没有官方中文叫法，大家都瞎叫居多。</p>\n</blockquote>\n<p>下面我们逐一验证上面几个规则，就会慢慢地理解原型和原型链。</p>\n<h4 id=\"规则一\"><a href=\"#规则一\" class=\"headerlink\" title=\"规则一\"></a>规则一</h4><p>引用类型，都具有对象特性，即可自由扩展属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-keyword\">const</span> arr = []<br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>obj.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span><br>arr.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span><br>fn.<span class=\"hljs-property\">a</span> = <span class=\"hljs-number\">1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn.<span class=\"hljs-property\">a</span>) <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个规则应该比较好理解，Date 和 RegExp 也一样，就不赘述了。</p>\n</blockquote>\n<h4 id=\"规则二\"><a href=\"#规则二\" class=\"headerlink\" title=\"规则二\"></a>规则二</h4><p>引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-keyword\">const</span> arr = []<br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;obj.__proto__&#x27;</span>, obj.<span class=\"hljs-property\">__proto__</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;arr.__proto__&#x27;</span>, arr.<span class=\"hljs-property\">__proto__</span>)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;fn.__proto__&#x27;</span>, fn.<span class=\"hljs-property\">__proto__</span>)<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8640c1029037485ca324b2cf61bdf928~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<h4 id=\"规则三\"><a href=\"#规则三\" class=\"headerlink\" title=\"规则三\"></a>规则三</h4><p>引用类型，隐式原型 <code>__proto__</code> 的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;<br><span class=\"hljs-keyword\">const</span> arr = []<br><span class=\"hljs-keyword\">const</span> fn = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) &#123;&#125;<br>obj.<span class=\"hljs-property\">__proto__</span> == <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br>arr.<span class=\"hljs-property\">__proto__</span> === <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br>fn.<span class=\"hljs-property\">__proto__</span> == <span class=\"hljs-title class_\">Function</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"规则四\"><a href=\"#规则四\" class=\"headerlink\" title=\"规则四\"></a>规则四</h4><p>当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;<br>obj.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// ƒ toString() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>首先， <code>obj</code>  对象并没有 <code>toString</code>  属性，之所以能获取到 <code>toString</code>  属性，是遵循了第四条规则，从它的构造函数 <code>Object</code>  的 <code>prototype</code>  里去获取。</p>\n<h2 id=\"一个特例\"><a href=\"#一个特例\" class=\"headerlink\" title=\"一个特例\"></a>一个特例</h2><p>我试图想推翻上面的规则，看下面这段代码：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span> <span class=\"hljs-comment\">// 其实这行可以不写，默认返回 this 对象</span><br>  &#125;<br>  <span class=\"hljs-keyword\">var</span> nick = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>(<span class=\"hljs-string\">&quot;nick&quot;</span>) nick.<span class=\"hljs-property\">toString</span> <span class=\"hljs-comment\">// ƒ toString() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>按理说， <code>nick</code>  是 <code>Person</code>  构造函数生成的实例，而 <code>Person</code>  的 <code>prototype</code>  并没有 <code>toString</code>  方法，那么为什么， <code>nick</code>  能获取到 <code>toString</code>  方法？</p>\n<p>这里就引出 <code>原型链</code>  的概念了， <code>nick</code>  实例先从自身出发检讨自己，发现并没有 <code>toString</code>  方法。找不到，就往上走，找 <code>Person</code>  构造函数的 <code>prototype</code>  属性，还是没找到。构造函数的 <code>prototype</code>  也是一个对象嘛，那对象的构造函数是 <code>Object</code> ，所以就找到了 <code>Object.prototype</code> 下的 <code>toString</code>  方法。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4cc571148745f4b25545d3a7ccf73d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<blockquote>\n<p>上述寻找的过程就形成了原型链的概念，我理解的原型链就是这样一个过程。也不知道哪个人说过一句，JavaScript 里万物皆对象。从上述情况看来，好像是这么个理。🤔</p>\n</blockquote>\n<h2 id=\"一张图片\"><a href=\"#一张图片\" class=\"headerlink\" title=\"一张图片\"></a>一张图片</h2><p>用图片描述原型链：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp\" alt=\"image.png\"></p>\n<p>最后一个 <code>null</code>，设计上是为了避免死循环而设置的, <code>Object.prototype</code>  的隐式原型指向 <code>null</code>。</p>\n<h2 id=\"一个方法\"><a href=\"#一个方法\" class=\"headerlink\" title=\"一个方法\"></a>一个方法</h2><p><code>instanceof</code>  运算符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象原型链中的任何位置。 <code>instanceof</code>  的简易手写版，如下所示：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 变量R的原型 存在于 变量L的原型链上</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">instance_of</span>(<span class=\"hljs-params\">L, R</span>) &#123;<br>  <span class=\"hljs-comment\">// 验证如果为基本数据类型，就直接返回 false</span><br>  <span class=\"hljs-keyword\">const</span> baseType = [<span class=\"hljs-string\">&#x27;string&#x27;</span>, <span class=\"hljs-string\">&#x27;number&#x27;</span>, <span class=\"hljs-string\">&#x27;boolean&#x27;</span>, <span class=\"hljs-string\">&#x27;undefined&#x27;</span>, <span class=\"hljs-string\">&#x27;symbol&#x27;</span>]<br>  <span class=\"hljs-keyword\">if</span> (baseType.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-keyword\">typeof</span> L)) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>  &#125;<br>  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable constant_\">RP</span> = R.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> <span class=\"hljs-comment\">// 取 R 的显示原型</span><br>  L = L.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// 取 L 的隐式原型</span><br>  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-literal\">null</span>) &#123;<br>      <span class=\"hljs-comment\">// 找到最顶层</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (L === <span class=\"hljs-variable constant_\">RP</span>) &#123;<br>      <span class=\"hljs-comment\">// 严格相等</span><br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span><br>    &#125;<br>    L = L.<span class=\"hljs-property\">__proto__</span> <span class=\"hljs-comment\">// 没找到继续向上一层原型链查找</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们再来看下面这段代码：</p>\n<p>javascript</p>\n<p>代码解读</p>\n<p>复制代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Foo</span>(<span class=\"hljs-params\">name</span>) &#123;   <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name; &#125; <span class=\"hljs-keyword\">var</span> f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Foo</span>(<span class=\"hljs-string\">&#x27;nick&#x27;</span>) f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Foo</span> <span class=\"hljs-comment\">// true</span><br>f <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Object</span> <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<p>上述代码判断流程大致如下：</p>\n<p>1、 <code>f instanceof Foo</code>： <code>f</code>  的隐式原型 <code>__proto__</code>  和 <code>Foo.prototype</code> ，是相等的，所以返回 <code>true</code> 。</p>\n<p>2、 <code>f instanceof Object</code>： <code>f</code>  的隐式原型 <code>__proto__</code> ，和 <code>Object.prototype</code>  不等，所以继续往上走。 <code>f</code>  的隐式原型 <code>__proto__</code>  指向 <code>Foo.prototype</code> ，所以继续用 <code>Foo.prototype.__proto__</code>  去对比 <code>Object.prototype</code> ，这会儿就相等了，因为 <code>Foo.prototype</code>  就是一个普通的对象。</p>\n<blockquote>\n<p>再一次验证万物皆对象。。。。</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过四个特性、一个例子、一张图片、一个方法，大家应该对原型和原型链的关系有了大概的认知。我的认知就是，原型链就是一个过程，原型是原型链这个过程中的一个单位，贯穿整个原型链。就好像你要是看完了不点个赞，我可以顺着网线找到你。</p>\n<p><a href=\"https://juejin.cn/post/6934498361475072014\">https://juejin.cn/post/6934498361475072014</a></p>\n"},{"title":"内网穿透","date":"2024-10-23T02:20:22.000Z","_content":"# 这个可怜的前端终于学会了内网穿透\n\n[九段刀客](https://juejin.cn/user/4001878055066237/posts)\n\n## 什么是内网穿透\n\n**内网穿透**这个词大家肯定都有所耳闻，毕竟都是干这行的嘛！没吃过猪肉还能没见过猪跑啊。不就是让自己电脑启的服务，让远在千里之外的人也能访问到吗？对对对就是这个东西。\n\n## 什么场景下，让我需要这个东西呢\n\n微信支付和小程序的图片安全校验的时候。\n\n微信支付和图片安全校验都需要给一个notify\\_url，处理成功后腾讯那边会调用这个接口来通知你结果和信息。\n\n这个场景下内网穿透就非常重要了，如果你不弄内网穿透，每次都要传到测试服务器上去就会很繁琐，写一点传一次，有问题还得倒腾一次，如果能让你的本地就能实现测试服务器一样的功能，那岂不是完美。\n\n有朋友会说服务啊，这不是后端的事情吗？这不是越来越卷了吗？\n\n## 依赖安装和token配置\n\n其实很简单哈哈😄,首先拿出我们的前端秘制配方 npm\n\n`npm install ngrok -g`\n\n它似乎不想我们一步到位，还需要配置一下token，到ngrok.com 注册一个账号 [ngrok官网地址](https://link.juejin.cn/?target=https%3A%2F%2Fngrok.com%2F \"https://ngrok.com/\")\n\n`ngrok config add-authtoken xxxxxxxxxxxxxxx`\n\n![image.png](https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3204ca5c30e64855829632346f27bc88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=XG7gL17AA81XdT1yt5au66QNIcI%3D)\n\n## 起飞🛫\n\n先把你的nodejs服务搞起来，比如端口是3080,再运行内网穿透\n\n`ngrok http http://localhost:3080`\n\n## 看看效果\n\n![image.png](https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aee65decc61b4dbc9716b34f10c837e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=8g90jOIZXwxqXWvEQ%2FVRZx%2FVs1k%3D)","source":"_posts/inNetwork.md","raw":"---\ntitle: 内网穿透\ndate: 2024-10-23 10:20:22\ntags: web\n---\n# 这个可怜的前端终于学会了内网穿透\n\n[九段刀客](https://juejin.cn/user/4001878055066237/posts)\n\n## 什么是内网穿透\n\n**内网穿透**这个词大家肯定都有所耳闻，毕竟都是干这行的嘛！没吃过猪肉还能没见过猪跑啊。不就是让自己电脑启的服务，让远在千里之外的人也能访问到吗？对对对就是这个东西。\n\n## 什么场景下，让我需要这个东西呢\n\n微信支付和小程序的图片安全校验的时候。\n\n微信支付和图片安全校验都需要给一个notify\\_url，处理成功后腾讯那边会调用这个接口来通知你结果和信息。\n\n这个场景下内网穿透就非常重要了，如果你不弄内网穿透，每次都要传到测试服务器上去就会很繁琐，写一点传一次，有问题还得倒腾一次，如果能让你的本地就能实现测试服务器一样的功能，那岂不是完美。\n\n有朋友会说服务啊，这不是后端的事情吗？这不是越来越卷了吗？\n\n## 依赖安装和token配置\n\n其实很简单哈哈😄,首先拿出我们的前端秘制配方 npm\n\n`npm install ngrok -g`\n\n它似乎不想我们一步到位，还需要配置一下token，到ngrok.com 注册一个账号 [ngrok官网地址](https://link.juejin.cn/?target=https%3A%2F%2Fngrok.com%2F \"https://ngrok.com/\")\n\n`ngrok config add-authtoken xxxxxxxxxxxxxxx`\n\n![image.png](https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3204ca5c30e64855829632346f27bc88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=XG7gL17AA81XdT1yt5au66QNIcI%3D)\n\n## 起飞🛫\n\n先把你的nodejs服务搞起来，比如端口是3080,再运行内网穿透\n\n`ngrok http http://localhost:3080`\n\n## 看看效果\n\n![image.png](https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aee65decc61b4dbc9716b34f10c837e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=8g90jOIZXwxqXWvEQ%2FVRZx%2FVs1k%3D)","slug":"inNetwork","published":1,"updated":"2024-10-23T02:23:09.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cm2l9iyqo0000kyxx2wx94cbe","content":"<h1 id=\"这个可怜的前端终于学会了内网穿透\"><a href=\"#这个可怜的前端终于学会了内网穿透\" class=\"headerlink\" title=\"这个可怜的前端终于学会了内网穿透\"></a>这个可怜的前端终于学会了内网穿透</h1><p><a href=\"https://juejin.cn/user/4001878055066237/posts\">九段刀客</a></p>\n<h2 id=\"什么是内网穿透\"><a href=\"#什么是内网穿透\" class=\"headerlink\" title=\"什么是内网穿透\"></a>什么是内网穿透</h2><p><strong>内网穿透</strong>这个词大家肯定都有所耳闻，毕竟都是干这行的嘛！没吃过猪肉还能没见过猪跑啊。不就是让自己电脑启的服务，让远在千里之外的人也能访问到吗？对对对就是这个东西。</p>\n<h2 id=\"什么场景下，让我需要这个东西呢\"><a href=\"#什么场景下，让我需要这个东西呢\" class=\"headerlink\" title=\"什么场景下，让我需要这个东西呢\"></a>什么场景下，让我需要这个东西呢</h2><p>微信支付和小程序的图片安全校验的时候。</p>\n<p>微信支付和图片安全校验都需要给一个notify_url，处理成功后腾讯那边会调用这个接口来通知你结果和信息。</p>\n<p>这个场景下内网穿透就非常重要了，如果你不弄内网穿透，每次都要传到测试服务器上去就会很繁琐，写一点传一次，有问题还得倒腾一次，如果能让你的本地就能实现测试服务器一样的功能，那岂不是完美。</p>\n<p>有朋友会说服务啊，这不是后端的事情吗？这不是越来越卷了吗？</p>\n<h2 id=\"依赖安装和token配置\"><a href=\"#依赖安装和token配置\" class=\"headerlink\" title=\"依赖安装和token配置\"></a>依赖安装和token配置</h2><p>其实很简单哈哈😄,首先拿出我们的前端秘制配方 npm</p>\n<p><code>npm install ngrok -g</code></p>\n<p>它似乎不想我们一步到位，还需要配置一下token，到ngrok.com 注册一个账号 <a href=\"https://link.juejin.cn/?target=https://ngrok.com/\" title=\"https://ngrok.com/\">ngrok官网地址</a></p>\n<p><code>ngrok config add-authtoken xxxxxxxxxxxxxxx</code></p>\n<p><img src=\"https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3204ca5c30e64855829632346f27bc88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=XG7gL17AA81XdT1yt5au66QNIcI=\" alt=\"image.png\"></p>\n<h2 id=\"起飞🛫\"><a href=\"#起飞🛫\" class=\"headerlink\" title=\"起飞🛫\"></a>起飞🛫</h2><p>先把你的nodejs服务搞起来，比如端口是3080,再运行内网穿透</p>\n<p><code>ngrok http http://localhost:3080</code></p>\n<h2 id=\"看看效果\"><a href=\"#看看效果\" class=\"headerlink\" title=\"看看效果\"></a>看看效果</h2><p><img src=\"https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aee65decc61b4dbc9716b34f10c837e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=8g90jOIZXwxqXWvEQ/VRZx/Vs1k=\" alt=\"image.png\"></p>\n","site":{"data":{}},"wordcount":531,"excerpt":"","more":"<h1 id=\"这个可怜的前端终于学会了内网穿透\"><a href=\"#这个可怜的前端终于学会了内网穿透\" class=\"headerlink\" title=\"这个可怜的前端终于学会了内网穿透\"></a>这个可怜的前端终于学会了内网穿透</h1><p><a href=\"https://juejin.cn/user/4001878055066237/posts\">九段刀客</a></p>\n<h2 id=\"什么是内网穿透\"><a href=\"#什么是内网穿透\" class=\"headerlink\" title=\"什么是内网穿透\"></a>什么是内网穿透</h2><p><strong>内网穿透</strong>这个词大家肯定都有所耳闻，毕竟都是干这行的嘛！没吃过猪肉还能没见过猪跑啊。不就是让自己电脑启的服务，让远在千里之外的人也能访问到吗？对对对就是这个东西。</p>\n<h2 id=\"什么场景下，让我需要这个东西呢\"><a href=\"#什么场景下，让我需要这个东西呢\" class=\"headerlink\" title=\"什么场景下，让我需要这个东西呢\"></a>什么场景下，让我需要这个东西呢</h2><p>微信支付和小程序的图片安全校验的时候。</p>\n<p>微信支付和图片安全校验都需要给一个notify_url，处理成功后腾讯那边会调用这个接口来通知你结果和信息。</p>\n<p>这个场景下内网穿透就非常重要了，如果你不弄内网穿透，每次都要传到测试服务器上去就会很繁琐，写一点传一次，有问题还得倒腾一次，如果能让你的本地就能实现测试服务器一样的功能，那岂不是完美。</p>\n<p>有朋友会说服务啊，这不是后端的事情吗？这不是越来越卷了吗？</p>\n<h2 id=\"依赖安装和token配置\"><a href=\"#依赖安装和token配置\" class=\"headerlink\" title=\"依赖安装和token配置\"></a>依赖安装和token配置</h2><p>其实很简单哈哈😄,首先拿出我们的前端秘制配方 npm</p>\n<p><code>npm install ngrok -g</code></p>\n<p>它似乎不想我们一步到位，还需要配置一下token，到ngrok.com 注册一个账号 <a href=\"https://link.juejin.cn/?target=https://ngrok.com/\" title=\"https://ngrok.com/\">ngrok官网地址</a></p>\n<p><code>ngrok config add-authtoken xxxxxxxxxxxxxxx</code></p>\n<p><img src=\"https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/3204ca5c30e64855829632346f27bc88~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=XG7gL17AA81XdT1yt5au66QNIcI=\" alt=\"image.png\"></p>\n<h2 id=\"起飞🛫\"><a href=\"#起飞🛫\" class=\"headerlink\" title=\"起飞🛫\"></a>起飞🛫</h2><p>先把你的nodejs服务搞起来，比如端口是3080,再运行内网穿透</p>\n<p><code>ngrok http http://localhost:3080</code></p>\n<h2 id=\"看看效果\"><a href=\"#看看效果\" class=\"headerlink\" title=\"看看效果\"></a>看看效果</h2><p><img src=\"https://p9-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/aee65decc61b4dbc9716b34f10c837e4~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Lmd5q615YiA5a6i:q75.awebp?rk3s=f64ab15b&x-expires=1729664096&x-signature=8g90jOIZXwxqXWvEQ/VRZx/Vs1k=\" alt=\"image.png\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clyzfl2pg0001lyxx0o9qeyb8","tag_id":"clyzfl2pr0003lyxx5zca58hm","_id":"clyzfl2q00008lyxxf8318dce"},{"post_id":"clyzfl2pt0004lyxx72h69a1o","tag_id":"clyzfl2pz0007lyxx14y2hhjg","_id":"clyzfl2q8000clyxx8npd7odx"},{"post_id":"clyzfl2pw0006lyxx3s2c5q0i","tag_id":"clyzfl2q7000blyxxb408flf1","_id":"clyzfl2q9000elyxxghdm7o2b"},{"post_id":"clyzfl2q3000alyxxa53e9fdg","tag_id":"clyzfl2q9000dlyxxbp3pa93t","_id":"clyzfl2qa000flyxx8eeocqzz"},{"post_id":"clyzfor9f000glyxx8q9oeyf5","tag_id":"clyzfl2pr0003lyxx5zca58hm","_id":"clyzfqnic000hlyxx1nv03l3y"},{"post_id":"clyzhc59b000jlyxxf3a4gvoj","tag_id":"clyzfl2pr0003lyxx5zca58hm","_id":"clyzhd5dz000klyxx7yjigifz"},{"post_id":"clyzhplcy000llyxxdq0aeefr","tag_id":"clyzfl2pr0003lyxx5zca58hm","_id":"clyzhvnhh000mlyxxavp81mdr"},{"post_id":"cm2l9iyqo0000kyxx2wx94cbe","tag_id":"clyzfl2q9000dlyxxbp3pa93t","_id":"cm2l9iyqv0001kyxx03in63hb"}],"Tag":[{"name":"js","_id":"clyzfl2pr0003lyxx5zca58hm"},{"name":"JS","_id":"clyzfl2pz0007lyxx14y2hhjg"},{"name":"reg","_id":"clyzfl2q7000blyxxb408flf1"},{"name":"web","_id":"clyzfl2q9000dlyxxbp3pa93t"}]}}